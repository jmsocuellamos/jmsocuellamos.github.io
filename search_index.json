[["index.html", "Modelos Estadísticos Introducción", " Modelos Estadísticos Asunción M. Mayoral (asun.mayoral@umh.es). Web personal Instituto Universitario de Investigación CIO-UMH Javier Morales (j.morales@umh.es). Web personal Instituto Universitario de Investigación CIO-UMH 2022-02-03 Introducción Este compendio de unidades sobre modelización estadística trata de mostrar una versión aplicada para el tratamiento de los modelos estadísticos más básicos. El objetivo no es mostrar una versión teórica de estos modelos sino una versión aplicada. Se recomienda a los lectores interesado que complementen la teoría de estos modelos con manuales más específicos. Para poder seguir los contenidos aquí expuestos se recomiendan conocimientos básicos de estadística descriptiva, probabilidad e inferencia estadística, así como las funciones de R necesarias para llevar a cabo dichos análisis. Los modelos contenidos en este manual son: Modelos de regresión lineal simple Modelos de regresión lineal múltiple y polinómicos Modelos ANOVA Modelos ANCOVA Modelos aditivos lineales Modelos lineales generalizados Respuesta Binomial Respuesta Poisson Tablas de contingencia Supervivencia "],["antes-de-empezar.html", "Antes de empezar Conceptos básicos del diseño experimental Primeros pasos con R y RStudio Informes prediseñados Librerías de R necesarías", " Antes de empezar La importancia de la estadística dentro del campo experimental siempre ha sido muy relevante, ya que para poder extraer conclusiones de un conjunto de datos experimentales se hace necesaria la utilización de procedimientos estadísticos más o menos sofisticados. Con la irrupción de los ordenadores personales y de los programas estadísticos para legos en la materia, así como la explosión tecnológica que estamos viviendo en los últimos años, la importancia de un correcto estudio estadístico de los datos experimentales se hace más necesaria que nunca. Se siguen publicando trabajos de investigación basados en datos experimentales donde el tratamiento estadístico de la información allí recogida puede considerarse como decepcionante. Con esta materia pretendemos guiar al estudiante en un correcto uso y análisis de las técnicas estadísticas más habituales en los diseños experimentales. El tratamiento estadístico de datos experimentales se puede caracterizar en dos grandes áreas: estudios descriptivos y análisis y modelización. Los estudios descriptivos se centran en el procesado de los datos experimentales obtenidos con el objetivo de establecer o reflejar posibles patrones o tendencias en su comportamiento. Se engloban dentro de este ámbito todas la técnicas estadísticas que permiten los resúmenes numéricos y gráficos de la información observada, así como la detección de observaciones anómalas, la transformación y el filtrado de los datos experimentales. Sin embargo, los estudios descriptivos tienen la gran limitación de que sus resultados están circunscritos a los datos observados, y por tanto no se pueden generalizar a la población más general de la que se han obtenido. En el análisis y modelización se pretende generalizar los posibles patrones de comportamiento observados, en la fase descriptiva, mediante la construcción de modelos que nos permiten aproximar el comportamiento de datos experimentales no observados. Evidentemente la construcción de dichos modelos estadísticos no es una tarea rutinaria que debe tomarse a la ligera. La propia naturaleza de los datos observados puede dar una idea de los posibles modelos que se pueden utilizar, pero el modelo final obtenido es el resultados de un proceso iterativo de construcción, verificación y validación que puede resultar costoso en algunas situaciones. La modelización estadística resulta relevante para representar el comportamiento de los datos experimentales de la forma más sencilla posible mediante modelos matemáticos donde se introduce de forma natural la incertidumbre de cualquier diseño experimental. Esta asignatura se centrará en la fase de modelización pero para poder llegar a comprender su naturaleza es necesario introducir primero los conceptos básicos de cualquier estudio estadístico, así como los procedimientos de estadística descriptiva y el estudio de la aleatoriedad en los diseños experimentales. Este tema establece las definiciones básicas de cualquier estudio estadístico sobre diferentes ejemplos e introduce la nomenclatura básica de los modelos estadísticos que estudiaremos más adelante. Usar la estadística no necesariamente es sinónimo de utilizar palabras raras o de hacer cálculos complicados. Significa que deseamos ver la realidad de forma objetiva, a través de datos que reflejen de la mejor manera posible qué es lo que está ocurriendo. Una vez se tienen los datos hay que saber sacarles la información y saberla plasmar de forma clara y convincente. Conceptos básicos del diseño experimental En esta sección presentamos los conceptos básicos que utilizaremos a lo largo de la materia. Se trata únicamente de un resumen muy esquemática, pero nos sirve para sentar las bases de los temas siguientes. Objetivo del diseño experimental El objetivo de cualquier diseño experimental es aquellos que pretendemos estudiar en función del tipo de información que se ha recogido y del tipo de premisas establecidas antes de la recolección de los datos. Además es importante establecer el número de repeticiones del experimento que vamos a realizar, ya que eso condicionará el análisis de dichos datos. Si nuestro diseño experimental es muy complejo puede ocurrir que plantemos más de un objetivo. Ejemplo 1 (Degradación compuesto orgánico). Se va a realizar un experimento para conocer el tiempo que tarda en degradarse un compuesto orgánico. En este caso nuestro objetivo es el tiempo hasta la degradación. Si el experimneto considera diferentes tipos de compuestos nuestro objetivo podría ser comparar el tiempo de degradación en función del tipo de compuesto. Población y muestra Se define la población como el conjunto de sujetos u objetos que son de interés para el objetivo u objetivos planteados en nuestro diseño experimental. EL problema principal es que la población de sujetos u objetos suele ser demasiado grande para poder analizarla de forma completa, y por tanto debemos acudir a un subconjunto de dicha población para llevar a cabo nuestro diseño experimental. Se define la muestra como el subconjunto de la población a la que accedemos para obtener la información necesaria de cara a responder de la forma más precisa posible al objetivo u objetivos planteados. Medidas y escalas de medida Una medida es un número o atributo que se puede calcular para cada uno de los miembros de la población que está relacionado directamente con el objetivo de interés de la investigación. El conjunto de medidas obtenidas para cada uno de los elementos muestrales se denominan datos muestrales. EL conjunto de medidas que se pueden observar y registrar para un conjunto de sujetos u objetos bajo investigación se denominan variables. Por tanto, una variable es el conjunto de valores que puede tomar cierta característica de la población sobre la que se realiza el estudio estadístico. Se distinguen dos tipos que pasamos a describir a continuación. Variables cualitativas Son el tipo de variables que como su nombre lo indica expresan distintas cualidades, características o modalidad. Cada modalidad que se presenta se denomina atributo o categoría, y la medición consiste en una clasificación de dichos atributos. Las variables cualitativas pueden ser dicotómicas cuando sólo pueden tomar dos valores posibles, como sí y no, hombre y mujer o ser politómicas cuando pueden adquirir tres o más valores. Dentro de ellas podemos distinguir: Variable cualitativa ordinal: La variable puede tomar distintos valores ordenados siguiendo una escala establecida, aunque no es necesario que el intervalo entre mediciones sea uniforme, por ejemplo: leve, moderado, fuerte. Variable cualitativa nominal: En esta variable los valores no pueden ser sometidos a un criterio de orden, como por ejemplo los colores. Variables cuantitativas Son las variables que toman como argumento cantidades numéricas. Las variables cuantitativas además pueden ser: Variable discreta: Es la variable que presenta separaciones o interrupciones en la escala de valores que puede tomar. Estas separaciones o interrupciones indican la ausencia de valores entre los distintos valores específicos que la variable pueda asumir. Ejemplo: El número de hijos (1, 2, 3, 4, 5). En muchas ocasiones una variable cualitativa ordinal puede ser interpretada como una variable discreta asociando a las categorías de la variable valores numéricos respetando el orden o escala establecida. Por ejemplo a la escala leve, moderado y fuerte le podríamos asociar la escala 1, 2 y 3 para mantener el orden. Variable continua: Es la variable que puede adquirir cualquier valor dentro de un intervalo especificado de valores. Por ejemplo el peso (2,3 kg, 2,4 kg, 2,5 kg,…), la altura (1,64 m, 1,65 m, 1,66 m,…), o el salario. Solamente se está limitado por la precisión del aparato medidor, en teoría permiten que existan valores infinitos entre dos valores observados. De forma habitual, la estructura de cualquier banco de datos (asociado a un diseño experimental) tiene una estructura matricial donde en las filas se colocan los sujetos bajo estudio y en las columnas se sitúan las variables medidas para cada uno de ellos. Asociada a cada variable de nuestro banco de datos se puede establecer lo que conocemos como parámetro o parámetros de interés de la variable. Ejemplo 2 (Variable de interés). Para el diseño experimental del estudio de la degradación del compuesto orgánico presentado en el ejemplo 1.1, la variable de interés es de tipo continuo y viene dada por el tiempo de degradación asociado a cada repetición del experimento. Sin embargo, a la hora de extraer conclusiones no podemos presentar todo el conjunto de datos sino que recurrimos a un resumen de dichos datos. Parámetros poblacionales y estadísticos Asociado a cada variable se puede establecer lo que conocemos como parámetro o parámetros de interés de la variable. En el ejemplo anterior el parámetro de interés es el tiempo medio de degradación. Dado que generalmente no es posible examinar toda la población y debemos recurrir a una muestra de dicha población, es imposible conocer el verdadero valor del parámetro asociado con dicha variable. Para sortear este problema definimos el estadístico como una realización del parámetro para los datos muestrales observados. Por tanto el valor del estadístico (denominado estimación) varia entre dos muestras de las misma población. Cuanto mayor es la muestra más se parecerá el valor del estadístico al del parámetro. En ocasiones ocurrirá que el número de parámetros asociado con una variable no es único, ya que se pueden establecer varios parámetros para estudiar el comportamiento de una variable. En el caso de variables de tipo cuantitativo siempre existen dos parámetros de interés: la media y la desviación típica. El primero nos indica como se sitúan los datos mientras que el segundo nos indica como se reparten los datos muestrales alrededor de la media. Ejemplo 3 (Parámetro de interés). Para el diseño experimental del estudio de la degradación del compuesto orgánico presentado en el ejemplo 1.1, el parámetro poblacional de interés es el tiempo medio de degradación, mientras que el estadístico es la media del tiempo de degradación observado para los sujetos de la muestra. Distinguimos entonces entre media poblacional (parámetro) y media muestral (estadístico). Primeros pasos con R y RStudio Para poder utilizar el código expuesto en estos materiales es necesario la instalación del programa R, del programa RStudio y de diferentes librerías de R. En los puntos siguientes se describe brevemente cada uno de estos puntos. Se recomienda además la consulta de los materiales electrónicos siguientes para complmentar la formación. Childs, D. Z. (2017). APS 135: Introduction to Exploratory Data Analysis with R. Versión electrónica. Grosser, M. 2017. Tidyverse Cookbook. Versión electrónica incompleta. Wickham, H. 2015. Advanced R. CRC Press. Versión electrónica resumida. Wickham, H. 2010. ggplot2. Third Edition. Springer. Recursos electrónicos. Wickham, H. &amp; Grolemund, G. 2016. R for Data Science. O’Reilly. Versión electrónica resumida. Instalación y puesta en marcha Instalación de R y RStudio. Leer el capítulo de introducción del libro de Childs (2017) e instalar ambos programas descargándolos de sus correspondientes webs: Para instalar el programa R: https://cran.r-project.org/ Para instalar RStudio: https://rstudio.com/ Primeros pasos en R y RStudio. Leer los capítulos 1, 2, y 3 de Childs (2017), el capítulo 4 de Wickham (2015), y los capítulos 4 y 6 de Wickham (2016) para un desarrollo más amplio. Realizar los ejercicios que van a apareciendo a lo largo de los capítulos. Estructuras de datos. Leer los capítulos 4, 5, 6 y 9 de Childs (2017) para una breve introducción y los capítulos 2 y 3 de Wickham (2015) para completar la información. Realiza los ejercicios que van apareciendo. Instalación y uso de librerías en RStudio. Leer el capítulo 8 de Childs (2017) e instala las librerías tidyverse, stringr, forcats, lubridate, magrittr, broom y datasets mediante la consola de RStudio. Carga las librerías con el comando library para comprobar que se han instalando de forma correcta. Creación de proyectos y entornos de trabajo. Leer el capítulo 8 de Wickham (2016). Crea un proyecto para esta unidad, selecciona el directorio de trabajo donde se encuentra situado el proyecto, y guarda el entorno de trabajo. Informes prediseñados En los últimos tiempos se ha puesto de modo la creación de informes directos apartir del código utilizado en Rstudio mediante la creación de documentos específicos. Su puede consulyar una guía sencilla de uso en enlace. Un desaroollo más completo se puede ver en este enlace. También se puede consultar este vídeo. Librerías de R necesarías Para poder utilizar el código expuesto en estos materiales es necesario la instalación de diferentes librerías de R. A continuación se encuentra el código para cargar dichas librerías. Para algún análisis especifíco se utilizará alguna librería accesoria que será cargada con el comando require(). library(tidyverse) library(tidymodels) library(stringr) library(forcats) library(lubridate) library(magrittr) library(broom) library(pubh) library(datasets) library(lmtest) library(MASS) library(kableExtra) library(mosaic) library(latex2exp) library(moonBook) library(sjlabelled) library(sjPlot) library(reshape2) library(olsrr) library(ggfortify) library(mgcv) library(modelr) library(alr4) library(equatiomatic) library(survival) library(survminer) Configuramos además el tema de los gráficos para que tengan un aspecto más limpio y más fácil de exportar en formato pdf o word. Para ellos utilizamos la función theme_set(). theme_set(theme_sjplot2()) "],["intro.html", "Unidad 1 Introducción 1.1 Conceptos básicos 1.2 Ejercicios", " Unidad 1 Introducción La importancia de la estadística dentro del campo experimental siempre ha sido muy relevante, ya que para poder extraer conclusiones de un conjunto de datos experimentales se hace necesaria la utilización de procedimientos estadísticos más o menos sofisticados. Con la irrupción de los ordenadores personales y de los programas estadísticos para legos en la materia, así como la explosión tecnológica que estamos viviendo en los últimos años, la importancia de un correcto estudio estadístico de los datos experimentales se hace más necesaria que nunca. Se siguen publicando trabajos de investigación basados en datos experimentales donde el tratamiento estadístico de la información allí recogida puede considerarse como decepcionante. Con esta materia pretendemos guiar al estudiante en un correcto uso y análisis de las técnicas estadísticas más habituales en los diseños experimentales. El tratamiento estadístico de datos experimentales se puede caracterizar en dos grandes áreas: estudios descriptivos y análisis y modelización. Los estudios descriptivos se centran en el procesado de los datos experimentales obtenidos con el objetivo de establecer o reflejar posibles patrones o tendencias en su comportamiento. Se engloban dentro de este ámbito todas la técnicas estadísticas que permiten los resúmenes numéricos y gráficos de la información observada, así como la detección de observaciones anómalas, la transformación y el filtrado de los datos experimentales. Sin embargo, los estudios descriptivos tienen la gran limitación de que sus resultados están circunscritos a los datos observados, y por tanto no se pueden generalizar a la población más general de la que se han obtenido. En el análisis y modelización se pretende generalizar los posibles patrones de comportamiento observados, en la fase descriptiva, mediante la construcción de modelos que nos permiten aproximar el comportamiento de datos experimentales no observados. Evidentemente la construcción de dichos modelos estadísticos no es una tarea rutinaria que debe tomarse a la ligera. La propia naturaleza de los datos observados puede dar una idea de los posibles modelos que se pueden utilizar, pero el modelo final obtenido es el resultados de un proceso iterativo de construcción, verificación y validación que puede resultar costoso en algunas situaciones. La modelización estadística resulta relevante para representar el comportamiento de los datos experimentales de la forma más sencilla posible mediante modelos matemáticos donde se introduce de forma natural la incertidumbre de cualquier diseño experimental. Esta asignatura se centrará en la fase de modelización pero para poder llegar a comprender su naturaleza es necesario introducir primero los conceptos básicos de cualquier estudio estadístico, así como los procedimientos de estadística descriptiva y el estudio de la aleatoriedad en los diseños experimentales. Este tema establece las definiciones básicas de cualquier estudio estadístico sobre diferentes ejemplos e introduce la nomenclatura básica de los modelos estadísticos que estudiaremos más adelante. Usar la estadística no necesariamente es sinónimo de utilizar palabras raras o de hacer cálculos complicados. Significa que deseamos ver la realidad de forma objetiva, a través de datos que reflejen de la mejor manera posible qué es lo que está ocurriendo. Una vez se tienen los datos hay que saber sacarles la información y saberla plasmar de forma clara y convincente. 1.1 Conceptos básicos En esta sección presentamos los conceptos básicos que utilizaremos a lo largo de la materia. Se trata únicamente de un resumen muy esquemática, pero nos sirve para sentar las bases de los temas siguientes. 1.1.1 Objetivo del diseño experimental El objetivo de cualquier diseño experimental es aquellos que pretendemos estudiar en función del tipo de información que se ha recogido y del tipo de premisas establecidas antes de la recolección de los datos. Además es importante establecer el número de repeticiones del experimento que vamos a realizar, ya que eso condicionará el análisis de dichos datos. Si nuestro diseño experimental es muy complejo puede ocurrir que plantemos más de un objetivo. ffalse{-91-68-101-103-114-97-100-97-99-105-243-110-32-99-111-109-112-117-101-115-116-111-32-111-114-103-225-110-105-99-111-93-} Ejemplo 1.1 \\iffalse (Degradación compuesto orgánico) Se va a realizar un experimento para conocer el tiempo que tarda en degradarse un compuesto orgánico. En este caso nuestro objetivo es el tiempo hasta la degradación. Si el experimneto considera diferentes tipos de compuestos nuestro objetivo podría ser comparar el tiempo de degradación en función del tipo de compuesto. 1.1.2 Población y muestra Se define la población como el conjunto de sujetos u objetos que son de interés para el objetivo u objetivos planteados en nuestro diseño experimental. EL problema principal es que la población de sujetos u objetos suele ser demasiado grande para poder analizarla de forma completa, y por tanto debemos acudir a un subconjunto de dicha población para llevar a cabo nuestro diseño experimental. Se define la muestra como el subconjunto de la población a la que accedemos para obtener la información necesaria de cara a responder de la forma más precisa posible al objetivo u objetivos planteados. 1.1.3 Medidas y escalas de medida Una medida es un número o atributo que se puede calcular para cada uno de los miembros de la población que está relacionado directamente con el objetivo de interés de la investigación. El conjunto de medidas obtenidas para cada uno de los elementos muestrales se denominan datos muestrales. EL conjunto de medidas que se pueden observar y registrar para un conjunto de sujetos u objetos bajo investigación se denominan variables. Por tanto, una variable es el conjunto de valores que puede tomar cierta característica de la población sobre la que se realiza el estudio estadístico. Se distinguen dos tipos que pasamos a describir a continuación. 1.1.3.1 Variables cualitativas Son el tipo de variables que como su nombre lo indica expresan distintas cualidades, características o modalidad. Cada modalidad que se presenta se denomina atributo o categoría, y la medición consiste en una clasificación de dichos atributos. Las variables cualitativas pueden ser dicotómicas cuando sólo pueden tomar dos valores posibles, como sí y no, hombre y mujer o ser politómicas cuando pueden adquirir tres o más valores. Dentro de ellas podemos distinguir: Variable cualitativa ordinal: La variable puede tomar distintos valores ordenados siguiendo una escala establecida, aunque no es necesario que el intervalo entre mediciones sea uniforme, por ejemplo: leve, moderado, fuerte. Variable cualitativa nominal: En esta variable los valores no pueden ser sometidos a un criterio de orden, como por ejemplo los colores. 1.1.3.2 Variables cuantitativas Son las variables que toman como argumento cantidades numéricas. Las variables cuantitativas además pueden ser: Variable discreta: Es la variable que presenta separaciones o interrupciones en la escala de valores que puede tomar. Estas separaciones o interrupciones indican la ausencia de valores entre los distintos valores específicos que la variable pueda asumir. Ejemplo: El número de hijos (1, 2, 3, 4, 5). En muchas ocasiones una variable cualitativa ordinal puede ser interpretada como una variable discreta asociando a las categorías de la variable valores numéricos respetando el orden o escala establecida. Por ejemplo a la escala leve, moderado y fuerte le podríamos asociar la escala 1, 2 y 3 para mantener el orden. Variable continua: Es la variable que puede adquirir cualquier valor dentro de un intervalo especificado de valores. Por ejemplo el peso (2,3 kg, 2,4 kg, 2,5 kg,…), la altura (1,64 m, 1,65 m, 1,66 m,…), o el salario. Solamente se está limitado por la precisión del aparato medidor, en teoría permiten que existan valores infinitos entre dos valores observados. De forma habitual, la estructura de cualquier banco de datos (asociado a un diseño experimental) tiene una estructura matricial donde en las filas se colocan los sujetos bajo estudio y en las columnas se sitúan las variables medidas para cada uno de ellos. Asociada a cada variable de nuestro banco de datos se puede establecer lo que conocemos como parámetro o parámetros de interés de la variable. ffalse{-91-86-97-114-105-97-98-108-101-32-100-101-32-105-110-116-101-114-233-115-93-} Ejemplo 1.2 \\iffalse (Variable de interés) Para el diseño experimental del estudio de la degradación del compuesto orgánico presentado en el ejemplo 1.1, la variable de interés es de tipo continuo y viene dada por el tiempo de degradación asociado a cada repetición del experimento. Sin embargo, a la hora de extraer conclusiones no podemos presentar todo el conjunto de datos sino que recurrimos a un resumen de dichos datos. 1.1.4 Parámetros poblacionales y estadísticos Asociado a cada variable se puede establecer lo que conocemos como parámetro o parámetros de interés de la variable. En el ejemplo anterior el parámetro de interés es el tiempo medio de degradación. Dado que generalmente no es posible examinar toda la población y debemos recurrir a una muestra de dicha población, es imposible conocer el verdadero valor del parámetro asociado con dicha variable. Para sortear este problema definimos el estadístico como una realización del parámetro para los datos muestrales observados. Por tanto el valor del estadístico (denominado estimación) varia entre dos muestras de las misma población. Cuanto mayor es la muestra más se parecerá el valor del estadístico al del parámetro. En ocasiones ocurrirá que el número de parámetros asociado con una variable no es único, ya que se pueden establecer varios parámetros para estudiar el comportamiento de una variable. En el caso de variables de tipo cuantitativo siempre existen dos parámetros de interés: la media y la desviación típica. El primero nos indica como se sitúan los datos mientras que el segundo nos indica como se reparten los datos muestrales alrededor de la media. ffalse{-91-80-97-114-225-109-101-116-114-111-32-100-101-32-105-110-116-101-114-233-115-93-} Ejemplo 1.3 \\iffalse (Parámetro de interés) Para el diseño experimental del estudio de la degradación del compuesto orgánico presentado en el ejemplo 1.1, el parámetro poblacional de interés es el tiempo medio de degradación, mientras que el estadístico es la media del tiempo de degradación observado para los sujetos de la muestra. Distinguimos entonces entre media poblacional (parámetro) y media muestral (estadístico). 1.2 Ejercicios A continuación se presentan un conjunto de ejercicios con los que vamos a trabajar los conceptos presentados en esta unidad. Algunos de ellos los usaremos en las unidades siguientes. Al enunciado de cada ejercicio le acompaña el código de R necesario para la carga de los bancos de datos. Antes de leer los bancos de datos no debes olvidar cargar las librerias necesarias para su manipulación (ver Introducción). Ejercicio 1.1 Un hospital está llevando a cabo un procedimiento de rutina en los pacientes ingresados para detectar niveles plásmáticos de colesterol total (en mg/ml) excesivamente altos. Más concretamente el estudio se centra en un grupo de 24 pacientes con hiperlipoproteinemia, que es un trastorno metabólico caracterizado por niveles elevados de lipoproteínas en la sangre que pueden asociarse con enfermedad coronaria. Se sospecha además que la edad puede tener cierta relevancia en los niveles de colesterol en sangre para este tipo de pacientes (ver Krzanowski (1998)). # Creación del banco de datos edad &lt;- c(46,57,22,22,28,29,20,25,43,63,49,34,52,28,57,40, 52,24,30,36,33,48,58,50) nivel &lt;- c(3.5,4.5,2.2,2.5,2.3,3.3,1.9,3.0,3.8,4.6,4.0,3.2, 4.0,2.9,4.1,3.2,4.3,2.5, 2.6,3.8,3.0,4.2,3.9,3.3) datos &lt;- data.frame(edad = edad,nivel = nivel) # Visualización de los cinco primeros casos kable( head(datos,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de colesterol y edad en pacientes con hiperlipoproteinemia.&#39;) Tabla 1.1: Datos de colesterol y edad en pacientes con hiperlipoproteinemia. edad nivel 46 3.5 57 4.5 22 2.2 22 2.5 28 2.3 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.2 Los datos para este ejemplo se obtuvieron del Departamento de Conservación del Estado de Nueva York (datos sobre el ozono) y del Servicio Meteorológico Nacional (datos meteorológicos). Los datos recogidos son las lecturas diarias de los siguientes valores de calidad del aire desde el 1 de mayo de 1973 y el 30 de septiembre de 1973 (153 días en total) Banco de datos de Chambers et al. (1983) # Carga de datos data(airquality) # Descripción del banco de datos help(&quot;airquality&quot;) # Visualización de los cinco primeros casos kable( head(airquality,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de calidad del aire.&#39;) Tabla 1.2: Datos de calidad del aire. Ozone Solar.R Wind Temp Month Day 41 190 7.4 67 5 1 36 118 8.0 72 5 2 12 149 12.6 74 5 3 18 313 11.5 62 5 4 NA NA 14.3 56 5 5 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.3 Los datos para este ejemplo corresponden a un estudio caso-control de cáncer de esófago en Ille-et-Vilaine, Francia. Las características recogidas corresponden a un conjunto de 88 sujetos. Banco de datos de Breslow and Day (1980) # Carga de datos data(esoph) # Descripción del banco de datos help(&quot;esoph&quot;) # Visualización de los cinco primeros casos kable( head(esoph,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de cáncer de esófago.&#39;) Tabla 1.3: Datos de cáncer de esófago. agegp alcgp tobgp ncases ncontrols 25-34 0-39g/day 0-9g/day 0 40 25-34 0-39g/day 10-19 0 10 25-34 0-39g/day 20-29 0 6 25-34 0-39g/day 30+ 0 5 25-34 40-79 0-9g/day 0 27 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.4 Este conjunto de datos contiene un subconjunto de los datos de economía de combustible que la EPA pone a disposición en http://fueleconomy.gov. Contiene solamente información sobre los modelos de vehículo que tuvieron una nueva versión cada año entre 1999 y 2008 - esto se utiliza habitualmenete como una aproximación para la popularidad del coche. El banco de datos está compuesto por 234 regitros con información sobre 11 variables diferentes. # Carga de datos data(mpg) # Descripción del banco de datos help(&quot;mpg&quot;) # Visualización de los cinco primeros casos kable( head(mpg,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de economía de combustible.&#39;) Tabla 1.4: Datos de economía de combustible. manufacturer model displ year cyl trans drv cty hwy fl class audi a4 1.8 1999 4 auto(l5) f 18 29 p compact audi a4 1.8 1999 4 manual(m5) f 21 29 p compact audi a4 2.0 2008 4 manual(m6) f 20 31 p compact audi a4 2.0 2008 4 auto(av) f 21 30 p compact audi a4 2.8 1999 6 auto(l5) f 16 26 p compact ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.5 Este conjunto contiene información sobre precios y otras características de casi 54.000 diamantes. # Carga de datos data(diamonds) # Descripción del banco de datos help(&quot;diamonds&quot;) # Visualización de los cinco primeros casos kable( head(diamonds,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de características de los diamantes.&#39;) Tabla 1.5: Datos de características de los diamantes. carat cut color clarity depth table price x y z 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 0.29 Premium I VS2 62.4 58 334 4.20 4.23 2.63 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.6 El banco de datos de Puromycin contiene 23 mediciones sobre la velocidad de reacción enzimática frente a la concentración de sustrato para células tratadas o no tratadas con Puromicina. # Carga de datos data(Puromycin) # Descripción del banco de datos help(&quot;Puromycin&quot;) # Visualización de los cinco primeros casos kable( head(Puromycin,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de características de los diamantes.&#39;) Tabla 1.6: Datos de características de los diamantes. conc rate state 0.02 76 treated 0.02 47 treated 0.06 97 treated 0.06 107 treated 0.11 123 treated ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.7 El banco de datos presenta la información referida al nacimiento y mortalidad infantil de 800 niños nacidos en el estado de Carolina del Norte. Las variables consideradas en el estudio son: plural: Número de hijos nacidos del embarazo. sex: Sexo del bebe. mage: Edad de la madre. weeks: Semanas completas de gestación. marital: Estado matrimonial (“married” = 1; “not married” = 2). racemom: Raza de la madre (“other non white” = 0,“White” = 1,“Black” = 2, “America indian” = 3,“Chinese” = 4,“Hawaiian” = 5, “Filipino” = 6,“Other asian” = 7). hispmom: Madre de origen hispánico (“Cuban” = C,“Mexican” = M,“Non-Hispanic” = N, “Other” = O,“Puerto Rican” = P, “Central/South american”=S,“Not classificable”=U). gained: Peso ganado durante el embarazo (en libras). smoke: Madre fumadora (“Yes”=1,“No”=0). drink: Madre bebedora (“Yes”=1,“No”=0). tounces: Peso del bebe (en onzas). tgrams: Peso del bebe (en gramos). low: Bebe de poco peso (“Yes”=1,“No”=0). premie: Bebe prematuro (“Yes”=1,“No”=0). Datos en Daniel (2005) (pag. 56) # Carga de datos NCBIRTH800 = read_csv(&quot;https://goo.gl/mB9Jcn&quot;, col_types = &quot;dcddcccdccddcc&quot;) # Recodificación de factores NCBIRTH800 = NCBIRTH800 %&gt;% mutate(sex=fct_recode(sex,&quot;male&quot;=&quot;1&quot;,&quot;female&quot;=&quot;2&quot;), marital=fct_recode(marital,&quot;married&quot;=&quot;1&quot;,&quot;not married&quot;=&quot;2&quot;), racemom=fct_recode(racemom,&quot;other non white&quot;=&quot;0&quot;,&quot;White&quot;=&quot;1&quot;,&quot;Black&quot;=&quot;2&quot;, &quot;America indian&quot;=&quot;3&quot;,&quot;Chinese&quot;=&quot;4&quot;,&quot;Hawaiian&quot;=&quot;5&quot;, &quot;Filipino&quot;=&quot;6&quot;,&quot;Other asian&quot;=&quot;7&quot;,&quot;Other&quot;=&quot;8&quot;), hispmom=fct_recode(hispmom,&quot;Cuban&quot;=&quot;C&quot;,&quot;Mexican&quot;=&quot;M&quot;,&quot;Non-Hispanic&quot;=&quot;N&quot;, &quot;Other&quot;=&quot;O&quot;,&quot;Puerto Rican&quot;=&quot;P&quot;,&quot;Central/South american&quot;=&quot;S&quot;, &quot;U&quot;=&quot;Not classificable&quot;), smoke=fct_recode(smoke,&quot;Yes&quot;=&quot;1&quot;,&quot;No&quot;=&quot;0&quot;), drink=fct_recode(drink,&quot;Yes&quot;=&quot;1&quot;,&quot;No&quot;=&quot;0&quot;), low=fct_recode(low,&quot;Yes&quot;=&quot;1&quot;,&quot;No&quot;=&quot;0&quot;), premie=fct_recode(premie,&quot;Yes&quot;=&quot;1&quot;,&quot;No&quot;=&quot;0&quot;)) # Visualización de los cinco primeros casos kable( head(NCBIRTH800,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de nacimientos.&#39;) Tabla 1.7: Datos de nacimientos. plural sex mage weeks marital racemom hispmom gained smoke drink tounces tgrams low premie 1 male 32 40 married White Non-Hispanic 38 No No 111 3146.85 No No 1 female 32 37 married White Non-Hispanic 34 No No 116 3288.60 No No 1 male 27 39 married White Non-Hispanic 12 No No 138 3912.30 No No 1 male 27 39 married White Non-Hispanic 15 No No 136 3855.60 No No 1 male 25 39 married White Non-Hispanic 32 No No 121 3430.35 No No ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.8 Los datos corresponden a las mediciones de los niveles de colesterol de un grupo de 1000 sujetos. Las variables consideradas en el estudio son: SUBJ: Identificador del sujeto. CHOLEST: Nivel de colesterol. Datos en Daniel (2005) (pag. 206) # Carga de datos CHOLEST=read_csv(&quot;https://goo.gl/b5ZAb1&quot;, col_types = &quot;id&quot;) # Visualización de los cinco primeros casos kable( head(CHOLEST,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de colesterol.&#39;) Tabla 1.8: Datos de colesterol. SUBJ CHOLEST 1 231 2 219 3 216 4 199 5 159 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.9 Los datos corresponden a las mediciones de las cabezas de 1000 sujetos emparejados de dos a dos. Datos en Daniel (2005) (pag. 297) # Carga de datos HEADCIR=read_csv(&quot;https://goo.gl/juWJEu&quot;, col_types = &quot;idd&quot;) # Visualización de los cinco primeros casos kable( head(HEADCIR,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de cabezas.&#39;) Tabla 1.9: Datos de cabezas. PAIR SCA NC 1 50.3 53.2 2 55.2 58.1 3 54.5 56.0 4 49.7 53.7 5 51.5 55.5 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.10 Los datos corresponden a las mediciones de las niveles de la creatina fosfoquinasa para dos grupos de sujetos. En total hay 2010 sujetos y las variables consideradas en el estudio son: SUBJ: Sujeto. Grupo: Grupo al que se encuentra asignado cada sujeto del estudio (“A” o “B”). cretine: Nivel de creatinina para cada sujeto. Datos en Daniel (2005) (pag. 297) # Carga de datos PCKDATA =read_csv(&quot;https://goo.gl/W8Bfgv&quot;, col_types = &quot;idd&quot;) # Visualización de los cinco primeros casos kable( head(PCKDATA,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos del nivel de creatinina.&#39;) Tabla 1.10: Datos del nivel de creatinina. SUBJ A B 1 193 250 2 90 173 3 120 135 4 154 49 5 149 83 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.11 La información recogida corresponde a los datos sialicos ligados a los lípidos séricos. Se ha llevado a cabo un estudio para determinar si las mediciones de suero podrían ser de utilidad en la detección de cáncer de mama. Las mediciones son para cuatro poblaciones con un total de 1600 registros. Las variables consideradas son: OBSERV: Sujeto. Grupo: Grupo al que se encuentra asignado cada sujeto del estudio (“A,” “B,” “C,” “D”). sace: Nivel de suero para cada sujeto. Datos en Daniel (2005) (pag. 403) # Carga de datos SACEDATA =read_csv(&quot;https://goo.gl/FwMcTu&quot;, col_types = &quot;idddd&quot;) # Visualización de los cinco primeros casos kable( head(SACEDATA,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de mediciones de suero.&#39;) Tabla 1.11: Datos de mediciones de suero. OBSERV A B C D 1 108.4 198.3 89.1 64.8 2 73.8 174.1 117.0 70.4 3 65.9 168.2 113.3 65.0 4 86.7 189.9 108.4 85.6 5 102.7 169.9 132.1 98.5 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? Ejercicio 1.12 Un grupo de varones adultos con edades comprendidas entre 30 y 65 años participaron en un estudio para investigar la relación entre el consumo de carne y el colesterol. Los sujetos fueron organizados en tres grupos de acuerdo a tres dietas diferentes con una duración de 20 semanas. Las variables consideradas son: SUBJ: Sujeto. Dieta: Tipo de dieta (“BEEF” = carne de vaca unicamente, “PORK” = carne de cerdo unicamente, “C” = carne de pollo y pescado unicamente). chol: Nivel de colesterol. Datos en Daniel (2005) (pag. 404) # Carga de datos SERUMCHO =read_csv(&quot;https://goo.gl/ghxka2&quot;, col_types = &quot;iddd&quot;) # Visualización de los cinco primeros casos kable( head(SERUMCHO,5), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos de nivel de colesterol.&#39;) Tabla 1.12: Datos de nivel de colesterol. SUBJ BEEF PORK CHFISH 1 241 245 249 2 218 197 222 3 261 199 221 4 190 162 215 5 238 191 207 ¿Cuál consideras que es el objetivo principal del estudio? ¿se podrían establecer objetivos secundarios? ¿De qué tipo son las variables recogidas? ¿Cuál puede ser el parámetro o parámetros de interés teniendo en cuenta el objetivo u objetivos planteados? References "],["aed.html", "Unidad 2 Análisis exploratorio de datos 2.1 Objetivos 2.2 Variabilidad 2.3 Procesado inicial 2.4 Análisis Descriptivo inicial 2.5 Análisis Descriptivo avanzado 2.6 Librería de interés", " Unidad 2 Análisis exploratorio de datos Esta unidad mostrará cómo utilizar la visualización y la transformación para explorar los datos de un diseño experimental de una manera sistemática, una tarea que los estadísticos llaman análisis exploratorio de datos, o AED (EDA en inglés) para abreviar. Los contenidos para este tema se han obtenido de Wickham and Grolemund (2016). EDA es un ciclo iterativo en el que el investigador debe: este caso se irán mezclando los contenidos teóricos con los prácticos para ir mostrando el funcionamiento de las diferentes funciones y procedimientos para el análisis inicial de nuestro banco de datos. Generar preguntas sobre tus datos. Buscar respuestas visualizando, transformando y modelando sus datos. Usar lo que aprende para refinar sus preguntas y / o generar nuevas preguntas. EDA no es un proceso formal con un conjunto estricto de reglas. Más que nada, EDA es un estado mental. Durante las fases iniciales de EDA, debe sentirse libre de investigar cada idea que se le ocurra. Algunas de estas ideas funcionarán, y algunas serán callejones sin salida. A medida que continúe su exploración, se dirigirá a algunas áreas particularmente productivas que eventualmente escribirá y comunicará a otros. El EDA es una parte importante de cualquier análisis de datos porque siempre debe investigar la calidad de sus datos. La limpieza de datos es solo una aplicación de EDA: el investigador debe hacer preguntas sobre si sus datos cumplen con sus expectativas o no. Para realizar la limpieza de datos, deberá implementar todas las herramientas de EDA: visualización, transformación y modelado. 2.1 Objetivos El objetivo durante EDA es desarrollar una comprensión de los datos experimentales recogidos. La forma más fácil de hacerlo es utilizar preguntas como herramientas para guiar su investigación. Cuando se hace una pregunta, la pregunta centra la atención del investigador en una parte específica del conjunto de datos y le ayuda a decidir qué gráficos, modelos o transformaciones realizar. EDA es fundamentalmente un proceso creativo. Como la mayoría de los procesos creativos, la clave para hacer preguntas de calidad es generar una gran cantidad de preguntas. Es difícil hacer preguntas reveladoras al comienzo del análisis porque el investigador no sabe qué información contiene su conjunto de datos. Por otro lado, cada nueva pregunta que haga le expondrá a un nuevo aspecto de sus datos y aumentará sus posibilidades de hacer un descubrimiento. Se puede profundizar rápidamente en las partes más interesantes de los datos experimentales recogidos y desarrollar una serie de preguntas que invitan a la reflexión, si se realiza un seguimiento de cada pregunta con una nueva pregunta basada en lo que se encuentre. No hay una regla sobre qué preguntas se deben hacer para guiar la investigación, ya que debe ser el investigador en función de los objetivos del experimento planteado el que desarrolle dichas preguntas. Sin embargo, dos tipos de preguntas siempre serán útiles para hacer descubrimientos dentro de los datos. Estas preguntas son: ¿Qué tipo de variabilidad ocurre dentro de las variables recogidas? ¿Qué tipo de covariación (o variabilidad conjunta entre dos o más variables) ocurre entre las variables recogidas? 2.2 Variabilidad La variabilidad es la tendencia de los valores de una variable a cambiar de medición a medición. Dicha variabilidad se parecía claramente en la vida real; si se mide cualquier variable continua dos veces, se obtendrán dos resultados diferentes. Esto es cierto incluso si se miden cantidades que son constantes, como la velocidad de la luz. Cada una de sus medidas incluirá una pequeña cantidad de error que varía de una medida a otra. Las variables categóricas también pueden variar si se miden diferentes sujetos (por ejemplo, los colores de los ojos de diferentes personas) o en diferentes momentos (por ejemplo, los niveles de energía de un electrón en diferentes momentos). Cada variable tiene su propio patrón de variación, que puede revelar información interesante. La mejor manera de entender ese patrón es visualizar la distribución de los valores de la variable mediante descriptores numéricos o gráficos. Si la variación describe el comportamiento dentro de una variable, la covariación describe el comportamiento entre las variables. La covariación es la tendencia de los valores de dos o más variables a variar juntas de una manera relacionada. La mejor forma de detectar la covariación es visualizar la relación entre dos o más variables. Cómo hacer eso nuevamente debería depender del tipo de variables involucradas. 2.3 Procesado inicial La descripción numérica y la visualización gráfica son las herramientas más importantes en los pasos iniciales para la generación de conocimiento sobre los datos experimentales, pero en ocasiones los datos no son recogidos en la forma más efectiva para realizar dichos análisis. A menudo se necesitara crear algunas variables o resúmenes nuevos, o tal vez solo se quiera cambiar el nombre de las variables o reordenar las observaciones para facilitar el trabajo de los datos. En este tema aprenderemos cómo hacer todo eso. Para ejemplificar los procedimientos utilizaremos el conjunto de datos flights contenido en la librería nycflights13, que contiene toda la información sobre los vuelos que salieron desde la ciudad de Nueva York en 2013. Las variables que contiene este banco de datos (336776 observaciones = vuelos) son: year: Fecha de salida (año). month: Fecha de salida (mes). year,month,day: Fecha de salida (día). dep_time: Hora real de salida. arr_time: Hora real de llegada (en horario de la ciudad de llegada). sched_dep_time: Hora programada de salida. (Esta variable debe coincidir con la información de las variables hour y minute) sched_arr_time: Hora programada de llegada (en horario de la ciudad de llegada). dep_delay: Demora de salida (en minutos). Los tiempos negativos representan salidas tempranas. arr_delay: Demora de llegada (en minutos). Los tiempos negativos representan llegadas tempranas. hour: Hora de partida programada. minute: Minuto de partida programada. carrier: Aerolínea encargada del vuelo tailnum: Identificador del avión flight: Identificador del vuelo origin: Origen del vuelo dest: Destino del vuelo air_time: Tiempo de vuelo (en minutos) distance: Distancia entre los dos aeropuertos (en millas) time_hour: Fecha y hora programadas del vuelo como una fecha POSIXct. Junto con el origen, se puede usar para unir datos de vuelos a datos meteorológicos. Recuerda que debes instalar dicha librería antes de poder reproducir todo los procedimientos que mostramos en las secciones siguientes. Instalamos la librería (junto con todas las necesarias para la asignatura) y cargamos los datos para poder visualizarlos: library(nycflights13) Código para cargar y visualizar los datos # Carga de datos data(flights) # Visualización de los 10 primeros casos kable( head(flights,10), align = &#39;c&#39;, booktabs = TRUE, caption = &#39;Datos flights de la librería nycflights13.&#39;) Tambien podemos ver la estructura (tipo de variables) del banco de datos. Los tipos de variables que se admiten en R son: int para enteros, dbl para números reales, chr para vectores de caracteres o cadenas, dttm para fechas-tiempos (una fecha + una hora), lgl para vectores lógicos que solo contienen VERDADERO o FALSO, fctr para factores (que R usa para representar variables categóricas con valores posibles fijos), y date para fechas. # Visualización de la estructura del banco de datos str(flights) ## tibble [336,776 × 19] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_time : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hour : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... 2.3.1 Operaciones con sujetos Los procedimientos para el trabajo con los sujetos de nuestra muestra se reducen al filtrado u ordenación, para quedarnos con un subconjunto de sujetos o para organizar su visualización en otra forma. 2.3.1.1 Filtrado Usamos el filtrado para seleccionar un subconjunto de observaciones del data.frame que contiene nuestros datos. Esto se hace a menudo cuando queremos limitar un análisis a un subconjunto de observaciones. El uso básico del filtro se hace mediante la función filter(): filter(data_set, &lt;expression1&gt;, &lt;expression2&gt;, ...) donde data_set es el nombre del objeto que contiene nuestros datos y &lt;expression1&gt;, &lt;expression2&gt;,...son uno o más argumentos adicionales, donde cada uno de estos es una expresión de R válida que implica una o más condiciones a aplicar sobre las variables del conjunto de datos. Cada expresión se interpreta como una condición lógica (verdadero o falso). Para usar el filtrado de manera efectiva, se debe saber cómo seleccionar las observaciones que se desea utilizando los operadores de comparación. R proporciona el paquete estándar: &gt; (mayor que), &gt;= (mayor o igual que), &lt; (menor que), &lt;= (menor o igual que), != (no igual a), y == (igual a). Veamos diferentes posibilidades de filtrado sobre el banco de datos flights. En primer lugar filtramos todos los vuelos cuya día de origen sea el 1 de enero de 2013. El resultado es un conjunto de datos con 842 observaciones donde aparece la información de dichos vuelos. Almacenamos el resultado eb nuevo objeto y calculamos el tamaño (nñumero de sujetos) con la función dim. jan1 &lt;- filter(flights, month == 1, day == 1) dim(jan1) ## [1] 842 19 Podemos combinar diferentes condiciones de filtrado mediante los operadores lógicos &amp; es “y” (condición 1 y condición 2), | es “o” (condición 1 o condición 2). Seleccionamos ahora todos los vuelos con mes de origen igual a Noviembre o Diciembre. nov_dec &lt;- filter(flights, month == 11 | month == 12) dim(nov_dec) # Para saber cuantas observaciones contiene el banco de datos filtrado ## [1] 55403 19 Los datos filtrados contienen la información completa de 55403 vuelos. Otra forma de conseguir el mismo resultado es con el operador %in% nov_dec &lt;- filter(flights, month %in% c(11, 12)) dim(nov_dec) ## [1] 55403 19 A veces se pueden simplificar condiciones de filtrado más complicadas sin más que recordar la ley de De Morgan: !(x &amp; y) es lo mismo que!x | !y, y!(x | y)es lo mismo que!x &amp; !y`. Por ejemplo, si se desean obtener todos vuelos que no se retrasaron (en llegada o partida) en más de dos horas, se pueden usar cualquiera de los dos filtros siguientes: db_sel1 &lt;- filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) dim(db_sel1) ## [1] 316050 19 db_sel2 &lt;- filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) dim(db_sel2) ## [1] 316050 19 2.3.1.2 Ordenación Otro procesamiento muy habitual con los sujetos es reordenar las filas de un objeto que contiene nuestros datos. Esto se usa cuando queremos inspeccionar un conjunto de datos para buscar asociaciones entre las diferentes variables, lo que resulta difícil de hacer si no están ordenados. Para realizar la ordenación se utiliza la función arrange(). El uso básico de la función es: arrange(data_set, varname1, varname2, ...) donde data_set es el nombre del objeto que contiene nuestros datos y varname1, varname2,... son las variables que vamos a utilizar para la ordenación. Por ejemplo deseamos ordenar nuestro datos siguiendo el orden año, mes y día: dbf_ord1 &lt;- arrange(flights, year, month, day) str(dbf_ord1) ## tibble [336,776 × 19] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_time : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hour : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... Podemos introducir la función desc() para ordenar de forma descendente por la variable seleccionada. Ordenamos nuestros datos (de mayor a menor) por la demora en el tiempo de llegada: dbf_ord2 &lt;- arrange(flights, desc(arr_delay)) str(dbf_ord2) ## tibble [336,776 × 19] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 6 1 9 7 4 3 7 12 5 ... ## $ day : int [1:336776] 9 15 10 20 22 10 17 22 5 3 ... ## $ dep_time : int [1:336776] 641 1432 1121 1139 845 1100 2321 2257 756 1133 ... ## $ sched_dep_time: int [1:336776] 900 1935 1635 1845 1600 1900 810 759 1700 2055 ... ## $ dep_delay : num [1:336776] 1301 1137 1126 1014 1005 ... ## $ arr_time : int [1:336776] 1242 1607 1239 1457 1044 1342 135 121 1058 1250 ... ## $ sched_arr_time: int [1:336776] 1530 2120 1810 2210 1815 2211 1020 1026 2020 2215 ... ## $ arr_delay : num [1:336776] 1272 1127 1109 1007 989 ... ## $ carrier : chr [1:336776] &quot;HA&quot; &quot;MQ&quot; &quot;MQ&quot; &quot;AA&quot; ... ## $ flight : int [1:336776] 51 3535 3695 177 3075 2391 2119 2047 172 3744 ... ## $ tailnum : chr [1:336776] &quot;N384HA&quot; &quot;N504MQ&quot; &quot;N517MQ&quot; &quot;N338AA&quot; ... ## $ origin : chr [1:336776] &quot;JFK&quot; &quot;JFK&quot; &quot;EWR&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;HNL&quot; &quot;CMH&quot; &quot;ORD&quot; &quot;SFO&quot; ... ## $ air_time : num [1:336776] 640 74 111 354 96 139 167 109 149 112 ... ## $ distance : num [1:336776] 4983 483 719 2586 589 ... ## $ hour : num [1:336776] 9 19 16 18 16 19 8 7 17 20 ... ## $ minute : num [1:336776] 0 35 35 45 0 0 10 59 0 55 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-09 09:00:00&quot; &quot;2013-06-15 19:00:00&quot; ... En el resumen de los datos presentados se pueden apreciar las diferencia entre los datos ordenados de una u otra forma. 2.3.2 Trabajando con variables Los procedimientos para el trabajo con las variables de nuestra muestra se reducen a la selección de un subconjunto de variables, la creación de nuevas variables, el renombrado de variables, y la recodificación en nuevas variables. 2.3.2.1 Selección Usamos la función select() para seleccionar un subconjunto de variables de nuestro banco de datos. Esto función se usa cuando tenemos un conjunto de datos con muchas variables, pero solo necesitamos trabajar con un subconjunto de ellas. La función tiene la estructura: select(data_set, varname1, varname2, ...) El primer argumento, data_set, es el nombre del objeto que contiene nuestros datos. A continuación incluimos una serie de uno o más argumentos adicionales, donde cada uno es el nombre de una o más variables en el conjunto de datos. Estas son las variables que aparecerán en el nuevo banco de datos. Para el conjunto de datos flights vamos a seleccionar las variables year, month, y day. dbf_sel1 &lt;- dplyr::select(flights, year, month, day) # indicamos la libreria por la coincidencia de la función select() # en otra libreria cargada str(dbf_sel1) ## tibble [336,776 × 3] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month: int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... A veces es más conveniente establecer la selección especificando aquellas que no necesitamos, en lugar de especificar cuáles guardar. Usamos el operador - para indicar que variables deben ser eliminadas. dbf_sel2 &lt;- dplyr::select(flights, -(year:day)) # No seleccionamos las varaibles que se encuentran entre las variables year y day str(dbf_sel2) ## tibble [336,776 × 16] (S3: tbl_df/tbl/data.frame) ## $ dep_time : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hour : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... Cuando las variables que deseamos eliminar no se muestran de forma consecutiva en nuestro banco de datos podemos utilizar una expresión equivalente dbf_sel3 &lt;- dplyr::select(flights, -c(year,month,day)) str(dbf_sel3) ## tibble [336,776 × 16] (S3: tbl_df/tbl/data.frame) ## $ dep_time : int [1:336776] 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int [1:336776] 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int [1:336776] 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int [1:336776] 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr [1:336776] &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int [1:336776] 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr [1:336776] &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr [1:336776] &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr [1:336776] &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ hour : num [1:336776] 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num [1:336776] 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct[1:336776], format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... 2.3.2.2 Creación En la creación de variables a partir de las originales en nuestros datos tenemos dos opciones: i) crear una nueva variable sin eliminar las variables originales, ii) crear una nueva variable eliminando las variables originales. Usamos la función mutate() para crear nuevas variables en nuestro banco de datos sin eliminar las variables que forman parte de la nueva variable. La función tiene la estructura: mutate(data_set, &lt;expression1&gt;, &lt;expression2&gt;, ...) El primer argumento, data_set, es el nombre del objeto que contiene nuestros datos. A continuación incluimos una serie de uno o más argumentos adicionales, donde cada uno es la expresión para la nueva o nuevas variables. Veamos un ejemplo de uso de la función dbf_sel4 &lt;- dplyr::select(flights, c(year,month,day,dep_delay,arr_delay,distance,air_time)) # Seleccionamos un subconjunto de las variables originales str(dbf_sel4) ## tibble [336,776 × 7] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_delay: num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_delay: num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... # Creamos una varaible que indica la reducción de demora entre salida y llegada # Calculamos la velocidad del viaje dbf_new &lt;- mutate(dbf_sel4, gain = arr_delay - dep_delay, speed = distance / air_time * 60 ) str(dbf_new) ## tibble [336,776 × 9] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_delay: num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_delay: num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ gain : num [1:336776] 9 16 31 -17 -19 16 24 -11 -5 10 ... ## $ speed : num [1:336776] 370 374 408 517 394 ... Podemos ver que se han añadido las dos variables en el nuevo banco de datos que se ha creado. Una ventaja de esta función es que resulta posible crear nuevas variables a partir de las nuevas creadas dbf_new2 &lt;- mutate(dbf_sel4, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) str(dbf_new2) ## tibble [336,776 × 10] (S3: tbl_df/tbl/data.frame) ## $ year : int [1:336776] 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int [1:336776] 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_delay : num [1:336776] 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_delay : num [1:336776] 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ distance : num [1:336776] 1400 1416 1089 1576 762 ... ## $ air_time : num [1:336776] 227 227 160 183 116 150 158 53 140 138 ... ## $ gain : num [1:336776] 9 16 31 -17 -19 16 24 -11 -5 10 ... ## $ hours : num [1:336776] 3.78 3.78 2.67 3.05 1.93 ... ## $ gain_per_hour: num [1:336776] 2.38 4.23 11.62 -5.57 -9.83 ... Usamos la función transmute() para crear un banco de datos donde solo aparecen las nuevas variables creadas. La estructura de la función es idéntica a la de la función mutate(). dbf_new3 &lt;- transmute(dbf_sel4, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) str(dbf_new3) ## tibble [336,776 × 3] (S3: tbl_df/tbl/data.frame) ## $ gain : num [1:336776] 9 16 31 -17 -19 16 24 -11 -5 10 ... ## $ hours : num [1:336776] 3.78 3.78 2.67 3.05 1.93 ... ## $ gain_per_hour: num [1:336776] 2.38 4.23 11.62 -5.57 -9.83 ... El listado de funciones que podemos usar con las funciones mutate() y transmute() son: Operadores aritméticos: +, -, *, /, ^ Funciones logaritmo: log(), log2(), log10() Funciones de agregación: cumsum() (suma acumulada), cumprod() (producto acumulado), cummin() (mínimo acumulado), cummax() (máximo acumulado), cummean() (media acumulada). Comparaciones lógicas: &lt;, &lt;=, &gt;, &gt;=, != 2.3.2.3 Creación de factores La creación de variables tipo factor es un aspecto muy importante en el análisis de datos. Existen tres formas principales de conseguir variables de tipo factor: A partir de variables tipo carácter A partir de variables de tipo entero que pueden identificar niveles de una variable A partir de una variable de tipo numérico. Por el momento solo mostraremos las opciones 1 y 2. La función utilizada para estas operaciones es fct_recode() cuya estructura viene dada por: fct_recode(varfactor, levelnew1=levelold1, levelnew2=levelold2, ...) donde varfactor es la variable factor original, levelnew son los niveles del factor recodificados y levelold son los niveles del factor en la variable original. Vamos a ver un ejemplo de su uso sobre el banco de datos NCBIRTH800 que presentamos en la unidad anterior. Cargamos los datos desde el repositorio y vemos su estructura: NCBIRTH800=read_csv(&quot;https://goo.gl/mB9Jcn&quot;, col_types = &quot;dcddcccdccddcc&quot;) En esta base de datos hay varias variables que se han recogido como carácter (aunque se les ha asignado un código numérico). A continuación se presentan dichas variables así como la asignación de valor a cada uno de los códigos numéricos: sex: &quot;male&quot; = 1,&quot;female&quot; = 2 marital: &quot;married&quot; = 1,&quot;not married&quot; = 2 racemom: &quot;other non white&quot; = 0, &quot;White&quot; = 1,&quot;Black&quot; = 2, &quot;America indian&quot; = 3,&quot;Chinese&quot; = 4,&quot;Hawaiian&quot; = 5, &quot;Filipino&quot; = 6,&quot;Other asian&quot; = 7, &quot;Other&quot; = 8 hispmom: &quot;Cuban&quot; = C, &quot;Mexican&quot; = M, &quot;Non-Hispanic&quot; = N , &quot;Other&quot; = O,&quot;Puerto Rican&quot; = P, &quot;Central/South american&quot; = S, &quot;U&quot; = Not classificable smoke: &quot;Yes&quot;=1, &quot;No&quot; = 0 drink: &quot;Yes&quot; = 1 ,&quot;No&quot; = 0 low: &quot;Yes&quot; = 1, &quot;No&quot; = 0 premie: &quot;Yes&quot;= 1, &quot;No&quot; = 0 Realizamos la asignación de los valores NCBIRTHnew &lt;- mutate(NCBIRTH800, sex = fct_recode(sex,&quot;male&quot; = &quot;1&quot;,&quot;female&quot; = &quot;2&quot;), marital = fct_recode(marital,&quot;married&quot; = &quot;1&quot;,&quot;not married&quot; = &quot;2&quot;), racemom = fct_recode(racemom,&quot;other non white&quot; = &quot;0&quot;,&quot;White&quot; = &quot;1&quot;, &quot;Black&quot; = &quot;2&quot;,&quot;America indian&quot; = &quot;3&quot;, &quot;Chinese&quot; = &quot;4&quot;,&quot;Hawaiian&quot; = &quot;5&quot;,&quot;Filipino&quot; = &quot;6&quot;, &quot;Other asian&quot; = &quot;7&quot;,&quot;Other&quot; = &quot;8&quot;), hispmom = fct_recode(hispmom,&quot;Cuban&quot; = &quot;C&quot;,&quot;Mexican&quot; = &quot;M&quot;, &quot;Non-Hispanic&quot; = &quot;N&quot;,&quot;Other&quot; = &quot;O&quot;, &quot;Puerto Rican&quot; = &quot;P&quot;,&quot;Central/South american&quot; = &quot;S&quot;, &quot;U&quot; = &quot;Not classificable&quot;), smoke = fct_recode(smoke,&quot;Yes&quot; = &quot;1&quot;,&quot;No&quot; = &quot;0&quot;), drink = fct_recode(drink,&quot;Yes&quot; = &quot;1&quot;,&quot;No&quot; = &quot;0&quot;), low = fct_recode(low,&quot;Yes&quot; = &quot;1&quot;,&quot;No&quot; = &quot;0&quot;), premie = fct_recode(premie,&quot;Yes&quot; = &quot;1&quot;,&quot;No&quot; = &quot;0&quot;)) str(NCBIRTHnew) ## spec_tbl_df [800 × 14] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ plural : num [1:800] 1 1 1 1 1 1 1 1 1 1 ... ## $ sex : Factor w/ 2 levels &quot;male&quot;,&quot;female&quot;: 1 2 1 1 1 1 2 2 2 2 ... ## $ mage : num [1:800] 32 32 27 27 25 28 25 15 37 21 ... ## $ weeks : num [1:800] 40 37 39 39 39 43 39 42 41 39 ... ## $ marital: Factor w/ 2 levels &quot;married&quot;,&quot;not married&quot;: 1 1 1 1 1 1 1 2 1 1 ... ## $ racemom: Factor w/ 6 levels &quot;White&quot;,&quot;Black&quot;,..: 1 1 1 1 1 1 1 1 6 1 ... ## $ hispmom: Factor w/ 6 levels &quot;Cuban&quot;,&quot;Mexican&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ gained : num [1:800] 38 34 12 15 32 32 75 25 31 28 ... ## $ smoke : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ drink : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ tounces: num [1:800] 111 116 138 136 121 117 143 113 139 120 ... ## $ tgrams : num [1:800] 3147 3289 3912 3856 3430 ... ## $ low : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ premie : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. plural = col_double(), ## .. sex = col_character(), ## .. mage = col_double(), ## .. weeks = col_double(), ## .. marital = col_character(), ## .. racemom = col_character(), ## .. hispmom = col_character(), ## .. gained = col_double(), ## .. smoke = col_character(), ## .. drink = col_character(), ## .. tounces = col_double(), ## .. tgrams = col_double(), ## .. low = col_character(), ## .. premie = col_character() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; En el resultado se aprecia la modificación de los diferentes factores. 2.3.3 Reuniendo los datos Un problema bastante común que parece en la recogida de datos experimentales es que los nombres de las columnas de la base de datos no es una variable en si, sino los valores de una variable. Si tomamos como ejemplo el banco de datos PCKDATA. PCKDATA = read_csv(&quot;https://goo.gl/W8Bfgv&quot;, col_types = &quot;idd&quot;) PCKDATA Tabla 2.1: SUBJAB 1193250 290173 3120135 415449 514983 6146123 7180126 8128177 9180164 1066121 11129200 1217075 13121182 14135169 15133234 1616567 1712553 18129119 19118241 20109138 2189113 22115112 23119104 24200115 25158224 26130138 27197223 28165172 298068 30161164 31189232 32175106 33120266 34117190 3544153 3610259 37174119 389993 39126162 4047130 4113289 42177197 43144189 44177207 45161109 4684147 47180193 48198110 4915887 50116135 51176115 52111159 53109115 54181114 55108202 5657134 5715564 5823979 5910396 60158181 6124091 62136167 63182200 64176236 65113126 66158185 67118141 68184180 6911660 70124137 71173195 72241172 73141116 74150229 75172142 76179131 77146155 7889152 79149246 80140169 8110099 82124163 8390124 8499189 8520879 8622576 87203154 88130182 8999100 90209140 91185115 92190190 93148193 9488146 95141143 9662163 97256157 98198161 99150192 100145105 101201162 102164201 103207203 104178179 105145132 106139158 10760147 108125147 109140161 11014858 1115991 112128151 113135183 114173153 11582130 116175126 117140176 11814056 119187160 120165183 121126157 122142132 123167183 124120201 125154122 126125159 127131115 128119150 12912993 130111104 131150228 132153184 13355108 134118159 135131134 136171134 13713786 138175102 13960164 140202133 141175164 142140175 14313393 144104137 145129130 146118158 147265160 148171211 14911071 150114215 151153116 152110119 153190154 154187139 155131169 15611514 15713074 158182130 159152105 160192145 16164179 162148143 163182220 164135213 165202124 16684167 167121121 16890162 169187133 17013772 17113888 172187193 17313796 174204157 175148102 176185157 177120145 178125113 179196185 18020779 181145154 18283184 18317490 184118146 185136175 186123176 18786172 188102109 189102136 190150102 191222148 19217496 193179210 19418821 19575116 19696152 197152187 198150149 199130168 200161134 20177213 20210355 203127152 20414674 20513024 206200106 20790192 20883111 209122112 210122178 211233176 212154150 213125194 214164193 215187143 216192157 21799154 2189769 21914069 220137181 221178223 222207121 223123187 224151155 225206159 226102150 22716655 228171147 229154148 230197112 231111103 232148110 23378140 234192124 235239101 236131120 23767183 23842178 23912180 240180126 24170164 24281193 243167182 244119146 245109119 246175184 247152162 24894120 24964186 250127193 25177210 252190184 253169160 25415853 255111122 256123185 25739147 258152177 259211159 26014970 26113789 26279309 263127132 264116166 265150190 266130169 26759122 268205136 26914978 270149243 271177162 271147174 273153179 274185119 275140171 27611990 2778878 278137131 279173175 28059113 281199122 282160129 28380182 284122107 285131147 28673115 287229136 288242124 28997138 29012785 29113270 29284151 293120155 294161203 29513791 296194143 297178161 298205178 29911477 300120195 30193181 30212591 30311499 304190128 305136129 306114138 307109190 308164178 30970173 3105667 311156116 31272159 31374140 31474162 31512690 31653154 317158178 318182157 319101192 320127153 321114171 322201120 323137178 32479240 325181122 3268652 327109126 328120187 329101112 330184192 331169144 33212582 33316991 334123113 335170151 33683155 337121150 338121216 33919983 34094138 341195199 34292126 34321271 34416480 345216152 346178181 347219115 348142179 349143175 350104134 351124139 352122165 35315813 354129183 35583137 356144101 357183202 358132139 359134163 36097114 361179106 362141150 36398188 36419162 365181130 366165275 367119184 368161138 369103154 37015937 37113019 372115216 373120128 37418917 375125224 376125169 377190128 378127140 379105157 38098118 381154152 382113140 38368143 384191138 38519099 386191115 387153157 388141178 389143142 39071218 391135117 392153212 393145193 394117101 395163100 396185163 397213221 39896100 3993995 400226132 40188149 402151167 403140101 404124116 405165124 40650149 407159222 408131101 409154218 410140132 411126202 4127976 413120151 41416356 41511070 416147257 417153172 418191121 419217155 420102154 421242117 422179219 42311566 42476125 425156230 426205224 427114151 42896108 42999155 430170156 431141196 432162131 43317990 434205140 435114149 43616544 437121193 438130139 439250188 44090190 44195211 442163171 443157164 44492135 445173123 44698174 447155123 44819292 449152142 450158259 451189142 452120147 453131157 45415987 45598164 456124217 45783156 458148201 459131140 460186134 461151146 46288168 463149130 46489189 465104168 466148143 46710383 468106139 4696986 47049121 471173160 472163114 473207202 474134156 475125204 47673170 477160160 478205183 47921357 480254152 48167133 482172237 48313882 484158170 485221149 48676102 487207164 488110165 489196157 490102193 491202141 492139134 49387176 494237113 495169140 49622245 497181157 49865102 49920768 50056108 50122140 502173126 503183129 504224155 50597229 506206198 50781178 508124142 509136201 510143135 51113699 51217043 513118143 51472121 515146110 516130197 517178200 5189187 519133171 520165161 521176140 52211042 523235192 52454109 52516097 526161119 52717375 528107164 52913290 530147196 531124193 532129125 533273110 53490178 535209146 536229217 537105141 538173181 539154225 54014965 54192144 542129114 543141191 544198192 545114150 546124159 547222139 548107169 549147156 55022021 55182156 55217891 553196121 554248122 555186111 556101124 557116146 558157109 559167173 56011395 561135206 562162158 563140134 564111152 565240167 56661141 56756158 568165192 569160131 570191124 571146192 57264146 573148110 574125170 575193201 57625191 577154131 57868214 579217153 580264186 581115148 582153125 583152155 584177132 585117171 5868769 58719993 588143152 589219205 590136128 59198165 592161210 593201155 59416571 595120177 59623118 597180182 598123157 599220196 600148119 601113156 602162209 603115154 60473128 60511692 606173127 6074893 608161191 609183212 61012897 61195141 612212191 613119128 61414075 61599166 616194132 61717868 618142139 61912373 62013173 621205149 622136136 62317352 624188134 62517272 62613067 62710896 628140100 629193184 63081224 63121258 632169193 633175150 634195135 635130151 636140138 637130207 63863158 63967223 640202124 641127129 642200173 64391179 644129142 64511693 646163101 647127166 648148177 64912388 650232153 65117274 652155111 65350176 654134125 655102122 656183170 6579496 658103200 659117170 660122204 66148146 662145136 663130123 664114101 665159106 666127129 667168169 668178109 66913587 67015170 671181160 672109136 673184125 67490247 675107131 67618682 677207104 678142167 6796299 680154176 681196114 682141201 683170148 684207154 685109155 686201128 687170192 688200199 6897699 690148159 69111191 6927898 69332158 694217106 695166219 69679177 697184143 698199192 699178109 70020261 701141229 702121158 703169134 704158130 705211106 706241117 707120210 708243252 70999119 710192122 71111545 71283130 71316399 714197187 71513484 716260160 717186103 71813953 71964118 720257164 72199128 722155141 723150192 724179183 725153222 726181129 727142178 728115114 729166157 73091145 731216148 732121126 733204194 734193176 735113174 73691198 737175121 738198109 739185145 740166184 74193201 742152122 743170190 744124118 745112124 746153161 747179151 74894150 74921796 750139136 751176173 75274229 753146192 754114235 755213164 756143173 757171145 758124132 75983178 76091107 761107136 76298177 76313074 764150113 76518972 76617896 767177151 768164151 769157117 770116112 77116589 772167177 773126109 774191106 775253188 77616790 777181162 778128161 779192120 780164160 781195160 782200128 783132140 784135141 78516089 786160191 78750144 78815354 78985147 790133218 791172172 792139132 793103125 794145125 795143144 796170145 79720879 798119140 799100180 800138203 801159148 802168164 803250127 804209156 805114116 806221170 807217145 808145228 809240137 810123136 811144162 812142132 813172119 81410397 815143168 81618672 81779116 818135151 819124200 82088155 821215139 82276151 82316694 824221202 82592108 826137334 827201134 828169171 82912691 830218102 83114483 832269154 833126221 83496188 83511930 836121102 837188207 838185112 839165216 84018098 84165166 84266180 843109122 844131186 845142110 846138190 847178191 848165234 849121184 85093223 851134158 852139162 853138121 85474143 85534150 85677134 8579648 858200173 859138124 860175133 861134103 862164137 86310685 864153179 865203176 866160100 86768204 868207173 869139141 870122123 871128200 872244111 87370143 87482117 87516370 876265169 877203206 878213159 87975177 880152135 881110103 882155105 883181115 88414252 88565161 886150111 887236156 88819656 889146105 89016090 891148137 892205164 893162156 894204154 895128195 896201181 89776163 898206181 899157101 900123164 901116129 902113191 90379169 904156169 905113196 906132140 90714190 908159179 90956171 91014192 911260162 912113134 913110117 914120130 915143145 91624896 917162115 918159128 919155208 92020596 921143173 92221699 923164120 924168183 92578193 926188150 927193174 92888119 929169154 930148137 931111112 932164113 93311964 934146130 935112188 936141199 93770186 93893120 939137112 940105112 941129134 94222354 943135173 944172199 94535129 946194181 94718591 948148147 949107131 950161131 951127168 952190135 953133132 954149114 955118212 956203119 957166109 958161137 95919369 960109173 961215116 96272141 963168130 964130173 96599183 966116177 967196161 96861164 9695995 970103115 971146189 972118220 973128145 97487158 97585177 976180200 977120203 978149108 979233101 980188111 981135185 98298199 983160154 984151106 985121125 986149137 987173150 988100107 98999122 990156146 99177197 992210172 993160179 994135105 99525473 996186156 997100129 998191110 99976165 1000127208 100195150 100213192 1003135135 1004184126 1005157155 Como se puede ver aparecen dos columnas indicando el tratamiento del sujeto, es decir, cada fila no identifica a un único sujeto. Por ese motivo en cada una de ellas aparece el valor del nivel de creatinina. Para poder trabajar de forma óptima cada fila debe contener la información única de cada sujeto. En este caso cada fila contiene la información de dos sujetos: el identificado como 1 en el tratamiento A y el identificado como 1 en el tratamiento B. La función gather()nos permite reorganizar los datos de un banco de datos de forma muy sencilla. La estructura básica de la función es: gather(data_set,var, key = &quot;key&quot;, value = &quot;value&quot;, ...) donde data_set es el banco de datos, var es el conjunto de variables que reorganizamos, key es el nombre de la variable donde reorganizamos las variables anteriores, y value es el nombre de la variable donde almacenamos los valores de respuesta. Para el conjunto de datos anterior tenemos: gather(PCKDATA,`A`,`B`, key = &quot;Grupo&quot;, value = creatine) Tabla 2.2: SUBJGrupocreatine 1A193 2A90 3A120 4A154 5A149 6A146 7A180 8A128 9A180 10A66 11A129 12A170 13A121 14A135 15A133 16A165 17A125 18A129 19A118 20A109 21A89 22A115 23A119 24A200 25A158 26A130 27A197 28A165 29A80 30A161 31A189 32A175 33A120 34A117 35A44 36A102 37A174 38A99 39A126 40A47 41A132 42A177 43A144 44A177 45A161 46A84 47A180 48A198 49A158 50A116 51A176 52A111 53A109 54A181 55A108 56A57 57A155 58A239 59A103 60A158 61A240 62A136 63A182 64A176 65A113 66A158 67A118 68A184 69A116 70A124 71A173 72A241 73A141 74A150 75A172 76A179 77A146 78A89 79A149 80A140 81A100 82A124 83A90 84A99 85A208 86A225 87A203 88A130 89A99 90A209 91A185 92A190 93A148 94A88 95A141 96A62 97A256 98A198 99A150 100A145 101A201 102A164 103A207 104A178 105A145 106A139 107A60 108A125 109A140 110A148 111A59 112A128 113A135 114A173 115A82 116A175 117A140 118A140 119A187 120A165 121A126 122A142 123A167 124A120 125A154 126A125 127A131 128A119 129A129 130A111 131A150 132A153 133A55 134A118 135A131 136A171 137A137 138A175 139A60 140A202 141A175 142A140 143A133 144A104 145A129 146A118 147A265 148A171 149A110 150A114 151A153 152A110 153A190 154A187 155A131 156A115 157A130 158A182 159A152 160A192 161A64 162A148 163A182 164A135 165A202 166A84 167A121 168A90 169A187 170A137 171A138 172A187 173A137 174A204 175A148 176A185 177A120 178A125 179A196 180A207 181A145 182A83 183A174 184A118 185A136 186A123 187A86 188A102 189A102 190A150 191A222 192A174 193A179 194A188 195A75 196A96 197A152 198A150 199A130 200A161 201A77 202A103 203A127 204A146 205A130 206A200 207A90 208A83 209A122 210A122 211A233 212A154 213A125 214A164 215A187 216A192 217A99 218A97 219A140 220A137 221A178 222A207 223A123 224A151 225A206 226A102 227A166 228A171 229A154 230A197 231A111 232A148 233A78 234A192 235A239 236A131 237A67 238A42 239A121 240A180 241A70 242A81 243A167 244A119 245A109 246A175 247A152 248A94 249A64 250A127 251A77 252A190 253A169 254A158 255A111 256A123 257A39 258A152 259A211 260A149 261A137 262A79 263A127 264A116 265A150 266A130 267A59 268A205 269A149 270A149 271A177 271A147 273A153 274A185 275A140 276A119 277A88 278A137 279A173 280A59 281A199 282A160 283A80 284A122 285A131 286A73 287A229 288A242 289A97 290A127 291A132 292A84 293A120 294A161 295A137 296A194 297A178 298A205 299A114 300A120 301A93 302A125 303A114 304A190 305A136 306A114 307A109 308A164 309A70 310A56 311A156 312A72 313A74 314A74 315A126 316A53 317A158 318A182 319A101 320A127 321A114 322A201 323A137 324A79 325A181 326A86 327A109 328A120 329A101 330A184 331A169 332A125 333A169 334A123 335A170 336A83 337A121 338A121 339A199 340A94 341A195 342A92 343A212 344A164 345A216 346A178 347A219 348A142 349A143 350A104 351A124 352A122 353A158 354A129 355A83 356A144 357A183 358A132 359A134 360A97 361A179 362A141 363A98 364A191 365A181 366A165 367A119 368A161 369A103 370A159 371A130 372A115 373A120 374A189 375A125 376A125 377A190 378A127 379A105 380A98 381A154 382A113 383A68 384A191 385A190 386A191 387A153 388A141 389A143 390A71 391A135 392A153 393A145 394A117 395A163 396A185 397A213 398A96 399A39 400A226 401A88 402A151 403A140 404A124 405A165 406A50 407A159 408A131 409A154 410A140 411A126 412A79 413A120 414A163 415A110 416A147 417A153 418A191 419A217 420A102 421A242 422A179 423A115 424A76 425A156 426A205 427A114 428A96 429A99 430A170 431A141 432A162 433A179 434A205 435A114 436A165 437A121 438A130 439A250 440A90 441A95 442A163 443A157 444A92 445A173 446A98 447A155 448A192 449A152 450A158 451A189 452A120 453A131 454A159 455A98 456A124 457A83 458A148 459A131 460A186 461A151 462A88 463A149 464A89 465A104 466A148 467A103 468A106 469A69 470A49 471A173 472A163 473A207 474A134 475A125 476A73 477A160 478A205 479A213 480A254 481A67 482A172 483A138 484A158 485A221 486A76 487A207 488A110 489A196 490A102 491A202 492A139 493A87 494A237 495A169 496A222 497A181 498A65 499A207 500A56 501A221 502A173 503A183 504A224 505A97 506A206 507A81 508A124 509A136 510A143 511A136 512A170 513A118 514A72 515A146 516A130 517A178 518A91 519A133 520A165 521A176 522A110 523A235 524A54 525A160 526A161 527A173 528A107 529A132 530A147 531A124 532A129 533A273 534A90 535A209 536A229 537A105 538A173 539A154 540A149 541A92 542A129 543A141 544A198 545A114 546A124 547A222 548A107 549A147 550A220 551A82 552A178 553A196 554A248 555A186 556A101 557A116 558A157 559A167 560A113 561A135 562A162 563A140 564A111 565A240 566A61 567A56 568A165 569A160 570A191 571A146 572A64 573A148 574A125 575A193 576A251 577A154 578A68 579A217 580A264 581A115 582A153 583A152 584A177 585A117 586A87 587A199 588A143 589A219 590A136 591A98 592A161 593A201 594A165 595A120 596A23 597A180 598A123 599A220 600A148 601A113 602A162 603A115 604A73 605A116 606A173 607A48 608A161 609A183 610A128 611A95 612A212 613A119 614A140 615A99 616A194 617A178 618A142 619A123 620A131 621A205 622A136 623A173 624A188 625A172 626A130 627A108 628A140 629A193 630A81 631A212 632A169 633A175 634A195 635A130 636A140 637A130 638A63 639A67 640A202 641A127 642A200 643A91 644A129 645A116 646A163 647A127 648A148 649A123 650A232 651A172 652A155 653A50 654A134 655A102 656A183 657A94 658A103 659A117 660A122 661A48 662A145 663A130 664A114 665A159 666A127 667A168 668A178 669A135 670A151 671A181 672A109 673A184 674A90 675A107 676A186 677A207 678A142 679A62 680A154 681A196 682A141 683A170 684A207 685A109 686A201 687A170 688A200 689A76 690A148 691A111 692A78 693A32 694A217 695A166 696A79 697A184 698A199 699A178 700A202 701A141 702A121 703A169 704A158 705A211 706A241 707A120 708A243 709A99 710A192 711A115 712A83 713A163 714A197 715A134 716A260 717A186 718A139 719A64 720A257 721A99 722A155 723A150 724A179 725A153 726A181 727A142 728A115 729A166 730A91 731A216 732A121 733A204 734A193 735A113 736A91 737A175 738A198 739A185 740A166 741A93 742A152 743A170 744A124 745A112 746A153 747A179 748A94 749A217 750A139 751A176 752A74 753A146 754A114 755A213 756A143 757A171 758A124 759A83 760A91 761A107 762A98 763A130 764A150 765A189 766A178 767A177 768A164 769A157 770A116 771A165 772A167 773A126 774A191 775A253 776A167 777A181 778A128 779A192 780A164 781A195 782A200 783A132 784A135 785A160 786A160 787A50 788A153 789A85 790A133 791A172 792A139 793A103 794A145 795A143 796A170 797A208 798A119 799A100 800A138 801A159 802A168 803A250 804A209 805A114 806A221 807A217 808A145 809A240 810A123 811A144 812A142 813A172 814A103 815A143 816A186 817A79 818A135 819A124 820A88 821A215 822A76 823A166 824A221 825A92 826A137 827A201 828A169 829A126 830A218 831A144 832A269 833A126 834A96 835A119 836A121 837A188 838A185 839A165 840A180 841A65 842A66 843A109 844A131 845A142 846A138 847A178 848A165 849A121 850A93 851A134 852A139 853A138 854A74 855A34 856A77 857A96 858A200 859A138 860A175 861A134 862A164 863A106 864A153 865A203 866A160 867A68 868A207 869A139 870A122 871A128 872A244 873A70 874A82 875A163 876A265 877A203 878A213 879A75 880A152 881A110 882A155 883A181 884A142 885A65 886A150 887A236 888A196 889A146 890A160 891A148 892A205 893A162 894A204 895A128 896A201 897A76 898A206 899A157 900A123 901A116 902A113 903A79 904A156 905A113 906A132 907A141 908A159 909A56 910A141 911A260 912A113 913A110 914A120 915A143 916A248 917A162 918A159 919A155 920A205 921A143 922A216 923A164 924A168 925A78 926A188 927A193 928A88 929A169 930A148 931A111 932A164 933A119 934A146 935A112 936A141 937A70 938A93 939A137 940A105 941A129 942A223 943A135 944A172 945A35 946A194 947A185 948A148 949A107 950A161 951A127 952A190 953A133 954A149 955A118 956A203 957A166 958A161 959A193 960A109 961A215 962A72 963A168 964A130 965A99 966A116 967A196 968A61 969A59 970A103 971A146 972A118 973A128 974A87 975A85 976A180 977A120 978A149 979A233 980A188 981A135 982A98 983A160 984A151 985A121 986A149 987A173 988A100 989A99 990A156 991A77 992A210 993A160 994A135 995A254 996A186 997A100 998A191 999A76 1000A127 1001A95 1002A131 1003A135 1004A184 1005A157 1B250 2B173 3B135 4B49 5B83 6B123 7B126 8B177 9B164 10B121 11B200 12B75 13B182 14B169 15B234 16B67 17B53 18B119 19B241 20B138 21B113 22B112 23B104 24B115 25B224 26B138 27B223 28B172 29B68 30B164 31B232 32B106 33B266 34B190 35B153 36B59 37B119 38B93 39B162 40B130 41B89 42B197 43B189 44B207 45B109 46B147 47B193 48B110 49B87 50B135 51B115 52B159 53B115 54B114 55B202 56B134 57B64 58B79 59B96 60B181 61B91 62B167 63B200 64B236 65B126 66B185 67B141 68B180 69B60 70B137 71B195 72B172 73B116 74B229 75B142 76B131 77B155 78B152 79B246 80B169 81B99 82B163 83B124 84B189 85B79 86B76 87B154 88B182 89B100 90B140 91B115 92B190 93B193 94B146 95B143 96B163 97B157 98B161 99B192 100B105 101B162 102B201 103B203 104B179 105B132 106B158 107B147 108B147 109B161 110B58 111B91 112B151 113B183 114B153 115B130 116B126 117B176 118B56 119B160 120B183 121B157 122B132 123B183 124B201 125B122 126B159 127B115 128B150 129B93 130B104 131B228 132B184 133B108 134B159 135B134 136B134 137B86 138B102 139B164 140B133 141B164 142B175 143B93 144B137 145B130 146B158 147B160 148B211 149B71 150B215 151B116 152B119 153B154 154B139 155B169 156B14 157B74 158B130 159B105 160B145 161B179 162B143 163B220 164B213 165B124 166B167 167B121 168B162 169B133 170B72 171B88 172B193 173B96 174B157 175B102 176B157 177B145 178B113 179B185 180B79 181B154 182B184 183B90 184B146 185B175 186B176 187B172 188B109 189B136 190B102 191B148 192B96 193B210 194B21 195B116 196B152 197B187 198B149 199B168 200B134 201B213 202B55 203B152 204B74 205B24 206B106 207B192 208B111 209B112 210B178 211B176 212B150 213B194 214B193 215B143 216B157 217B154 218B69 219B69 220B181 221B223 222B121 223B187 224B155 225B159 226B150 227B55 228B147 229B148 230B112 231B103 232B110 233B140 234B124 235B101 236B120 237B183 238B178 239B80 240B126 241B164 242B193 243B182 244B146 245B119 246B184 247B162 248B120 249B186 250B193 251B210 252B184 253B160 254B53 255B122 256B185 257B147 258B177 259B159 260B70 261B89 262B309 263B132 264B166 265B190 266B169 267B122 268B136 269B78 270B243 271B162 271B174 273B179 274B119 275B171 276B90 277B78 278B131 279B175 280B113 281B122 282B129 283B182 284B107 285B147 286B115 287B136 288B124 289B138 290B85 291B70 292B151 293B155 294B203 295B91 296B143 297B161 298B178 299B77 300B195 301B181 302B91 303B99 304B128 305B129 306B138 307B190 308B178 309B173 310B67 311B116 312B159 313B140 314B162 315B90 316B154 317B178 318B157 319B192 320B153 321B171 322B120 323B178 324B240 325B122 326B52 327B126 328B187 329B112 330B192 331B144 332B82 333B91 334B113 335B151 336B155 337B150 338B216 339B83 340B138 341B199 342B126 343B71 344B80 345B152 346B181 347B115 348B179 349B175 350B134 351B139 352B165 353B13 354B183 355B137 356B101 357B202 358B139 359B163 360B114 361B106 362B150 363B188 364B62 365B130 366B275 367B184 368B138 369B154 370B37 371B19 372B216 373B128 374B17 375B224 376B169 377B128 378B140 379B157 380B118 381B152 382B140 383B143 384B138 385B99 386B115 387B157 388B178 389B142 390B218 391B117 392B212 393B193 394B101 395B100 396B163 397B221 398B100 399B95 400B132 401B149 402B167 403B101 404B116 405B124 406B149 407B222 408B101 409B218 410B132 411B202 412B76 413B151 414B56 415B70 416B257 417B172 418B121 419B155 420B154 421B117 422B219 423B66 424B125 425B230 426B224 427B151 428B108 429B155 430B156 431B196 432B131 433B90 434B140 435B149 436B44 437B193 438B139 439B188 440B190 441B211 442B171 443B164 444B135 445B123 446B174 447B123 448B92 449B142 450B259 451B142 452B147 453B157 454B87 455B164 456B217 457B156 458B201 459B140 460B134 461B146 462B168 463B130 464B189 465B168 466B143 467B83 468B139 469B86 470B121 471B160 472B114 473B202 474B156 475B204 476B170 477B160 478B183 479B57 480B152 481B133 482B237 483B82 484B170 485B149 486B102 487B164 488B165 489B157 490B193 491B141 492B134 493B176 494B113 495B140 496B45 497B157 498B102 499B68 500B108 501B40 502B126 503B129 504B155 505B229 506B198 507B178 508B142 509B201 510B135 511B99 512B43 513B143 514B121 515B110 516B197 517B200 518B87 519B171 520B161 521B140 522B42 523B192 524B109 525B97 526B119 527B75 528B164 529B90 530B196 531B193 532B125 533B110 534B178 535B146 536B217 537B141 538B181 539B225 540B65 541B144 542B114 543B191 544B192 545B150 546B159 547B139 548B169 549B156 550B21 551B156 552B91 553B121 554B122 555B111 556B124 557B146 558B109 559B173 560B95 561B206 562B158 563B134 564B152 565B167 566B141 567B158 568B192 569B131 570B124 571B192 572B146 573B110 574B170 575B201 576B91 577B131 578B214 579B153 580B186 581B148 582B125 583B155 584B132 585B171 586B69 587B93 588B152 589B205 590B128 591B165 592B210 593B155 594B71 595B177 596B118 597B182 598B157 599B196 600B119 601B156 602B209 603B154 604B128 605B92 606B127 607B93 608B191 609B212 610B97 611B141 612B191 613B128 614B75 615B166 616B132 617B68 618B139 619B73 620B73 621B149 622B136 623B52 624B134 625B72 626B67 627B96 628B100 629B184 630B224 631B58 632B193 633B150 634B135 635B151 636B138 637B207 638B158 639B223 640B124 641B129 642B173 643B179 644B142 645B93 646B101 647B166 648B177 649B88 650B153 651B74 652B111 653B176 654B125 655B122 656B170 657B96 658B200 659B170 660B204 661B146 662B136 663B123 664B101 665B106 666B129 667B169 668B109 669B87 670B70 671B160 672B136 673B125 674B247 675B131 676B82 677B104 678B167 679B99 680B176 681B114 682B201 683B148 684B154 685B155 686B128 687B192 688B199 689B99 690B159 691B91 692B98 693B158 694B106 695B219 696B177 697B143 698B192 699B109 700B61 701B229 702B158 703B134 704B130 705B106 706B117 707B210 708B252 709B119 710B122 711B45 712B130 713B99 714B187 715B84 716B160 717B103 718B53 719B118 720B164 721B128 722B141 723B192 724B183 725B222 726B129 727B178 728B114 729B157 730B145 731B148 732B126 733B194 734B176 735B174 736B198 737B121 738B109 739B145 740B184 741B201 742B122 743B190 744B118 745B124 746B161 747B151 748B150 749B96 750B136 751B173 752B229 753B192 754B235 755B164 756B173 757B145 758B132 759B178 760B107 761B136 762B177 763B74 764B113 765B72 766B96 767B151 768B151 769B117 770B112 771B89 772B177 773B109 774B106 775B188 776B90 777B162 778B161 779B120 780B160 781B160 782B128 783B140 784B141 785B89 786B191 787B144 788B54 789B147 790B218 791B172 792B132 793B125 794B125 795B144 796B145 797B79 798B140 799B180 800B203 801B148 802B164 803B127 804B156 805B116 806B170 807B145 808B228 809B137 810B136 811B162 812B132 813B119 814B97 815B168 816B72 817B116 818B151 819B200 820B155 821B139 822B151 823B94 824B202 825B108 826B334 827B134 828B171 829B91 830B102 831B83 832B154 833B221 834B188 835B30 836B102 837B207 838B112 839B216 840B98 841B166 842B180 843B122 844B186 845B110 846B190 847B191 848B234 849B184 850B223 851B158 852B162 853B121 854B143 855B150 856B134 857B48 858B173 859B124 860B133 861B103 862B137 863B85 864B179 865B176 866B100 867B204 868B173 869B141 870B123 871B200 872B111 873B143 874B117 875B70 876B169 877B206 878B159 879B177 880B135 881B103 882B105 883B115 884B52 885B161 886B111 887B156 888B56 889B105 890B90 891B137 892B164 893B156 894B154 895B195 896B181 897B163 898B181 899B101 900B164 901B129 902B191 903B169 904B169 905B196 906B140 907B90 908B179 909B171 910B92 911B162 912B134 913B117 914B130 915B145 916B96 917B115 918B128 919B208 920B96 921B173 922B99 923B120 924B183 925B193 926B150 927B174 928B119 929B154 930B137 931B112 932B113 933B64 934B130 935B188 936B199 937B186 938B120 939B112 940B112 941B134 942B54 943B173 944B199 945B129 946B181 947B91 948B147 949B131 950B131 951B168 952B135 953B132 954B114 955B212 956B119 957B109 958B137 959B69 960B173 961B116 962B141 963B130 964B173 965B183 966B177 967B161 968B164 969B95 970B115 971B189 972B220 973B145 974B158 975B177 976B200 977B203 978B108 979B101 980B111 981B185 982B199 983B154 984B106 985B125 986B137 987B150 988B107 989B122 990B146 991B197 992B172 993B179 994B105 995B73 996B156 997B129 998B110 999B165 1000B208 1001B150 1002B92 1003B135 1004B126 1005B155 Podemos ver que se han reorganizado las filas de la base de datos. De hecho se han duplicado el número de filas (hemos ampliado dos variables) y ahora cada columna identifica claramente la información de un sujeto. 2.4 Análisis Descriptivo inicial Esta sección muestra los procedimientos de análisis estadístico descriptivo para el estudio de una o dos variables de tipo numérico y/o categórico. Las situaciones que se plantean son: Una variable de tipo factor. Una variable de tipo numérico. Dos variables categóricas. Dos variables numéricas. Una variable categórica y una variable numérica. Este es el primer paso del EDA y sirve al investigador para plantear o responder las primeras preguntas de interés sobre sus datos. Para ilustrar los procedimientos utilizaremos el conjunto de datos storms de la librería nasaweather. Estos datos son un subconjunto de la base de datos de la NASA sobre los huracanes en el Atlántico Norte (NOAA). Los datos incluyen las posiciones y atributos de 198 tormentas tropicales, medidas cada seis horas durante la vida de la tormenta. Las variables registradas son: name: Nombre de la tormenta year, month, day: Año, mes y día del informe de la tormenta hour: Hora del informe (en UTC) lat, long: Latitud y longitud de la tormenta pressure: Presión atmosférica en el centro de la tormenta (en milibares) wind: Máxima velocidad sostenida de la tormenta (en nudos) type: Clasificación de la tormenta (Tropical Depression, Tropical Storm, or Hurricane) seasday: día de la temporada de tormentas library(nasaweather) # Guardamos los datos en un nuevo objeto storm &lt;- nasaweather::storms # Estructura de los datos str(storm) Dado que las variables year y month no vienen definidas como factores, el primer paso es convertirlas en factores. En este caso vamos a utilizar una versión diferente de la vista en el tema anterior para convertir varaibles enteras a factores. # Primero creamos el factor año storm$year_f &lt;- factor(storm$year) # Asignamos los niveles levels(storm$year_f) &lt;- as.character(1995:2000) # Ahora el factor mes storm$month_f &lt;- factor(storm$month) # Asignamos los niveles levels(storm$month_f) &lt;- c(&quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;) # Veamos como queda el banco de datos str(storm) ## tibble [2,747 × 13] (S3: tbl_df/tbl/data.frame) ## $ name : chr [1:2747] &quot;Allison&quot; &quot;Allison&quot; &quot;Allison&quot; &quot;Allison&quot; ... ## $ year : int [1:2747] 1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ... ## $ month : int [1:2747] 6 6 6 6 6 6 6 6 6 6 ... ## $ day : int [1:2747] 3 3 3 3 4 4 4 4 5 5 ... ## $ hour : int [1:2747] 0 6 12 18 0 6 12 18 0 6 ... ## $ lat : num [1:2747] 17.4 18.3 19.3 20.6 22 23.3 24.7 26.2 27.6 28.5 ... ## $ long : num [1:2747] -84.3 -84.9 -85.7 -85.8 -86 -86.3 -86.2 -86.2 -86.1 -85.6 ... ## $ pressure: int [1:2747] 1005 1004 1003 1001 997 995 987 988 988 990 ... ## $ wind : int [1:2747] 30 30 35 40 50 60 65 65 65 60 ... ## $ type : chr [1:2747] &quot;Tropical Depression&quot; &quot;Tropical Depression&quot; &quot;Tropical Storm&quot; &quot;Tropical Storm&quot; ... ## $ seasday : int [1:2747] 3 3 3 3 4 4 4 4 5 5 ... ## $ year_f : Factor w/ 6 levels &quot;1995&quot;,&quot;1996&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ month_f : Factor w/ 7 levels &quot;June&quot;,&quot;July&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... A lo largo de cada una de las secciones siguientes se irán introduciendo las funciones y procedimientos necesarias para cada análisis en función de la variable o variables que se desean analizar. 2.4.1 Una variable factor En esta sección se considera cómo explorar la distribución de una variable categórica. Se presentan las descriptivas básicas y visualizaciones que son apropiadas para las variables categóricas. Para ejemplificar los procedimientos utilizaremos la variable type que identifica el tipo de tormenta. Explorar variables categóricas es generalmente más simple que trabajar con variables numéricas porque tenemos menos respuestas posibles. La primera pregunta que nos debemos plantear es is la variables categórica es de tipo nominal u ordinal. Esto tiene un efecto relevante a la hora de presentar y visualizar la información. La variable type es una variable categórica de tipo ordinal debido a que las tormentas son clasificadas según su virulencia. 2.4.1.1 Resúmenes numéricos Cuando calculamos resúmenes de variables categóricas, intentamos describir la distribución muestral de la variable mediante el recuento de ocurrencias de cada una de las posibles respuestas de la variable. Estos recuentos es lo que denominamos en estadística frecuencias absolutas. Necesitamos entender qué categorías son comunes y cuáles son raras. Asociado a dichas frecuencias absolutas podemos obtener las frecuencias relativas, o más frecuentemente los porcentajes de cada una de las posibles categorías de la variable. Si \\(F_i\\) es la frecuencia absoluta de la categoría \\(i\\) de la variable y \\(n\\) es el tamaño de la muestra, se define la frecuencia relativa de la categoría \\(i\\) (\\(f_i\\)) como: \\[\\begin{equation} f_i =\\frac{F_i}{n} \\tag{2.1} \\end{equation}\\] El porcentaje de la categoría \\(i\\) es simplemente \\(100 * f_i\\). La forma más sencilla para obtener la tabla de frecuencias absoluta asociada con una variable categórica es la función table(). table(storm$type) ## ## Extratropical Hurricane Tropical Depression Tropical Storm ## 412 896 513 926 Para obtener los porcentajes en lugar de los conteos podemos utilizar le código siguiente type_counts &lt;- table(storm$type) round(type_counts / sum(type_counts),2) # Redondeamos a dos decimales ## ## Extratropical Hurricane Tropical Depression Tropical Storm ## 0.15 0.33 0.19 0.34 Sin embargo, hay otra opción un poco más compleja pero que nos servirá de utilidad para el resto de esta unidad y que pasamos a mostrar a continuación. Es una combinación del operador de anidamiento %&gt;%, de la función de agrupación (group_by()), de la función de resumen (summarise()), y de la función de conteos (n()). # banco de datos tabla_tipo &lt;- storm %&gt;% # agrupamos por la variable factor group_by(type) %&gt;% # resumimos contando el número de casos de cada nivel del factor summarise(n=n()) # Para calcular los porcentajes mutate(tabla_tipo,percent=round(100*n/sum(n),2)) Tabla 2.3: typenpercent Extratropical41215&nbsp;&nbsp; Hurricane89632.6 Tropical Depression51318.7 Tropical Storm92633.7 Aunque esta forma es más costosa cuando tenemos únicamente una variable nos resultará de más utilidad cuando deseemos realizar análisis que involucren un mayor número de variables. Podemos ver que mayoritariamente se han producido Tormentas Tropicales (33.71%) y Huracanes (32.62%). Estos dos tipos suman más de dos tercios de los ecentos registrados. Por contra los eventos menos abundantes han sido las Depresiones Tropicales (18.67%) y las Extratropicales (15.00%). Las funciones más habituales que se utilizan con summarise() son: Localización: mean() (media), median() (mediana) Escala: sd() (desviación típica), IQR() (rango intercuartílico) Rango: min() (mínimo), max() (máximo), quantile() (cuantil) Posición: first() (primero), last() (último), nth() (posición n-ésima) Conteo: n() (número de casos), n_distinct() (número de casos distintos) La mayoría se usan exclusivamente para variables de tipo numérico. 2.4.1.2 Visualización gráfica En este apartado veremos como representar los datos de los conteos de una variable categórica mediante la función ’ggplot`. Esta función permite realizar casi cualquier tipo de gráfico que podamos imaginar. En este punto vamos a ir presentando diferentes parámetros de dicha función para ir familiarizándonos con su uso. 2.4.1.2.1 Gráfico barras La herramienta gráfica más común utilizada para resumir una variable categórica es un gráfico de barras. Un gráfico de barras (o gráfico de barras) es un gráfico que presenta resúmenes de datos agrupados con barras rectangulares. La longitud de las barras es proporcional a los valores que representan. Al resumir una sola variable categórica, la longitud de las barras debe mostrar los recuentos brutos o las proporciones de cada categoría. Para realizar este gráfico con la función ggplotnecesitamos identificar el conjunto de datos sobre el que vamos a trabajar y la variable que queremos representar: # Configuramos el gráfico identificando los datos y la variable de interés bar_plt &lt;- ggplot(storm, aes(x = type)) bar_plt &lt;- bar_plt + geom_bar() # Seleccionamos el tipo gráfico bar_plt # Representamos el gráfico Figura 2.1: Gráfico de barras del tipo de tormenta. Podemos personalizar este gráfico de barras si es necesario con funciones como xlab y ylab, y configurando varias propiedades dentro de geom_bar. Por ejemplo: # Retocamos las barras para que aparezcan en azul y con un ancho inferior # En este caso no almacenamos el gráfico sino que lo ejecutamos directamente ggplot(storm, aes(x = type)) + geom_bar(fill = &quot;blue&quot;, width = 0.7) + xlab(&quot;Tipo de Tormenta&quot;) + ylab(&quot;Número de observaciones&quot;) Figura 2.2: Gráfico de barras del tipo de tormenta (versión 2). Como podemos ver tanto en las tablas obtenidas como en los dos gráficos precedentes la escala del tipo de tormenta no está ordenada, es decir, no la tenemos graduada por la relevancia de la tormenta. Veamos como podemos hacer esto e integrarlo en el gráfico: # Creamos un vector con el orden predefinido ords &lt;- c(&quot;Tropical Depression&quot;, &quot;Extratropical&quot;, &quot;Tropical Storm&quot;, &quot;Hurricane&quot;) # Generamos el gráfico indica que el eje x tiene escala dada por el vector ordenado ggplot(storm, aes(x = type)) + geom_bar(fill = &quot;blue&quot;, width = 0.7) + scale_x_discrete(limits = ords) + xlab(&quot;Tipo de Tormenta&quot;) + ylab(&quot;Número de observaciones&quot;) Figura 2.3: Gráfico de barras del tipo de tormenta (versión 3). Ahora el gráfico si está ordenado con la escala adecuada y resulta más fácil cuantificar la relevancia de las tormentas más importantes. También podemos intercambiar las filas por las columnas para una mejor visualización de las etiquetas de la variable categórica. Para ello utilizamos el parámetro coord_flip(): ggplot(storm, aes(x = type)) + geom_bar(fill = &quot;blue&quot;, width = 0.7) + scale_x_discrete(limits = ords) + coord_flip() + xlab(&quot;Tipo de Tormenta&quot;) + ylab(&quot;Número de observaciones&quot;) Figura 2.4: Gráfico de barras del tipo de tormenta (versión 4). Por último utilizamos la función theme_bw() para configurar un fondo blanco para el gráfico. Otras posibilidades para los temas son theme_classic(), theme_dark(), theme_grey(), theme_light(). ggplot(storm, aes(x = type)) + geom_bar(fill = &quot;blue&quot;, width = 0.7) + scale_x_discrete(limits = ords) + coord_flip() + xlab(&quot;Tipo de Tormenta&quot;) + ylab(&quot;Número de observaciones&quot;)+ theme_bw() Figura 2.5: Gráfico de barras del tipo de tormenta (versión 5). En lugar de representar los contesos podemos visualizar los porcentajes asociados a cada categoría en lugar de los conteos haciendo uso de la variable ..prop.. en la configuración de geom_bar(). Se debe modificar la escala de la varaible para indicar que estamos representando porcentajes (labels = scales::percent): ggplot(storm, aes(x = type)) + geom_bar(aes(y = ..prop.. , group = 1),fill = &quot;blue&quot;, width = 0.7) + scale_y_continuous(labels = scales::percent) + coord_flip() + xlab(&quot;Tipo de Tormenta&quot;) + ylab(&quot;Porcentaje&quot;)+ theme_bw() Figura 2.6: Gráfico de barras del porcentaje de cada tipo de tormenta. 2.4.2 Una variable numérica En esta sección se considera cómo explorar la distribución de una variable numérica Se presentan las descriptivas básicas y visualizaciones que son apropiadas para las variables de este tipo. Para ejemplificar los procedimientos utilizaremos las variables wind y pressure. 2.4.2.1 Resúmenes numéricos Hasta ahora hemos estado describiendo las propiedades de las distribuciones de muestra en términos muy generales, usando frases como “valores más comunes” y “el rango de los datos” sin decir realmente lo que queremos decir. Los estadísticos han ideado términos específicos para describir este tipo de propiedades, así como diferentes estadísticas descriptivas para cuantificarlas. Los dos que más importan son la tendencia central y la dispersión: Una medida de tendencia central describe un valor típico (‘central’) de una distribución de datos. La medida de localización más extendida es la media aritmética de una muestra. Hay muchas medidas diferentes de tendencia central, cada una con sus propios pros y contras. Entre estos, la mediana es la que se usa con mayor frecuencia en los análisis exploratorios ya que es le valor que nos divide la muestra de dos partes iguales situando el 50% de los datos a cada lado de ese valor. Una medida de dispersión describe cómo se distribuye una distribución. Las medidas de dispersión cuantifican la variabilidad o dispersión de una variable con respecto al promedio de los datos. Si una distribución está más dispersa que otra, significa que, en cierto sentido, abarca una gama más amplia de valores. Lo que esto significa en la práctica depende del tipo de medida con la que estamos trabajando. Las medidas de dispersión más habituales son la varianza y su raíz cuadrada, la desviación estándar. 2.4.2.1.1 Medidas de tendencia central Hay dos estadísticos que se utilizan generalmente para describir la tendencia central de la distribución de los datos muestrales de un variable numérica. De ahora en adelante denotamos por \\(n\\) al tamaño muestral y \\(x_1, x_2,...,x_n\\) los valores muestrales de la variable que deseamos estudiar. La media muestral es la medida de tendencia muestral por excelencia. La definición matemática de la media muestral viene dada por: \\[\\begin{equation} \\bar{x} = \\frac{\\sum_{i=1}^n x_i}{n} \\tag{2.2} \\end{equation}\\] Para obtener la media utilizamos la función mean() mean(storm$wind) ## [1] 54.68329 mean(storm$pressure) ## [1] 989.8238 Esto nos dice que la media de la velocidad del viento es de 55 mph y que la media de la presión es de 989.82 milibares. ¿Como podemos interpretar esos resultados? Una limitación de la media aritmética es que se ve afectada por la forma de la distribución de los datos. Es muy sensible a los extremos de una muestra. Esta es la razón por la cual, por ejemplo, no tiene mucho sentido mirar el ingreso medio de los trabajadores en un país para tener una idea de lo que gana una persona “típica.” La distribución del ingreso es muy asimétrica, y los pocos que tienen la suerte de ganar salarios muy buenos tienden a cambiar la media hacia arriba y superar cualquier cosa que sea realmente “típica.” La media de la muestra también se ve fuertemente afectada por la presencia de ‘valores atípicos’ o valores extremos, es decir, valores inusualmente grandes o pequeños en una muestra. Debido a que la media muestral es sensible a la forma de una distribución y la presencia de valores atípicos, a menudo se prefiere una segunda medida de tendencia central: la mediana de la muestra. La mediana de una muestra es el número que separa los datos en dos subgrupos (la mitad superior de la mitad inferior). Podemos calcular la mediana muestral en R con la función median(): median(storm$wind) ## [1] 50 median(storm$pressure) ## [1] 995 Estos resultados indican que el 50% de de los registros muestran una valor de viento inferior a 50 mph. De la misma forma el 50% de los datos muestran una valor de la presión inferior a 995 milibares. Otras medidas de localización son el mínimo, el máximo y los percentiles. Los percentiles son los valores que dividen en la muestra según el valor del percentil solicitado. Si solicitamos el percentil 20, se separa la muestra en dos subconjuntos dejando el 20% en un grupo y e 80% en el otro. Los percentiles más habituales son lo denominados primer y tercer cuartil que corresponden a los percentiles 25 y 75 respectivamente. Para obtener el percentil asociado a una variable numérica podemos hacer uso de la función quantile(). Para ver como se debe utilizar es útil consultar la ayuda de dicha función help(quantile). 2.4.2.1.2 Medidas de dispersión Hay muchas maneras de cuantificar la dispersión de un conjunto de datos muestrales de una variable numérica. Los valores más importantes desde el punto de vista estadístico son la varianza muestral y la desviación estándar. La varianza muestral \\(s^2\\) es “la suma de las desviaciones cuadradas” (es decir, las diferencias) de cada observación con respecto a la media de la muestra, dividida por el tamaño de la muestra menos uno. La desviación típica es la raíz cuadrada de la varianza muestral. Las definiciones matemáticas de ambas cantidades son: \\[\\begin{equation} s^2 = \\frac{\\sum_{i=1}^n (x_i-\\bar{x})^2}{n-1} \\tag{2.3} \\end{equation}\\] \\[\\begin{equation} s = \\sqrt{s^2} \\tag{2.4} \\end{equation}\\] Las funciones de R para calcular ambas cantidades son var() para la varianza y sd() para la desviación típica. var(storm$wind);sd(storms$wind) ## [1] 668.1444 ## [1] 25.84849 var(storm$pressure);sd(storms$pressure) ## [1] 349.4912 ## [1] 18.69468 ¿Qué significa ese número en realidad? Las variaciones son siempre no negativas. Una pequeña varianza indica que las observaciones tienden a ser cercanas a la media (y una a la otra), mientras que una alta varianza indica que las observaciones están muy dispersas. Una varianza de cero solo ocurre si todos los valores son idénticos. Sin embargo, es difícil interpretar si una varianza muestral es realmente “pequeña” o “grande” porque el cálculo involucra desviaciones al cuadrado. Por ejemplo, cambiar la escala de medición de una variable por 10 implica un cambio de 100 veces (102) en la varianza. La varianza es una cantidad importante en las estadísticas que aparece una y otra vez. Muchas herramientas estadísticas comunes usan cambios en la varianza para comparar formalmente qué tan bien diferentes modelos describen un conjunto de datos. Sin embargo, es muy difícil interpretar las variaciones, por lo que rara vez las utilizamos en el trabajo exploratorio. Para expresar la variabilidad en la misma escala de la variable original utilizamos la desviación típica. En este caso se puede observar una mayor variabilidad en la variable presión atmosférica (desviación típica de 25.84 milibares) que en la variable de viento (18.69 mph). La desviación estándar de la muestra no está exenta de problemas. Al igual que la media muestral, es sensible a la forma de la distribución de los datos y a la presencia de valores atípicos. Una medida de dispersión más robusta para este tipo de características es el rango intercuartílico, definida como la diferencia entre el percentil 75 (tercer cuartil) y el percentil 25 (primer cuartil): \\[\\begin{equation} IQR = Q_3 - Q_1 \\tag{2.5} \\end{equation}\\] Obviamente, cuanto más dispersos estén los datos, mayor será el IQR. La razón por la que preferimos usar IQR para medir la dispersión es que solo depende de los datos en el “medio” de una distribución de muestra. Esto lo hace robusto a la presencia de valores atípicos. Podemos usar la función IQR() para calcular el rango intercuartílico: IQR(storm$wind) ## [1] 35 IQR(storm$pressure) ## [1] 24 La última medidad de dispersión que veremos es el coeficiente de variación. Esta medida es una de las más habituales y se obtiene a partir de la media y desviación típica muestral como: \\[\\begin{equation} CV = \\frac{s}{\\bar{x}} \\tag{2.6} \\end{equation}\\] Su fórmula expresa la desviación estándar como porcentaje de la media aritmética, mostrando una interpretación relativa del grado de variabilidad, independiente de la escala de la variable, a diferencia de la desviación típica o estándar. De esta forma, valores bajos del coeficiente de variación expresan menor variabilidad, lo que resulta de utilidad cuando deseamos comparar la variabilidad de dos muestras independeintemente de su media. El mayor problema es que sólo puede ser usado cuando la media muestral es positiva. 2.4.2.1.3 Resúmenes conjuntos Aunque podemos ir calculando cada una de las medidas de localización y dispersión vistas anteriormente, en la práctica nos resulta más útil obtenerlas todas de una vez. Existen diferentes funciones que nos permiten obterner estos análisis descriptivos. La primera de ellas es la función summary() que nos porporciona el mínimo, máximo, media, mediana y los percentiles 25 y 75. Sin embargo, no nos porporciona ninguna de las medidas de varaibilidad usuales. En nuestro ejemplo summary(storm$wind) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 15.00 35.00 50.00 54.68 70.00 155.00 summary(storm$pressure) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 905.0 980.0 995.0 989.8 1004.0 1019.0 Se pude ver que el 25% de las observaciones muestran una valor de viento inferior a 35mph y un 25% un valor de viento superior a 70mph. Con respecto a la presión atmosférica tenemos que el 25% de las observaciones tienen un valor inferior a 980 milibares, y un 25% tienen un valor superior a 1004 milibares. Otra función que nos porporciona medidas conjuntas es estat() de la librería pubh. Esta función nos porporciona el número de casos, el mínimo, el máximo, la media, la mediana, la desviación típica, y el coeficiente de variación. # Etiquetamos las variables storm = storm %&gt;% var_labels(wind = &#39;Wind speed (in knots)&#39;, pressure = &#39;Air pressure (in mbar)&#39;) # Análisis descriptivos estat(~ wind, data = storm) Tabla 2.4: NMin.Max.MeanMedianSDCV Wind speed (in knots)2.75e+031515554.75025.90.47 estat(~ pressure, data = storm) Tabla 2.4: NMin.Max.MeanMedianSDCV Air pressure (in mbar)2.75e+039051.02e+0399099518.70.02 2.4.2.2 Visualización gráfica En este apartado veremos como representar los datos de los conteos de una variable categórica mediante la función ’ggplot`. Esta función permite realizar casi cualquier tipo de gráfico que podamos imaginar. En este punto vamos a ir presentando diferentes parámetros de dicha función para ir familiarizándonos con su uso. 2.4.2.2.1 Gráfico barras El gráfico por excelencia para una variable de tipo numérico es el denominado histograma. El histograma es una representación mediante barras de la distribución de los datos. Para construir las barras se divide el rango de la variable numérica en un conjunto fijo de intervalos disjuntos y se contabiliza el número de datos que quedan dentro de cada uno de ellos (altura del gráfico de barras). Es un gráfico muy interesante porque representa de forma bastante precisa, ajustando el número de intervalos, la distribución del conjunto de datos pudiéndose observar su dispersión y/o asimetria. Para realizar este gráfico utilizamos parámetros específicos dentro de la función ggplot() a partir de geom_histogram(). ggplot(storm, aes(x = pressure)) + geom_histogram() Figura 2.7: Histograma de la presión atmosférica. Podemos ver que la mayoría de los datos se sitúan por encima de 915 milibares, hay una clara asimetría hacia los valores más grandes y existe una gran dispersión entre en el conjunto de valores observados. Veamos como introducir diferentes parámetros en el gráfico anterior. el más importante es el que hace referencia a los intervalos asociado con el histograma (parámetro binwith) ggplot(storm, aes(x = pressure)) + geom_histogram(binwidth = 8, fill = &quot;steelblue&quot;) + xlab(&quot;Air pressure (in mbar)&quot;) + ylab(&quot;Frequency&quot;) Figura 2.8: Histograma de la presión atmosférica (modificando binwidth). Veamos ahora el histograma de la variable wind ggplot(storm, aes(x = wind)) + geom_histogram(binwidth = 8, fill = &quot;steelblue&quot;) + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Frequency&quot;) Figura 2.9: Histograma de la velocidad del viento. El otro gráfico habitual para una variable de tipo numérico es el llamado gráfico de cajas. En este gráfico se representa mediante una caja la media (linea central de la caja), el percentil 75 (línea superior de la caja), y el percentil 25 (linea inferior de la caja). También se representan el valor máximo (percentil 75 + 1.5 IQR) y mínimo (percentil 25 - 1.5 IQR), así como los caracterizados como valores extremos (punto fuera de la caja). Veamos como realizar este gráfico mediante el parámetro geom_boxplot(). ggplot(storm, aes(x = factor(1),y = pressure)) + geom_boxplot() Figura 2.10: Gráfico de cajas de la presión atmosférica. Añadimos parámetros (título de ejes, color caja, selección de valores extremos, y fondo blanco) ggplot(storm, aes(x = factor(1), y = pressure)) + geom_boxplot(fill = &quot;orange&quot;, outlier.colour = &quot;red&quot;, outlier.shape = 1) + scale_x_discrete(name = &quot; &quot;) + scale_y_continuous(name = &quot;Air pressure (in mbar)&quot;) + theme_bw() Figura 2.11: Gráfico de cajas de la presión atmosférica (versión 2). Podemos ver que la media se sitúa muy próxima a los 1000 mbar y la gran cantidad de valores extremos en la parte baja de la distribución. Además la caja es muy estrecha indicando la poca variabilidad en los datos, lo que viene corroborado también por la proximidad de los percentiles 25 y 75. Ahora el gráfico para la variable wind ggplot(storm, aes(x = factor(1),y = wind)) + geom_boxplot(fill = &quot;orange&quot;,outlier.colour = &quot;red&quot;, outlier.shape = 1) + scale_x_discrete(name = &quot; &quot;) + scale_y_continuous(name = &quot;Wind speed (in knots)&quot;) + theme_bw() Figura 2.12: Gráfico de cajas de la velocidad del viento. ¿Cómo interpretamos este gráfico? 2.4.3 Dos variables categóricas Explorar numéricamente las asociaciones entre pares de variables categóricas no es tan simple como el caso de una variable. La pregunta general que debemos abordar es, “¿las diferentes combinaciones de categorías parecen estar sub o sobre representadas?” Necesitamos entender qué combinaciones son comunes y cuáles son raras. Lo más simple que podemos hacer es construir una tabulación cruzada del número de ocurrencias de cada combinación de niveles de ambas variables. La tabla resultante se llama tabla de contingencia. En cuanto a la representación gráfica la opción más habitual pasa por representar los conteos mediante gráficos de barras que representan de forma conjunta la información de ambas variables. Para ejemplificar los cálculos y gráficos utilizaremos las variables month_f (mes como factor) y type. En primer lugar etiquetamos las variables. # Etiquetamos las variables storm = storm %&gt;% var_labels(month_f = &#39;Month&#39;, type = &#39;Storm category&#39;) 2.4.3.1 Resúmenes numéricos El resumen numérico habitual para este tipo de situación es la tabla de contigencia (tabla de doble entrada) que nos porporciona los conteos o coincidencias entre los niveles de cada factor. Obtener la tabla completa (frecuencias y porcentajes) puede ser una faena algo pesada utilizando las funciones habituales. En nuestro caso utilizaremos la función cross_tab de la librería pubh. Dicha función nos porpociona la tbala de doble entrada con los conteos y los porcentajes marginales por columnas. Veamos su uso en el banco de datos. table(storm$type, storm$month_f) ## ## June July August September October November December ## Extratropical 27 38 23 149 129 42 4 ## Hurricane 3 31 300 383 152 25 2 ## Tropical Depression 22 59 150 156 84 42 0 ## Tropical Storm 31 123 247 259 204 61 1 Esta tabla nos permite analizar las concidencias entres los fatores estudiados (conteos), así como la relevancia de cada tipo de tormenta a los largo de los meses estudiados (porcentajes marginales por columnas). Por ejemplo, podemos ver que el perido más activo de huracanes es el comprendido entre los meses de agosto a octubre. En este caso los porcentajes marginales nos revelan que tipo de tormenta es más habitual dentro de cada mes de los analizados. Por ejemplo, en el mes de agosto el tipo de tormenta más habitual son los huracanes con un 40.1%, lo que representa casi la mitad de los observado durante ese mes. 2.4.3.2 Visualización gráfica Los gráficos de barras se pueden usar para resumir la relación entre dos variables categóricas. La idea básica es producir una barra separada para cada combinación de categorías en las dos variables. La longitud de estas barras es proporcional a los valores que representan, que son los recuentos brutos o las proporciones en cada combinación de categorías. Esta es la misma información que se muestra en una tabla de contingencia. El uso de ggplot2 para mostrar esta información no es muy diferente de producir un gráfico de barras para resumir una única variable categórica. Tomamos las variables type y year_f para mostrar su funcionamiento. Ordenamos la variable type para mostrar los gráficos por orden de importancia de la tormenta. En primer lugar realizamos el gráfico de barras apiladas. # Creamos un vector con el orden predefinido ords &lt;- c(&quot;Tropical Depression&quot;, &quot;Extratropical&quot;, &quot;Tropical Storm&quot;, &quot;Hurricane&quot;) # Generamos el gráfico indica que el eje x tiene escala dada por el vector ordenado ggplot(storm, aes(x = type, fill = year_f)) + geom_bar() + scale_x_discrete(limits = ords) + xlab(&quot;Storm category&quot;) + ylab(&quot;Frequancy&quot;) Figura 2.13: Gráfico de barras apiladas para tipo de tormenta versus año. En este caso cada tipo de tormenta tiene su propia barra, y cada barra se ha dividido en diferentes segmentos de colores, cuya longitud está determinada por el número de observaciones asociadas con cada año. Podemos apreciar si para un mismo tipo de tormenta la ocurrencia de un tipo de tormenta es similar o no. Por ejemplo, para los huracanes podemos apreciar que los años 1996, 1998, 1999, y 2000 tienen un número similar de ocurrencias. Un problema con este tipo de gráfico es que puede ser difícil detectar asociaciones entre las dos variables categóricas. Si queremos saber cómo están asociados, a menudo es mejor trazar los recuentos para cada combinación de categorías una al lado de la otra. Este gráfico se denomina gráfico de barras agrupado. Utilizamos la opción dodge en la función geom_bar para poder realizar esta versión: ggplot(storm, aes(x = type, fill = year_f)) + geom_bar(position = &quot;dodge&quot;) + scale_x_discrete(limits = ords) + labs(x = &quot;Storm category&quot;, y = &quot;Frequancy&quot;, fill = &quot;Storm category&quot;) Figura 2.14: Gráfico de barras agrupado para el tipo de tormenta versus año. ¿Qué ventajas o desventajas aprecias en este gráfico frente al de barras apiladas? Alternativamente podríamos realizar el gráfico de porcentahjes en lugar de los conteos. Hacemos uso de la función ..prop.. e indicamos la agrupación por la variable year_f: ggplot(storm, aes(x = type, fill = year_f)) + geom_bar(aes(y = ..prop.. , group = year_f),position = &quot;dodge&quot;) + scale_y_continuous(labels = scales::percent) + labs(x = &quot;Storm category&quot;, y = &quot;Percent&quot;, fill = &quot;Storm category&quot;) Figura 2.15: Gráfico de barras agrupado (porcentjes) para el tipo de tormenta versus año. Otra opción es realizar un mapa de intensidad de cada una de las combinaciones e ambos factores. Utilizamos la función geom_tile() a partir los conteos conjuntos para ambas variables con la opción count() que se almacenan en la variable temporal n. storm %&gt;% count(type,year_f) %&gt;% ggplot(mapping = aes(x = type, y = year_f)) + geom_tile(mapping = aes(fill = n)) + scale_x_discrete(limits = ords) + labs(x = &quot;Storm type&quot;, y = &quot;Year&quot;, fill = &quot;n&quot;) Figura 2.16: Mapa de intensidad para el tipo de tormenta versus año. En este caso las casillas en tonos más claros corresponden con las combinaciones de niveles con una mayor ocurrencia. Las más abundantes se concentran en 1995 y los tipos de tormenta más graves. Por otro lado el año 1997 es el que ha registrado menor número de tormentas. 2.4.4 Categórica vs Numérica El objetivo en este tipo de situaciones es comparar cada una de las distribuciones de la variable numérica que surgen al segmentar los valores por cada uno de los niveles de la variable categórica. Tenemos tantas conjuntos de datos como niveles del facgor hemos observado. 2.4.4.1 Resúmenes numéricos Los resúmenes numéricos se pueden construir tomando las diversas ideas que hemos explorado para las variables numéricas (medias, medianas, etc.) y aplicándolas a subconjuntos de datos definidos por los valores de la variable categórica. Sin embargo, podemos hacer uso de la función estat() para simplicar este trabajo. para ejemplificar su uso utilizamos la variable type como categórica y las variables wind y pressure como numéricas. storm$type &lt;- as.factor(storm$type) # Simplificamos las etiquetas de las variables storm = storm %&gt;% var_labels(wind = &#39;Wind&#39;, pressure = &#39;Air pressure&#39;) # Análisis descriptivos estat(~ wind|type, data = storm) Tabla 2.5: typeNMin.Max.MeanMedianSDCV WindExtratropical412158040.14013.2&nbsp;0.33 Hurricane8966515584.78018.8&nbsp;0.22 Tropical Depression513203027.4303.520.13 Tropical Storm9263512047.34511.1&nbsp;0.23 estat(~ pressure|type, data = storm) Tabla 2.5: typeNMin.Max.MeanMedianSDCV Air pressureExtratropical4129501.02e+03994&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;996&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14.2&nbsp;0.01 Hurricane8969051.00e+03970&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;974&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.9&nbsp;0.02 Tropical Depression5139821.02e+031.01e+031.01e+033.9&nbsp;0&nbsp;&nbsp;&nbsp; Tropical Storm9269351.01e+03998&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1e+03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.950.01 Se puede ver como el tipo Huracanes tiene la media más alta de velocidad del viento y la más baja de presión atmosférica. Además en ambos casos la variabilidad observada es la mayor de todos los tipos de tormenta. La depresión tropical es justo el caso contrario. Evidentemente los datos observados corresponden con la clasificación de tormenta establecida desde el inicio. ¿Qué otras conclusiones podemos obtener? ¿qué tipo de tormenta muestra una mayor variabilidad? 2.4.4.2 Visualización gráfica Para la visualización gráfica de las relaciones entre una variable categórica y una numérica tenemos diferentes opciones: gráfico de densidad, gráfico de cajas, y gráficos comparativos matriciales. El gráfico de densidad representa la distribución del conjunto de datos muestrales. Con este gráfico se puede apreciar claramente el rango de valores y su concentración (altura de la curva de densidad). Para su obtención utilizamos la opción geom_density() donde sólo debemos fijar el parámetro de suavizado, bw, que nos indica el grado de información que debemos utilizar para obtener dicha densidad. Valores pequeños dan curvas poco suavizadas y valores grandes dan curva suavizadas. Siempre es necesario un pequeño ajuste para obtener el valor más adecuado. Con este gráfico resulta muy fácil comparar el comportamiento de los diferentes grupos. Comenzamos con la variable wind: ggplot(storm, aes(x = wind)) + geom_density(aes(colour = type), bw = 3, na.rm = TRUE) + labs(x = &quot;Wind speed (in knots)&quot;, y = &quot;Density&quot;) Figura 2.17: Gráficos de densidades de la velocidad del viento por tipo de tormenta. # la opción na.rm elimina los valores pérdidos. El resultado son cuatro curvas de densidad (una por cada top de tormenta) donde los más destacable es que el rango de valores posibles para la velocidad del viento es sólo diferente para el tipo huracanes, ya que su curva de densidad se encuentra desplazada respecto del resto de densidades. También se puede ver que las depresiones tropicales tienen una menor dispersión (menor rango de valores) los que provoca que su curva sea más puntiaguda. Cuanto mayor sea la dispersión mas amplia sera la densidad obtenida. Si la densidad es simétrica la media se sitúa en el punto medio, mientras que el valor asociado con el punto más alto de la densidad es lo que denominamos moda. Ahora con la variable presión atmosférica: ggplot(storm, aes(x = pressure)) + geom_density(aes(colour = type), bw = 3, na.rm = TRUE) + labs(x = &quot;Air pressure (in knots)&quot;, y = &quot;Density&quot;) Figura 2.18: Gráficos de densidades de la presión atmosférica por tipo de tormenta. El comportamiento de la variable presión atmosférica es muy similar al de la velocidad del viento pero en la parte izquierda del rango de valores. Los huracanes tienen la menor presión atmosférica y se distinguen del resto de tipos de tormenta. También muestra una mayor variabilidad que el resto de tipos. La visualización más común para explorar las relaciones entre una variable categórica y otra numérica es el diagrama de cajas. Cada diagrama de caja consiste en: Una casilla que se extiende desde el percentil 25 de la distribución hasta el percentil 75, una distancia conocida como rango intercuartílico (IQR). En el medio del recuadro hay una línea que muestra la mediana, es decir, el percentil 50 de la distribución. Estas tres líneas le dan una idea de la extensión de la distribución y si la distribución es simétrica o no respecto a la mediana o sesgada hacia un lado. Puntos visuales que muestran observaciones que caen más de 1,5 veces el IQR desde cualquier borde de la caja. Estos puntos remotos son inusuales, por lo que se representan de forma individual. Una línea (o bigote) que se extiende desde cada extremo de la caja y va al el punto más lejano no atípico en la distribución. Veamos los ejemplos: ggplot(storm, aes(x = type, y = wind)) + geom_boxplot() + scale_x_discrete(limits = ords) + labs(x = &quot;Storm category&quot;, y = &quot;Wind speed (in knots)&quot;) Figura 2.19: Gráficos de cajas de la velocidad del viento por tipo de tormenta. En este tipo de gráficos se esta interesado en dos aspecto fundamentales: * Estudiar la variabilidad dentro de cada grupo viendo la altura de la caja (IQR). * Comparar el comportamiento de cada grupo observando si las cajas quedan a alturas superpuestas. En este caso podemos ver que la variabilidad más grande se produce en el tipo huracanes y la más pequeña en las depresiones tropicales. Se aprecian diferencias entre las variabilidades de los grupos. Por otro lado, las cajas correspondientes a las tormentas extra tropicales y tormentas tropicales quedan a una misma altura indicando que tienen valores similares para la velocidad del viento. Este gráfico nos da unas primeras indicaciones claras para los procedimientos de comparaciones de medias que estudiaremos más adelante. ggplot(storm, aes(x = type, y = pressure)) + geom_boxplot() + scale_x_discrete(limits = ords) + labs(x = &quot;Storm category&quot;, y = &quot;Air pressure (in mbar)&quot;) Figura 2.20: Gráficos de cajas de la presión atmosférica por tipo de tormenta. En este caso observamos que los tipos extra tropical y Huracanes muestran variabilidades similares, mientras que los otros dos tipos también muestran variabilidades similares. En cuanto a la comparación de los grupos se observa que el único con un comportamiento diferente son los huracanes. Los otros tres tipos muestran cajas que se podrías solapar mostrando una mayor igualdad en los valores de presión atmosférica. Los gráficos matriciales o de facetas permiten representar mediante múltiples gráficos la información de una variable numéricas con respecto a los niveles de la variable categórica. Se pretende de esta forma comprobar la forma de la distribución de los datos de forma similar al gráfico de densidad pero realzando un gráfico para cada nivel. Aunque resultan más útiles cuando trabajamos con más de dos variables, se introducen aquí para ir conociendo su funcionamiento en ejemplos sencillos. Comenzamos realizando un histograma independiente. Para que resulte más fácil visualizar el gráfico introducimos un orden asociado con los valores de la variable numérica, comenzando con el nivel que tiene valores en esa variable más pequeños, y finalizando con la que tiene los valores más grandes. # Creamos un nuevo factor ordenado de acuerdo a la variable que estamos midiendo storm$type2 &lt;- reorder(storm$type, storm$wind) # Creamos el gráfico ggplot(storm, aes(x = wind)) + geom_histogram(binwidth = 5) + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Frequency&quot;) + facet_wrap(~ type2, ncol = 1) Figura 2.21: Gráficos matricial de velocidad del viento por tipo de tormenta También podríamos realizar el gráfico de densidad # Creamos el gráfico ggplot(storm, aes(x = wind)) + geom_density(bw = 3) + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Density&quot;) + facet_wrap(~ type2, ncol = 1) Figura 2.22: Gráficos matricial de velocidad del viento por tipo de tormenta En ambos casos las interpretaciones son similares a las que se hicieron con el gráfico conjunto de densidad. Podemos cambiar la configuración cambiando el número de columnas: # Creamos el gráfico ggplot(storm, aes(x = wind)) + geom_density(bw = 3) + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Density&quot;) + facet_wrap(~ type2, ncol = 2) Figura 2.23: Gráficos matricial de velocidad del viento por tipo de tormenta Aunque el gráfico se visualiza mejor también resulta más difícil la comparación entre todos los niveles. Si deseamos cambiar la situación de las etiquetas del factor podemos utilizar la opción facet_grid. # Creamos el gráfico ggplot(storm, aes(x = wind)) + geom_density(bw = 3) + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Density&quot;) + facet_grid(type2 ~ .) Figura 2.24: Gráficos matricial (grid) de velocidad del viento por tipo de tormenta Esta opción nos resultará de mayor utilidad cuando tengamos que representar dos factores ya que se podrá situar en la filas uno de los factores y el otro en las columnas con la opción facet_grid(factor1 ~ factor2). 2.4.5 Dos variables numéricas Los estadísticos han ideado varias formas diferentes de cuantificar la asociación entre dos variables numéricas en un banco de datos. Las medidas más comunes medidas buscan calcular algún tipo de coeficiente de asociación Los términos “asociación” y “correlación” están estrechamente relacionados; tanto que a menudo se usan indistintamente. La más habitual es la correlación lineal que cuantifica el grado de asociación lineal entre dos variables de tipo numérico. Para ejemplificar nuestros cálculos y gráficos utilizaremos las variables wind y preassure. 2.4.5.1 Resúmenes numéricos La medida de correlación más utilizada es el coeficiente de correlación lineal de Pearson. El coeficiente de correlación de Pearson cuantifica el grado de asociación entre las variables en la escala -1 a 1, donde -1 indica una relación inversa (cuando una variable crece la otra decrece) y 1 indica una relación directa (cuando una crece la otra también lo hace. Valores próximo a cero indican que no hay asociación lineal entre las variables analizadas. Este coeficiente es la base para plantear lo que denominaremos más adelante los modelos de regresión lineal simple. La definición formal del coeficiente de correlación de Pearson (\\(\\rho\\)) viene dada por: \\[\\begin{equation} \\rho = \\frac{1}{n-1}\\sum_{i=1}^n \\frac{(x_i - \\bar{x})(y_i - \\bar{y})}{s_x s_y} \\tag{2.7} \\end{equation}\\] donde \\(x_i\\), \\(y_i\\) son las observaciones de la variable \\(x\\) e \\(y\\) respectivamente, \\(\\bar{x}\\), \\(\\bar{y}\\) son las medias muestrales de cada variable, y \\(s_x\\), \\(s_y\\) son las desviaciones típica de cada variable. El coeficiente trata de valorar la “covaraición” entre ambas variables, es decir, como afectan los cambios de valores en una variable en los valores de la otra, teniendo en cuenta la propia variabilidad de cada una de ellas. Para obtener el coeficiente de correlación utilizamos la función cor(). cor(storm$wind,storm$pressure) ## [1] -0.9254911 El coeficiente de correlación resulta negativo, lo que indica que la velocidad del viento tiende a disminuir al aumentar la presión. Al estar próximo a -1 se puede intuir que dicha asociación es muy fuerte. Sin embargo, el coeficiente de correlación de Pearson debe interpretarse con cuidado debido a que está diseñado para medir una relación de tipo lineal, lo que implica que dicho coeficiente será engañoso cuando esta relación sea curva, o incluso peor, en forma de joroba. ¿Qué deberíamos hacer si pensamos que la relación entre dos variables no es lineal? No deberíamos usar el coeficiente de correlación de Pearson para medir la asociación en este caso. En cambio, podemos calcular lo que denominamos correlación de rango. La idea es muy simple. En lugar de trabajar con los valores reales de cada variable, los “clasificamos,” es decir, ordenamos cada variable de menor a mayor y asignamos las etiquetas “primero,” “segundo,” “tercero,” etc. a diferentes observaciones. Las medidas de correlación de rangos se basan en una comparación de los rangos resultantes. Los dos más populares son Spearman’s y Kendall’s. Ambos coeficientes se comportan de una manera muy similar al coeficiente de correlación de Pearson. Toman un valor de 0 si los rangos no están correlacionados, y un valor de +1 o -1 si están perfectamente relacionados. Podemos calcular ambos coeficientes de correlación de rangos en R usando nuevamente la función cor. Esta vez necesitamos establecer el argumento del método en el valor apropiado: method = \"kendall\" o method = \"spearman\". cor(storm$wind,storm$pressure,method = &quot;kendall&quot;) ## [1] -0.7627645 cor(storm$wind,storm$pressure,method = &quot;spearman&quot;) ## [1] -0.9025831 Los resultados obtenidos son compatibles con el del coeficiente de Pearson. 2.4.5.2 Visualización gráfica Los coeficientes de correlación nos dan una forma simple de resumir las asociaciones entre variables numéricas. Sin embargo, son limitados, porque un solo número nunca puede resumir todos los aspectos de la relación entre dos variables. Es por eso que siempre visualizamos la relación entre dos variables. El gráfico estándar para mostrar asociaciones entre variables numéricas es un diagrama de dispersión, usando ejes horizontales y verticales para trazar dos variables como una serie de puntos. Para realizar este gráfico usamos la opción geom_point() ggplot(storm, aes(x = wind, y = pressure)) + geom_point() + labs(x = &quot;Wind speed (in knots)&quot;, y = &quot;Air pressure (in mbar)&quot;) Figura 2.25: Gráfico de dispersión de velocidad del viento vs presión atmosférica En el gráfico se puede apreciar la relación de tipo lineal en orden o pendiente decreciente (cuando aumenta el viento disminuye la presión). El problema de este gráfico es que no podemos apreciar todos los puntos, ya que si tenemos dos observaciones con los mismo valores en ambas variables, estos quedarían superpuestos. Para solucionar esta deficiencia podemos optar por otra versión del gráfico de dispersión que nos permita contabilizar el número de repeticiones cuando estas existan. Este gráfico se obtiene con la opción geom_hex(). Para poder realizarlo es necesario instalar la librería hexbin: ggplot(storm, aes(x = wind, y = pressure)) + geom_hex(bins = 25) + labs(x = &quot;Wind speed (in knots)&quot;, y = &quot;Air pressure (in mbar)&quot;, fill = &quot;n&quot;) Figura 2.26: Gráfico de dispersión de velocidad del viento vs presión atmosférica (versión dos). El parámetro bins segmenta el rango de cada variable en intervalos disjuntos. Lo que se representa es una gráfico de dispersión por intervalos, de forma que cada casilla representa todos los valores que quedan dentro del intervalo conjunto que obtenemos con ambas variables. Se observa que la tendencia se mantiene pero resulta posible ver que valores muestran una mayor o menor ocurrencia. La combinación de valores bajos de viento (&lt; 40 mph) con altos de presión (&gt; 990 mb) son los que más aparecen en el banco de datos. Otra opción es agrupar una variable continua para que actúe como una variable categórica. Luego se puede usar un gráfico combinado de cajas para representar ambas variables Veamos un ejemplo: ggplot(data = storm, aes(x = wind, y = pressure)) + geom_boxplot(mapping = aes(group = cut_width(wind, 10))) + labs(x = &quot;Wind speed (in knots)&quot;, y = &quot;Air pressure (in mbar)&quot;, fill = &quot;n&quot;) Figura 2.27: Gráfico de cajas discretizando la velocidad del viento vs presión atmosférica. La interpretación es similar a la que se realizaba cuando trabajamos con una variable factor y otra numérica. Lo que resulta interesante es que podemos observar los intervalos con un mayor volumen de valores extremos o anómalos (valores de viento entre 30 y 90 mph). 2.5 Análisis Descriptivo avanzado En esta unidad se amplían los procedimientos de análisis descriptivos vistos en el tema anterior para estudiar una o dos variables de tipo numérico o categórico al caso de más de dos variables de este tipo. No se hace un barrido a cualquier situación que pueda aparecer sino que se pretende mostrar los casos más habituales. Dichos casos son: Tres variables categóricas. Dos variables categóricas y una variable numérica. Una variable categórica y dos variables numéricas. Dos variables categóricas y dos variables numéricas. Tres variables categóricas y dos variables numéricas. De nuevo utilizaremos el conjunto de datos storms de la librería nasaweather. 2.5.1 Tres factores Los procedimientos numéricos se restringen en este caso a la obtención de la tabla de frecuencias conjunta de las tres variables, mientras que los gráficos se basan en gráficos matriciales donde se consideran gráficos de barras. A modo de ejemplo vamos a realizar el análisis conjunto de las variables year_f, month_f y type. Para poder realizar estos análisis utilizamos la función mytable de la librería moonBook. Para conocer todas las caracter´siticas de esta función se recomienda ver la ayuda help(mytable). EL problema principal con esta función es que si el número de nivles de los factores es demasiado grande resulta muy complicado visualizar todos los resultados en una única página. De hecho solo se pueden visulaizar resulatdos si el número de niveles del factor es 5 como máximo. Para poder ver los resultados en esta situación procedemos reando un conjunto de datos para cada tipo de tormenta. En este caso seleccionamos los meses centrales y los últimos cinco años para poder visualizar los resultados. #{r aed045,error=FALSE,warning=FALSE,message=FALSE} #stormTD &lt;- dplyr::filter(storm , month %in% c(7,8,9,10,11), # year %in% c(1996,1997,1998,1999,2000)) #mytable(year_f + type ~ month_f, data = stormTD) # Para realizar le gráfico combinado de las tres variables categóricas utilizamos un gráfico matricial con dos factores y representamos dentro de cada combinación el gráfico de barras de la otra variable. ords &lt;- c(&quot;Tropical Depression&quot;, &quot;Extratropical&quot;, &quot;Tropical Storm&quot;, &quot;Hurricane&quot;) ggplot(storm, aes(x = type)) + geom_bar() + scale_x_discrete(limits = ords) + xlab(&quot;Storm category&quot;) + ylab(&quot;Frequency&quot;) + facet_grid(year_f ~ month_f)+ theme(axis.text.x = element_text(angle = 90)) Figura 2.28: Gráfico de barras para tipo de tormenta para los diferentes meses y años. ¿Qué conclusiones podemos extraer de estos resultados? El gráfico resulta revelador, ya que se aprecian de forma directa las combinaciones de año - mes en al que no hay datos, y en aquellas donde si los hay se puede ver claramente cual es el tipo de tormenta más predominante. Dado que la mayoría de los datos se producen entre los meses de agosto y octubre vamos a filtrar los datos para estudiar esas combinaciones únicamente. storm_meses &lt;- storm %&gt;% filter(month_f == c(&quot;August&quot;,&quot;September&quot;,&quot;October&quot;)) ords &lt;- c(&quot;Tropical Depression&quot;, &quot;Extratropical&quot;, &quot;Tropical Storm&quot;, &quot;Hurricane&quot;) ggplot(storm_meses, aes(x = type)) + geom_bar() + scale_x_discrete(limits = ords) + xlab(&quot;Storm category&quot;) + ylab(&quot;Frequency&quot;) + facet_grid(year_f ~ month_f) + theme(axis.text.x = element_text(angle = 90)) Figura 2.29: Gráfico de barras para tipo de tormenta para los diferentes meses y años (versión 2). Este gráfico nos permite estudiar con más detalle los meses que concentran un mayor número de tormentas. 2.5.2 Dos factores, Una numérica En este caso generalizamos el cálculo de medidas de localización y dispersión a esta situación, y analizamos los diferentes gráficos que podemos realizar en esta situación. Utilizamos las variables year_f, type, y wind. Mostraremos solo los datos para los años 1999 y 2000. stormTD &lt;- dplyr::filter(storm , year %in% c(1999,2000)) mytable(year_f + type ~ wind, data = stormTD) ## ## Descriptive Statistics stratified by &#39;year_f&#39; and &#39;type&#39; ## ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— ## 1999 2000 ## —————————————————————————————————————————————————————————————————— —————————————————————————————————————————————————————————————————— ## Extratropical Hurricane Tropical Depression Tropical Storm p Extratropical Hurricane Tropical Depression Tropical Storm p ## (N=22) (N=164) (N=75) (N=150) (N=63) (N=130) (N=76) (N=138) ## ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— ## Wind 38.9 ± 20.3 90.5 ± 20.7 27.1 ± 3.9 47.7 ± 8.1 0.000 39.7 ± 13.2 79.5 ± 14.7 27.8 ± 2.6 46.2 ± 8.5 0.000 ## ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— Como antes el análisis de estas tablas es más complejo que tratar de representar los datos de forma que se puedan extraer conclusiones de forma más efectiva. Empezamos con el gráfico matricial mezclado con los gráficos de densidad. # Creamos un nuevo factor ordenado de acurdo a la variable que estamos midiendo storm$type2 &lt;- reorder(storm$type, storm$wind) # Creamos el gráfico ggplot(storm, aes(x = wind, color = type2)) + geom_density(bw = 3) + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Density&quot;) + facet_grid(year_f ~ .) Figura 2.30: Gráfico de densidad de la velocidad del viento para cada tipo de tormenta y año. Ahora realizamos el gráfico de cajas con una estructura similar # Creamos el gráfico ggplot(storm, aes(x = type2, y = wind)) + geom_boxplot() + xlab(&quot;Storm category&quot;) + ylab(&quot;Wind speed (in knots)&quot;) + facet_grid(. ~ year_f) + theme(axis.text.x = element_text(angle = 90)) Figura 2.31: Gráfico de cajas de la velocidad del viento para cada tipo de tormenta y año. ¿Qué conclusiones podemos extraer de este gráfico? Otra versión de este gráfico podría ser: # Creamos el gráfico ggplot(storm, aes(x = year_f, y = wind, color = type2)) + geom_boxplot() + xlab(&quot;Year&quot;) + ylab(&quot;Wind speed (in knots)&quot;) Figura 2.32: Gráfico de cajas de la velocidad del viento para cada tipo de tormenta y año (versión 2). 2.5.3 Un factor, Dos numéricas En este caso generalizamos el análisis de correlación y el gráfico de dispersión con la inclusión del factor. Consideramos las variables type, wind y pressure. En primer lugar realizamos el estudio descriptivo numérico. storm %&gt;% group_by(type) %&gt;% # Segmentamos por tipo de tormenta summarise(cor = cor(wind,pressure)) # Obtenemos coeficientes de correlación Tabla 2.6: typecor Extratropical-0.816 Hurricane-0.914 Tropical Depression-0.157 Tropical Storm-0.819 El resultado muestra gran asociación entre la velocidad del viento y la presión atmosférica en todas la categorías salvo para las Depresiones tropicales. Veamos ahora el gráfico de dispersión conjunto. En primer lugar realizamos un único gráfico marcando con colores los tipos de tormenta ggplot(storm, aes(x = wind, y = pressure, color = type )) + geom_point() + labs(x = &quot;Wind speed (in knots)&quot;, y = &quot;Air pressure (in mbar)&quot;) Figura 2.33: Gráfico de dispersion de presión vs velocidad para cada tipo de tormenta. Podemos ver como cada punto viene identificado según el tipo de tormenta. Los huracanes en la parte inferior donde se dan las relaciones entre velocidades del viento más altas y presiones atmosféricas más bajas. ¿Qué más podemos decir? Podemos distinguir cada grupo introduciendo un gráfico matricial # Creamos el gráfico ggplot(storm, aes(x = wind, y = pressure)) + geom_point() + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Air pressure (in mbar)&quot;) + facet_grid(. ~ type2) Figura 2.34: Gráfico de dispersion de presión vs velocidad para cada tipo de tormenta. En este gráfico se aprecia mejor el comportamiento de ambas variables en cada uno de los niveles del factor. Salvo en las depresiones tropicales donde no se aprecia asociación, en el resto de niveles se aprecia un relación de orden inverso. Lo que si podemos ver es que hay observaciones en algunas categorías que podrían corresponder a otras. En la categoría de tormentas tropicales tenemos combinaciones de velocidad y presión que parecen corresponder más a un huracán que a una tormenta tropical. Esto puede ser debido al protocolo de clasificación establecido o a la propia evolución de las tormentas. 2.5.4 Dos factores, Dos numéricas Este caso es una generalización directa del caso anterior, ya que únicamente debemos añadir una nueva variable categórica. Consideramos las variables type, year_f, wind y pressure. Comenzamos con el análisis numérico: tabla_cor &lt;- storm %&gt;% group_by(year_f,type) %&gt;% summarise(cor = cor(wind,pressure)) # Visulaizamos la tabla de resultados de forma óptima tabla_resumen &lt;- dplyr::select(tabla_cor,year_f,type,cor) # Arreglamos la tabla para una mejor visualización spread(tabla_resumen, key = type, value = cor) ## # A tibble: 6 × 5 ## # Groups: year_f [6] ## year_f Extratropical Hurricane `Tropical Depression` `Tropical Storm` ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1995 -0.848 -0.885 0.113 -0.731 ## 2 1996 -0.826 -0.941 -0.290 -0.917 ## 3 1997 -0.781 -0.973 -0.455 -0.748 ## 4 1998 -0.726 -0.947 -0.271 -0.613 ## 5 1999 -0.961 -0.916 -0.170 -0.661 ## 6 2000 -0.915 -0.940 -0.127 -0.791 En esta tabla aparecen representados los coeficientes de correlación entre viento y presión para las diferentes combinaciones de niveles de las variables tipo y año. Se aprecian valores muy bajos en todas las combinaciones de la depresión tropical, mientras que en el resto hay asociaciones que pueden resultar interesantes de estudiar posteriormente. En el caso de los huracanes esas asociaciones son muy fuertes ya que muestran valores muy próximos a -1. En cuanto a los procedimientos gráficos optamos por una combinación de los gráficos que utilizamos en la sección anterior. Representamos el gráfico de dispersión coloreando por tipo de tormenta, y usamos un diagrama matricial por año. # Creamos el gráfico ggplot(storm, aes(x = wind, y = pressure, color = type2)) + geom_point() + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Air pressure (in mbar)&quot;) + facet_grid(. ~ year_f) Figura 2.35: Gráfico de dispersion de presión vs velocidad para cada tipo de tormenta y año. En todos los años se observa un comportamiento similar del resto de variables, indicando que el año no es una factor que pueda ser considerado como relevante. Si utilizamos la variable mes en su lugar el gráfico resultante es: # Creamos el gráfico ggplot(storm, aes(x = wind, y = pressure, color = type2)) + geom_point() + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Air pressure (in mbar)&quot;) + facet_grid(. ~ month_f) + theme(axis.text.x = element_text(angle = 90)) Figura 2.36: Gráfico de dispersion de presión vs velocidad para cada tipo de tormenta y mes En este caso el comportamiento de los meses no es tan parecido. Si bien es cierto que en todas las combinaciones se aprecia una tendencia negativa (sube viento - baja presión), también se puede ver que los huracanes aparecen mayoritariamente en los meses de agosto a octubre. ¿Qué otra información podemos extraer de este gráfico? 2.5.5 Tres factores, Dos numéricas Es una generalización directa de los dos casos anteriores. Se presenta únicamente el código para obtener los resultados. Añadimos la variable month_f a las del caso anterior. tabla_cor &lt;- storm %&gt;% group_by(year_f,month_f,type) %&gt;% summarise(cor = cor(wind,pressure)) # Visulaizamos la tabla de resultados de forma óptima tabla_resumen &lt;- dplyr::select(tabla_cor,year_f,month_f,type,cor) spread(tabla_resumen, key = type, value = cor) ## # A tibble: 30 × 6 ## # Groups: year_f, month_f [30] ## year_f month_f Extratropical Hurricane `Tropical Depress…` `Tropical Storm` ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1995 June -0.688 NA NA -0.849 ## 2 1995 July -0.816 NA 0.121 -0.701 ## 3 1995 August -0.926 -0.750 0.294 -0.805 ## 4 1995 September -0.881 -0.931 -0.203 -0.937 ## 5 1995 October -0.954 -0.918 -0.0585 -0.727 ## 6 1995 November -0.968 NA NA 1 ## 7 1996 June -0.591 NA -0.828 0 ## 8 1996 July -0.165 -0.779 -0.612 -0.955 ## 9 1996 August NA -0.976 -0.0301 -0.830 ## 10 1996 September -0.887 -0.852 0.0622 -0.927 ## # … with 20 more rows ¿Qué podemos decir de los resultados obtenidos? Veamos ahora el gráfico matricial. Seleccionamos los meses de agosto a octubre para poder visualizarlo mejor. storm_meses &lt;- storm %&gt;% filter(month_f == c(&quot;August&quot;,&quot;September&quot;,&quot;October&quot;)) # Creamos un nuevo factor ordenado de acurdo a la variable que estamos midiendo storm_meses$type2 &lt;- reorder(storm_meses$type, storm_meses$wind) # Creamos el gráfico ggplot(storm_meses, aes(x = wind, y = pressure, color = type2)) + geom_point() + xlab(&quot;Wind speed (in knots)&quot;) + ylab(&quot;Air pressure (in mbar)&quot;) + facet_grid(year_f ~ month_f) + theme(axis.text.x = element_text(angle = 90)) Figura 2.37: Gráfico de dispersion de presión vs velocidad para cada tipo de tormenta, año y mes. ¿Qué podemos decir de este gráfico? 2.6 Librería de interés La libreria ggplotgui a través de la función ggplot_shiny nos permite generar una aplicación con la que se puede obtener el código correspondiente a un gráfico. Para utilizar dicha función basta con escribir ggplot_shiny(dataframe). References "],["prob.html", "Unidad 3 Probabilidad 3.1 Introducción 3.2 Distribuciones-Modelos 3.3 Distribuciones notables", " Unidad 3 Probabilidad En esta unidad introducimos los conceptos básicos de varaible aleatoria, distribución de probabilidad, y las variables aleatorias más habituales en la investigación científica. No se trata de una unidad sobre probabilidad (para lo que se recomienda acudir a libros con mayores desarrollos), sino una unidad práctica de conocimiento básico de las distribuciones de probabilidad que juegan un papel relevante en los procesos de inferencia y en la cnstruccion de modelos estadísticos que veremos en las unidades siguientes. 3.1 Introducción La probabilidad o el azar juega un papel muy importante en el razonamiento científico. Ejemplos de procesos biológicos donde la probabilidad juega un papel relevante son: i) la segregación de cromosomas en la formación de gametos o la ocurrencia de mutaciones genéticas. En otras ocasiones es el propio diseño experimental el que introduce la aleatoriedad como por ejemplo cuando dividimos un grupo de sujetos en función del tratamiento al que se van a ver sometidos. Las conclusiones del análisis estadístico de datos se expresan en muchas ocasiones en términos de probabilidad, ya que implícitamente se está introduciendo la aleatoriedad debida a la muestra de sujetos con el que estamos trabajando, y que generalmente no coincide con toda la población bajo estudio. En las unidades anteriores hemos visto que el estudio estadístico se centra en la información recogida sobre alguna variable relacionada directamente con el objetivo u objetivos del diseño experimental planteado. Un hecho cierto es que debido a la aleatoriedad e los sujetos resulta imposible saber con certeza el valor de dicha variable para un sujeto en particular. Se introduce de esta forma el concepto de variable aleatoria que hace referencia a todas aquellas en las que intrínsecamente se reconoce variabilidad en la respuesta de los sujetos. En este punto introducimos algo de notación que nos resultará de utilidad de aquí en adelante. Las variables aleatorias siempre se denotan en mayúsculas, \\(Y\\), mientras que los valores observados para un conjunto de sujetos en esa variable (muestra) se denotan por minúsculas e indicando la posición que el sujeto ocupa en el banco de datos \\(y_1,y_2,...,y_n\\). Por razones obvias se definen entonces las variables aleatorias discretas y las variables aleatorias continuas. Una variable discreta es aquella que sólo puede tomar un número finito o contable de posibles resultados, de forma que es posible conocer de antemano cuales son los posibles resultados que se pueden observar. Una variable continua es aquella que puede tomar infinitos valores numéricos, y por tanto es imposible identificar cada uno de los posibles valores de la variable, aunque si es posible conocer el rango de posibles resultados que se pueden observar. De forma natural se puede establecer una equivalencia entre la definición de variables categóricas y numéricas introducidas en unidades anteriores con las variables discretas y continuas. Se puede describir de forma completa una variable aleatoria sin más que especificar la probabilidad asociada a cada uno de sus posibles valores. Esta especificación se conoce con el nombre de distribución de probabilidad. Sin embargo, la forma en que se puede especificar dicha distribución de probabilidad depende del tipo de variable aleatoria con la que estemos trabajando. En el caso de variables discretas basta con determinar la probabilidad de cada uno de los posibles resultados observables de la variable, pero no ocurre así en las variables continuas donde es imposible conocer todos sus posibles valores. 3.2 Distribuciones-Modelos En la Unidad anterior se ha visto que el objetivo principal de muchos análisis estadísticos es estudiar el comportamiento de los sujetos de una población, a partir de la información recogida en una muestra de sujetos seleccionados de dicha población. Sin embargo, cuando hablamos de una población lo hacemos teniendo en mente las variables que se han medido sobre ellos. Imaginemos que estamos interesados en conocer la nota media de acceso de todos los estudiantes de primero de grado en la Universidad Miguel Hernández de Elche (UMH). En este caso es evidente que la población objetivo son todos los estudiantes de primero de grado que han accedido a la UMH, aunque esa población contiene información sobre muchas otras variables (sexo, edad, localidad de residencia,…).Por lo tanto, todas las poblaciones se considerarán poblaciones de valores de alguna variable especificada. Si la población es infinita, nunca podremos obtener todos sus valores, e incluso si la población es finita, generalmente no queremos medir todos sus valores. En cualquier caso, deseamos obtener información sobre características particulares de la población a partir de un número restringido de valores de muestra. Por ejemplo, en el estudio de la nota de acceso podríamos querer utilizar la media de la nota media de todos los estudiantes como referencia de la población, aunque podríamos utilizar otros como el percentil 80, etc… Para proceder de esta forma, necesitamos formular un modelo adecuado para los valores \\(x\\) que componen la población, relacionar las características de interés con los aspectos apropiados del modelo y luego usar los datos de la muestra para proporcionar estimaciones de estos aspectos.La característica esencial de tales valores \\(x\\) en su imprevisibilidad, y lo mejor que podemos hacer es especificar la probabilidad de obtener un valor dado o un valor en un rango dado. Por lo tanto, las distribuciones de probabilidad proporcionan los modelos más apropiados para las poblaciones variables de respuesta. Más específicamente, la función de densidad de probabilidad \\(f(x)\\) o la función de distribución de probabilidad \\(F(x)\\) proporcionan la información necesaria, por lo que constituye el modelo de población para la variable aleatoria \\(X\\). Por supuesto, dado que nunca conocemos esta distribución con una certeza total, debemos suponer una forma funcional específica (modelo matemático) para \\(f(x)\\) y \\(F(x)\\). Esta forma funcional usualmente involucra uno o más parámetros que pueden ser variados, y leso que se espera es que habrá algunos valores específicos de estos parámetros para los cuales la distribución resultante se ajusta adecuadamente a nuestros datos observados. Tal modelo se llama modelo paramétrico para \\(X\\). En el tema siguiente se presentarán los modelos paramétricos más frecuentes para una variable aleatoria \\(X\\). Por el momento, supongamos que hemos especificado alguna función adecuada \\(f(x)\\) como la densidad de probabilidad de nuestra población. ¿Qué valores resumen de esta densidad se relacionan con las características de la población que generalmente son de interés? Para responder a esta situación, centrémonos en las variables discretas e interpretemos la probabilidad como una frecuencia relativa. Si la variable aleatoria \\(X\\) tiene valores posibles \\(x_1, x_2, x_3, ... ,x_n\\) y si \\(p_i = P(X = x_i)\\), entonces podemos pensar en \\(p_i\\) como la frecuencia relativa con la que el valor \\(x_i\\) ocurre en toda la población. Definimos el valor esperado de \\(X\\) por la ecuación: \\[\\begin{equation} E(X) = \\sum_{i=1}^n x_i p_i \\tag{3.1} \\end{equation}\\] Utilizando la interpretación de frecuencia relativa de \\(p_i\\) dada anteriormente, \\(E(X)\\) puede interpretarse como el promedio de los valores \\(X\\) en toda la población, por lo que es la media poblacional. Este es claramente uno de los principales valores de resumen para la población. A menudo se denota \\(\\mu\\) y como mide el “centro” de la población también se lo conoce como el parámetro de localización de la población. De forma similar se define la varianza de la población, \\(\\sigma2\\), como: \\[\\begin{equation} \\sigma^2 = V(X) = E\\{(X-\\mu)^2\\} = \\sum_{i=1}^n (x_i - \\mu)^2 p_i \\tag{3.2} \\end{equation}\\] La desviación típica poblacional, \\(\\sigma\\), se obtiene a partir de la raíz cuadrada de la varianza poblacional: \\[\\begin{equation} \\sigma = DT(X) = \\sqrt{V(X)} \\tag{3.3} \\end{equation}\\] Siguiendo con el ejemplo de la variable aleatoria que representa la suma del lanzamiento de dos dados ¿Cuál es el valor esperado de la suma de ambos lanzamientos? ¿Cuál es la desviación típica? En este caso ¿la distribución es aproximada o la distribución poblacional? En el caso de variables aleatorias continuas, donde denotamos por \\(R\\) el rango de todos los valores posibles, se define la media, varianza y desviación típica poblacional como \\[\\begin{equation} \\mu = E(X) = \\int_R x f(x) dx \\tag{3.4} \\end{equation}\\] \\[\\begin{equation} \\sigma^2 = V(X) = \\int_R (x - \\mu)^2 f(x) dx \\tag{3.5} \\end{equation}\\] \\[\\begin{equation} \\sigma = DT(X) = \\sqrt{V(X)} \\tag{3.6} \\end{equation}\\] Para las variables de tipo continuo más habituales la esperanza, varianza y desviación típica poblacionales se aproximan de forma precisa (si la muestra de trabajo es adecuada) por la media, varianza y desviación típica muestral. 3.3 Distribuciones notables En la práctica resultaría complicado y farragoso si para cada experimento aleatorio ligeramente diferente de otro ya realizado, tuviéramos que determinar las distribuciones de probabilidad desde cero. Afortunadamente, podemos hacer uso de las similitudes que existen entre ciertos tipos o familias de experimentos y ciertas distribuciones de probabilidad, conocidas con el nombre de distribuciones notables, que nos permiten el desarrollo de las funciones de distribución que representen las características generales del experimento. Por ejemplo, muchos experimentos comparten el elemento común de que sus resultados se pueden clasificar en uno de dos eventos: una moneda puede salir cara o cruz; un niño puede ser hombre o mujer; una persona puede morir o no morir; una persona puede ser empleada o desempleada. Estos resultados a menudo se etiquetan como “éxito” o “fracaso,” teniendo en cuenta que aquí no hay connotación de “bondad”; por ejemplo, al observar los nacimientos, el estadístico podría calificar el nacimiento de un niño como un “éxito” y la el nacimiento de una niña como un “fracaso,” pero los padres no necesariamente verían las cosas de esa manera. Esta situación experimental se conoce como experimento Bernouilli, asignando probabilidad \\(\\theta\\) al suceso calificado como éxito y probabilidad \\(1-\\theta\\) al suceso calificado como de fracaso. Dichas probabilidades son diferentes para cada situación y se pueden aproximar mediante la obtención de datos experimentales. La distribución de probabilidad que surge en este experimento se conoce como distribución Bernouilli y es la primera distribución de probabilidad notable conocida. 3.3.1 Distribución Binomial A menudo nos interesa el resultado de los ensayos independientes y repetidos de Bernoulli, es decir, el número de éxitos en ensayos repetidos. En esta situación se considera: sucesos independientes: el resultado de un ensayo no afecta el resultado de otro ensayo. repeticiones: las condiciones son las mismas para cada prueba, es decir, la probabilidad de éxito y fracaso permanecen constantes a través de los diferentes ensayos realizados. Una distribución binomial nos da las probabilidades asociadas con los ensayos independientes y repetidos de Bernoulli. En una distribución binomial, las probabilidades de interés son las de observar un cierto número de éxitos, \\(r\\), en \\(n\\) ensayos independientes, cada uno de los cuales tiene solo dos resultados posibles y la misma probabilidad, \\(\\theta\\), de éxito. Por ejemplo, usando una distribución binomial, podemos determinar la probabilidad de obtener 4 caras en 10 lanzamientos de una misma moneda. La distribución de probabilidad para este experimento queda completamente determinado si conocemos \\(n\\) (número de repeticiones realizadas) y \\(\\theta\\) (probabilidad de éxito). Si \\(X\\) denota la variable aleatoria asociada con este experimento, la función de densidad de probabilidad se define como: \\[\\begin{equation} P(X = x) = {n \\choose x} \\theta^x (1-\\theta)^{n-x} \\tag{3.7} \\end{equation}\\] donde \\({n \\choose x}\\) representa el número combinatorio de \\(n\\) sobre \\(x\\), y \\(x\\) el número de éxitos observados. Dicha distribución se denota habitualmente: \\[\\begin{equation} X \\sim Bi(n, \\theta) \\tag{3.8} \\end{equation}\\] Esta distribución se puede evaluar para cualquier valor entre 0 y el número de repeticiones del experimento \\(n\\). En R la función dbinom permite obtener cualquier probabilidad de la distribución binomial una vez fijamos el valor que deseamos evaluar (\\(x\\)), el número de repeticiones (\\(n\\)), y la probabilidad de éxito asociada (\\(\\theta\\)). Una vez establecida la función de densidad de probabilidad resulta posible obtener el valor esperado del número de éxitos, así como conocer su variabilidad haciendo uso de las definiciones expuestas en el tema anterior. En concreto, para una variable que sigue una distribución de probabilidad Binomial ((3.8)) tenemos que: \\[\\begin{equation} E(X) = n \\theta \\tag{3.9} \\end{equation}\\] \\[\\begin{equation} V(X) = n \\theta (1-\\theta) \\tag{3.8} \\end{equation}\\] \\[\\begin{equation} DT(X) = \\sqrt{n \\theta (1-\\theta)} \\tag{3.10} \\end{equation}\\] En la página web http://www.artofstat.com/ se encuentra disponible una aplicación de trabajo de la distribución Binomial (https://istats.shinyapps.io/BinomialDist/). Dicha aplicación nos permite calcular tanto probabilidades como cuantiles para un experimento binomial. Utiliza dicha aplicación para responder a las cuestiones siguientes: En una población de sujetos se conoce que el 39% de ellos sufre algún tipo de mutación genética. Si se obtiene una muestra de 20 sujetos ¿cuál es la probabilidad de observar tres sujetos con esa mutación genética? En una población de moscas de la fruta se conoce que el 30% son de color negro y el 70% son de color gris. Si se extrae una muestra de 15 moscas ¿cuál es la probabilidad de observar al menos cuatro moscas de color negro? ¿y de color gris? Una cierta droga causa daños en el hígado en el 1% de los pacientes. Se van a realizar estudios completos sobre 50 pacientes que están tomando dicha droga para detectar daños en el hígado. ¿Cuál es la probabilidad de que ninguno de lo pacientes muestre daños en el hígado? ¿Cuál es la probabilidad de que al menos uno de los pacientes muestre daños en el hígado? Los estudios realizados concluyen que el 10% de las adolescentes de EEUU tienen deficiencia de hierro. Se obtiene una muestra de 14 adolescentes y se desea conocer ¿cuál es la probabilidad de que al menos el 50% de ellas tengan una deficiencia de hierro? En un experimento se comprobó que la aplicación de un tratamiento químico aumentaba la resistencia a la corrosión de un material en un 80 % de los casos. Si se tratan ocho piezas, determina: (i) probabilidad de que el tratamiento sea efectivo para más de cinco piezas, (ii) probabilidad de que el tratamiento sea efectivo para al menos tres piezas, (iii) número de piezas para las que espera que el tratamiento sea efectivo. Se dispone de un cristal que tiene dos tipos de impurezas que absorben radiación de la misma longitud de onda. Una de ellas emite un electrón tras la absorción de un fotón, mientras que la segunda no emite electrones. Las impurezas están en igual concentración y distribuidas homogéneamente en el cristal. Sin embargo, la sección eficaz de absorción, que es una medida de la probabilidad de absorber un fotón, es 90 veces mayor para la impureza que emite electrones que el de la impureza que no los emite. Suponiendo que sobre el cristal inciden 200 fotones y que este es lo suficientemente grande para absorber todos, calcula la probabilidad de que al menos se emitan tres electrones. 3.3.2 Distribución Poisson La distribución de Poisson se emplea como un modelo para variables aleatorias de tipo discreto cuando se quieren obtener las probabilidades de ocurrencia de un evento que se distribuye al azar en el espacio o el tiempo. Algunos ejemplos de esta distribución son: En el estudio de cierto organismo acuático, se toman un gran número de muestras de un lago y se cuentan el número de organismos que aparecen en cada muestra. El interés principal radica en conocer cuál es la probabilidad de encontrar algún organismo en una muestra próxima si la media observada en el conjunto de nuestras es de 2 organismos. En un estudio sobre la efectividad de un insecticida sobre cierto tipo de insecto, se fumiga una gran región. Posteriormente se crea una cuadrícula sobre el terreno, se selecciona de forma aleatoria un conjunto de ellas, y se cuenta el número de insectos vivos dentro de cada una. Estamos interesados en conocer cuál es la probabilidad de que no encontremos ningún insecto vivo en una cuadrícula próxima si se sabe que que la media de insectos vivos en las cuadriculas analizadas es de 0.5. Un grupo de investigadores observó la ocurrencia de hemangioma capilar retiniano (RCH) en pacientes con la enfermedad de von Hippel-Lindau (VHL). RCH es un tumor vascular benigno de la retina. Usando una revisión retrospectiva de series de casos consecutivos, los investigadores encontraron que el número de medio de tumores RCH por ojo para pacientes con VHL era de 4. Están interesados en conocer cuál es la probabilidad de que se detecten más de cuatro tumores por ojo. Como se puede ver en los ejemplos la distribución de Poisson es muy habitual en los campos de la biología y la medicina. En una distribución de Poisson, las probabilidades de interés son las de observar un número de eventos, \\(x\\), en un tiempo o espacio determinado. La distribución de probabilidad para este experimento queda completamente determinada si conocemos el número de eventos y \\(\\lambda\\) la tasa o media del número de eventos que ocurren por unidad de tiempo o espacio. Si \\(X\\) denota la variable aleatoria asociada con este experimento, la función de densidad de probabilidad se define como: \\[\\begin{equation} P(X = x) = \\frac{e^{-\\lambda} \\lambda^x}{x!} \\tag{3.11} \\end{equation}\\] Dicha distribución se denota habitualmente: \\[ X \\sim Po(\\lambda)\\]. Esta distribución se puede evaluar para cualquier valor entre 0 y el número de máximo de ocurrencias que pueden ocurrir. Dado que este valor no se conoce de antemano se debe prefijar un valor máximo que asegure que la probabilidad de ese valor sea cero. En R la función dpois permite obtener cualquier probabilidad de la distribución de Poisson una vez fijamos el valor que deseamos evaluar (\\(x\\)), y la tasa o media del número de eventos (\\(\\lambda\\)). Una vez establecida la función de densidad de probabilidad resulta posible obtener el valor esperado del número de eventos ocurridos, así como conocer su variabilidad haciendo uso de las definiciones expuestas en el tema anterior. En concreto, para una variable que sigue una distribución de probabilidad Poisson (\\(X \\sim Po(\\lambda)\\)) tenemos que: \\[\\begin{equation} E(X) = \\lambda \\tag{3.12} \\end{equation}\\] \\[\\begin{equation} V(X) = \\lambda \\tag{3.13} \\end{equation}\\] \\[\\begin{equation} DT(X) = \\sqrt{\\lambda} \\tag{3.14} \\end{equation}\\] En la página web http://www.artofstat.com/ se encuentra disponible una aplicación de trabajo de la distribución Binomial (https://istats.shinyapps.io/PoissonDist/). Dicha aplicación nos permite calcular tanto probabilidades como cuantiles para un experimento poisson Utiliza dicha aplicación para responder a las cuestiones siguientes: (Hint: Recuerda que la tasa de la poisson se debe modificar si las cuestiones de interés no están referenciadas a la misma escala que la escala proporcionada). Un laboratorio es capaz de realizar 20 análisis de cierto tipo en un hora. ¿Cuál es la probabilidad de realizar entre 30 y 36 análisis en las próximas dos horas?¿y la probabilidad de realizar más de 36? (Hint: En este caso no concemos directamente la media de la poisson ya que la escala medida no es la misma sobre la que se este interesado, por lo que es necesario ajustar la tasa a cada pregunta) Consideremos que el número de trozos de chocolate en una determinada galleta sigue una distribución de Poisson. Queremos que la probabilidad de que una galleta seleccionada al azar tenga por lo menos tres trozos de chocolate sea mayor que 0.8. Encontrar el valor entero más pequeño de la media de la distribución que asegura esta probabilidad. Un fabricante de maquinaria pesada tiene instalados en el campo 3840 generadores de gran tamaño con garantía. Sí la probabilidad de que cualquiera de ellos falle durante el año dado es de 1/1200 determine la probabilidad de que a) 4 generadores fallen durante el año en cuestión, b) que más 1 de un generador falle durante el año en cuestión. En un proceso de manufactura, en el cual se producen piezas de vidrio, ocurren defectos o burbujas, ocasionando que la pieza sea indeseable para la venta. Se sabe que en promedio 1 de cada 1000 piezas tiene una o más burbujas. ¿Cuál es la probabilidad de que en una muestra aleatoria de 8000 piezas, menos de 3 de ellas tengan burbujas? Se sabe que el número de microorganismos por gramo de una cierta muestra de suelo diluida en agua destilada se distribuye según una variable aleatoria de media 0.08. Si una preparación con un gramo de esta disolución se vuelve turbia, este gramo contiene al menos un microorganismo. Hallar la probabilidad de que una preparación que se ha vuelto turbia contenga: Un solo microorganismo Menos de tres microorganismos Más de dos microorganismos En un monte, el número de plantas de romero por círculo de un metro de radio, se distribuye según una variable aleatoria. Se eligen 1o plantas al azar y se mide la distancia a la planta que tiene más próxima. Las distancias observadas fueron (medidas en metros): 0.7, 1.7, 1.2, 0.4, 0.2, 0.5, 0.7, 0.8, 1.5, y 2.1. A partir de estos datos estima los parámetros de interés de la distribución y calcula cuantas plantas es de esperar que habrá en una zona del monte de unos 12500 m2 de superficie. 3.3.3 Distribución Normal Hasta ahora todas las distribuciones consideradas eran de tipo de discreto. En este punto tratamos la distribución de probabilidad de tipo continuo y más concreta mente la más famosa y utilizada de todas ellas: la distribución de probabilidad Normal. Una variable de tipo continuo es aquella que puede tomar cualquier valor dentro de un rango de valores, es decir, existe un infinito número de valores posibles para la variable aleatoria. Para representar gráficamente una distribución de una variable aleatoria continua se debe construir un subconjunto de clases o intervalos consecutivos para el rango de valores de la variable considerada y considerar el histograma resultante. Cuando consideramos un número muy grande de clases o intervalos podríamos obtener la curva suavizada que representa la función de densidad de probabilidad de la variable aleatoria. La función de densidad de probabilidad para una variable aleatoria \\(X\\) que sigue una distribución Normal con parámetros \\(\\mu\\) y \\(\\sigma\\), denotada por \\(N(\\mu, \\sigma^2)\\) viene dada por: \\[\\begin{equation} f(x) = \\frac{1}{2\\pi\\sigma^2} exp\\left(-\\frac{(x - \\mu)^2}{2\\sigma^2}\\right) \\tag{3.15} \\end{equation}\\] Los dos parámetros de la distribución son \\(\\mu\\) que representa la medida de localización y \\(\\sigma\\) la medida de dispersión. Habitualmente los conocemos por sus nombres más habituales como son la media y la desviación típica. En concreto, para una variable que sigue una distribución de probabilidad Normal (\\(X \\sim N(\\mu, \\sigma^2)\\)) tenemos que: \\[\\begin{equation} E(X) = \\mu \\tag{3.16} \\end{equation}\\] \\[\\begin{equation} V(X) = \\sigma^2 \\tag{3.17} \\end{equation}\\] \\[\\begin{equation} DT(X) = \\sigma \\tag{3.18} \\end{equation}\\] Las características más importantes de la distribución Normal: Es una distribución simétrica alrededor de la media, \\(\\mu\\). La media, la mediana y la moda son iguales. La distribución Normal queda completamente especificada a partir de los valores de \\(\\mu\\) y \\(\\sigma\\). Los diferentes valores de la media y la desviación típica desplazan hacia un lado o el otro, o consiguen una distribución más puntiaguda (desviaciones típicas más pequeñas) o más achatada (desviaciones típicas más grandes). El intervalo definido por \\(\\mu - 5 * \\sigma, \\mu + 5 * \\sigma\\) tiene probabilidad 1, es decir, la probabilidad de los extremos inferior y superior del rango de valores se puede considerar despreciable. Dada una variable aleatoria Normal con media \\(\\mu\\) y desviación típica \\(\\sigma\\) y tenemos un escalar \\(a\\) tenemos que: \\[ X \\sim N(\\mu, \\sigma^2) \\Longrightarrow aX \\sim N(a\\mu, a^2\\sigma^2)\\] * Dada dos variables aleatorias Normales, \\(X e Y\\), con medias y desviaciones típicas respectivas: \\(\\mu_1\\), \\(\\sigma_1\\) y \\(\\mu_2\\), \\(\\sigma_2\\) y dos escalares \\(a\\) y \\(b\\) tenemos que \\[ X \\sim N(\\mu_1, \\sigma^2_1), Y \\sim N(\\mu_2, \\sigma^2_2) \\Longrightarrow aX + bY\\sim N(a\\mu_1+b\\mu_2, a^2\\sigma^2_1+b^2\\sigma^2_2)\\] Esta última propiedad se puede generalizar para el caso de \\(m\\) variables aleatorias en lugar de 2. 3.3.3.1 Teorema Central de Límite Si las variables aleatorias \\(X_1,...X_n\\) son una muestra aleatoria de una distribución con media \\(\\mu\\) y desviación típica \\(\\sigma\\) entonces las variables aleatorias suma (\\(T = X_1+...+X_n\\)) y media (\\(M = (X_1+...+X_n)/n\\)) tienen distribuciones: \\[ T \\sim N\\left(n\\mu,n\\sigma^2\\right)\\] \\[ M \\sim N\\left(\\mu,\\frac{\\sigma^2}{n}\\right)\\] En la página web http://www.artofstat.com/ se encuentra disponible una aplicación de trabajo de la distribución Binomial (https://istats.shinyapps.io/NormalDist/). Dicha aplicación nos permite calcular tanto probabilidades como cuantiles para un experimento normal Utiliza dicha aplicación para responder a las cuestiones siguientes: La longitud L (en micras) de ciertas larvas parásitas de moluscos, sigue la distribución Normal, pero de media y desviación típica distinats, según la larva se encuentre en estadio 1 o en estadio 2 de su crecimiento. La media y la desviación típica son: 219 y 20 para el estadio 1, y 241 y 14 para el estadio 2. Para identificar el estadio en que se encuentra la larva, se adopta el criterio siguiente: Si L≤230 pertenece al estadio 1, en otro caso pertenece al estadio 2. Resolver las siguientes cuestiones: Calcular la probabilidad de la presencia del suceso L≤230 para larvas del estadio 1. Idem. para larvas en el esatdio 2. Desde que nace una larva hasta que llega al estadio 3 de su desarrollo (que es fácilmente identificable), trasncurren 12 horas, permaneciendo 8 horas en el estadio 1 y 4 horas en el estadio 2. La observación de una larva cualquiera se hace en un instante que puede considerarse elegido al azar durante estas 12 horas (se desconoce cuando ha nacido la larva). Entonces, si se ha observado que una larva mide L = 225 y, por lo tanto, se considera que pertenece al estadio 1, calcular la probabilidad de equivocarnos al tomar esta decisión. Supongamos que el diámetro de las aceitunas rellenas de anchoa varía entre 15 y 17 mm. Debido a al sequía del último año, la producción de aceituna verde se ha distribuido según una normal de media 15.5 mm. y desviación típica 1.2 mm. ¿Qué porcentaje de aceitunas podría ser aprovechado para rellenar de anchoa? La duración media de un lavavajillas es de 15 años y su desviación típica 0.5. Sabiendo que la vida útil del lavavajillas se distribuye normalmente, hallar la probabilidad de que al adquirir un lavavajillas, este dure más de 15 años. Una normativa europea obliga a que en los envases de yogur no debe haber menos de 120 gr. La máquina dosificadora de una empresa láctea hace los envases de yogur según una distribución normal de desviación típica de 2 gr. y media 122 gr. ¿Qué tanto por ciento de los envases de yogur de esa empresa cumplirá la normativa? ¿Cuál deberá ser la media de la distribución normal con la cual la máquina dosificadora debe hacer los envases para que el 98% de la producción de yogures de la empresa cumpla la normativa?. (La desviación típica sigue siendo de 2 gr.). 3.3.4 Otras distribuciones A partir de la distribución de probabilidad Normal se pueden obtener otras distribuciones de probabilidad que resultan de gran utilidad para los procesos de generalización de resultados de un diseño experimental a una población que veremos en la unidad siguiente. 3.3.4.1 Distribución Chi-cuadrado Sean n variables aleatorias \\(X_1,...,X_n\\) independientes entre sí cuya distribución de probabilidad es idéntica para todas ellas e igual a una Normal estándar (\\(N(0,1)\\)). Si definimos la variable aleatoria suma como: \\[X = X_1 + ... + X_n,\\] entonces decimos que \\(X\\) se distribuye según una distribución Chi-cuadrado con \\(n\\) grados de libertad y la denotamos por \\[X \\sim \\chi^2_n.\\] 3.3.4.2 T se Student Si tenemos dos variables aleatorias independientes \\(Y\\) y \\(Z\\) con distribuciones de probabilidad \\[Z \\sim N(0,1); Y \\sim \\chi^2_n,\\] y consideramos la variable aleatoria \\(X\\) dada por: \\[X = \\frac{Z}{\\sqrt{Y/n}},\\] entonces decimos que dicha variable sigue una distribución \\(t\\) de Student con \\(n\\) grados de libertad, y se denota por \\[X \\sim t_n.\\] 3.3.4.3 F de Snedecor Si tenemos dos variables aleatorias independientes \\(Y\\) y \\(Z\\) con distribuciones de probabilidad \\[Z \\sim \\chi^2_n; Y \\sim \\chi^2_m,\\] y consideramos la variable aleatoria \\(X\\) dada por: \\[X = \\frac{Z/n}{Y/m},\\] entonces decimos que dicha variable sigue una distribución \\(F\\) de Snedecor con \\(n\\) y \\(m\\) grados de libertad, y se denota por \\[X \\sim F_{n,m}.\\] "],["inferencia-básica.html", "Unidad 4 Inferencia básica 4.1 Estimador y estimación 4.2 Información contenida en la muestra 4.3 Procedimientos de inferencia estadística 4.4 Inferencia para dos poblaciones 4.5 Inferencia para dos proporciones 4.6 Inferencia para dos medias 4.7 Procedimientos no paramétricos", " Unidad 4 Inferencia básica En la unidad anterior se han expuesto brevemente la teoría y los métodos de la probabilidad. En este unidad se expondrán la teoría y los métodos de la inferencia estadística que servirán como base para los modelos estadísticos que estudiaremos en la unidad siguiente. Un problema de inferencia estadística es un problema en el cual se han de analizar datos que han sido generados de acuerdo con una distribución de probabilidad desconocida y en la que se debe realizar algún tipo de inferencia (“conocer su comportamiento”) acerca de tal distribución. En la mayoría de situaciones reales, existe un número infinito de distribuciones posibles distintas que podrían haber generado los datos. En la práctica, dado el tipo de variable aleatoria considerada, se suele asumir un modelo de distribución de probabilidad que es completamente conocida salvo excepto por los valores de los parámetros que la especifican completamente. Utilizamos los datos de la muestra para obtener información sobre dichos parámetros desconocidos y poder asumir de esta forma una distribución de probabilidad completa para todos los datos de la población. Por ejemplo, se podría saber que la duración de cierto tipo de marcapasos tiene una distribución exponencial con parámetro \\(\\lambda\\) pero desconocer el valor exacto de dicho parámetro. Si se puede observar la duración de varios marcapasos de este tipo, entonces, a partir de estos valores observados y de cualquier otra información relevante de la que se pudiera disponer, es posible producir una inferencia acerca de ese valor desconocido \\(\\lambda\\). Podría interesar producir la mejor estimación del valor de dicho parámetro o especificar un intervalo en el cual se piensa que pueda estar incluido el verdadero valor de \\(\\lambda\\), o decidir si dicho parámetro es menor que un valor específico, ya que en ningún caso es posible obtener el verdadero valor de \\(\\lambda\\) ya que sería necesario obtener la información de todos los sujetos de la población y no sólo los de la muestra. En un problema de inferencia estadística, cualquier característica de la distribución que genera los datos experimentales que tenga un valor desconocido, como \\(\\lambda\\) en el ejemplo anterior, se llama parámetro de la distribución. El conjunto \\(\\Omega\\) de todos los valores posibles de dicho parámetro se llama espacio parámetrico. Cuando nuestra distribución de probabilidad tiene dos parámetros (por ejemplo la distribución Normal) el espacio paramétrico vendrá dado por todo el conjunto de parejas de valores de \\(\\mu\\) y \\(\\sigma^2\\). 4.1 Estimador y estimación Si tenemos una variable aleatoria \\(X\\) cuya función de distribución viene caracterizada por un parámetro o conjunto de parámetros \\(\\delta\\), y una muestra aleatoria de tamaño \\(n\\), \\(X_1,...,X_n\\), a partir de la cual se observan el conjunto de datos muestrales \\(x_1,...,x_n\\) vamos a definir dos conceptos relevantes en todo proceso de inferencia: estimador y estimación. Un estimador del parámetro \\(\\delta\\), basado en las variables aleatorias \\(X_1,...,X_n\\), es una función \\(\\delta(X_1,...,X_n)\\) que especifica una valor para \\(\\delta\\). Se trata de una función matemática que tiene la misma forma independientemente de la muestra utilizada. Por ejemplo, los estimadores para la media, varianza (y cuasivarainza), y proporción poblacionales vienen dados por: Media muestral \\[\\delta_1(X_1,...,X_n) = \\bar{X} = \\frac{X_1+X_2+...+X_n}{n}\\] Varianza muestral \\[\\delta_2(X_1,...,X_n) = S^2 = \\frac{\\sum_{i=1}^n (X_i-\\bar{X})^2}{n}\\] Cuasi-Varianza muestral \\[\\delta_3(X_1,...,X_n) = S_q^2 = \\frac{n}{n-1} S^2\\] Para una variable de tipo discreto se aplican las mismas definiciones si consideramos cada \\(X_i\\) como una realización de dicha variable. Para una variable que mide “éxito” o “fracaso” los valores de \\(X_i\\) serán 1 o 0 respectivamente, de forma que la media muestral coincide con la proporción muestral ya que tendríamos la suma de 1 en el numerador dividido por el tamaño de muestra en el denominador. Una estimación es el valor numérico del estimador para unos datos dados (\\(x_1,...,x_n\\)), es decir, sustituimos en \\(\\delta(X_1,...,X_n)\\) por sus valores observados y obtendríamos la estimación del parámetro. De forma habitual se identifica con el “gorro” encima del parámetro indica la estimación de un parámetro: \\[\\hat{\\mu} = \\delta_1(x_1,...,x_n) =\\bar{x}\\] \\[\\hat{\\sigma}^2 = \\delta_2(x_1,...,x_n)= s^2\\] 4.2 Información contenida en la muestra Antes de comenzar a describir los procesos de inferencia estadística es necesario conocer como podemos relacionar la información contenida en una muestra con la distribución de probabilidad de la variable aleatoria de interés. Para ello una vez fijada la población del estudio y el objetivo principal es necesario: Establecer la variable de interés, \\(X\\) (y su tipo), en función del objetivo principal Establecer una distribución de probabilidad para la variable aleatoria, \\(f(X | \\theta)\\), acorde con el tipo de dicha variable y lo más sencilla posible, donde \\(\\theta\\) representa el parámetro o parámetros que especifican dicha distribución. Muestra aleatoria de tamaño \\(n\\) de la variable de interés, \\(X_1, X_2,...,X_n\\) de forma que cada observación tiene probabilidad \\(f(X_1 | \\theta), f(X_2 | \\theta),...,f(X_n | \\theta)\\) respectivamente y sus valores observados vienen dados por \\(x_1,...,x_n\\). Obtener los descriptivos muestrales habituales: media, varianza, desviación típica, o proporción. Se define entonces la función de verosimilitud \\(L(X|\\theta)\\) como: \\[L(X|\\theta) = \\prod_{i=1}^n f(X_i|\\theta) = f(X_1|\\theta)f(X_2|\\theta)\\cdots f(X_n|\\theta)\\] La función de verosimilitud contiene toda la información sobre la muestra y la relaciona con el parámetro o parámetros de interés a través de la distribución de probabilidad establecida. Se convierte por tanto en la herramienta más importante, desde el punto de vista de la estadística frecuentista, para los procesos de inferencia estadística que estudiaremos a continuación. Además, se utiliza como base para la caracterización de la distribución en el muestreo de los diferentes estimadores, aproximaciones numéricas del verdadero valor del parámetro o parámetros de la distribución de probabilidad asumida, que se utilizan en los procesos inferenciales. Para evitar la complejidad matemática que supone trabajar con productos se suele definir el logaritmo de la función de verosimilitud, log-verosimilitud, \\(LL(X|\\theta)\\) como: \\[LL(X|\\theta) = log\\left(\\prod_{i=1}^n f(X_i|\\theta)\\right) = \\sum_{i=1}^n log(f(X_i|\\theta)) = log(f(X_1|\\theta))+log(f(X_2|\\theta))+\\cdots +log(f(X_n|\\theta))\\] 4.3 Procedimientos de inferencia estadística Estudiamos en este punto los distintos procedimientos de inferencia que tratamos en esta unidad. Realizamos una pequeña introducción de cada uno de ellos y ejemplificaremos su uso en el análisis de una población. 4.3.1 Estimación puntual Es el procedimiento de inferencia estadística más sencillo y consiste en obtener un único valor aproximado del parámetro de interés a partir de un estimador de dicho parámetro y de los datos observados de una muestra. Aunque en las situaciones más sencillas (media, varianza y proporción) tanto el estimador como la estimación son fáciles de obtener, hay que establecer un procedimiento general para obtener dichas estimaciones. Dicho procedimiento consiste en encontrar el máximo de la función de verosimilitud (o más concretamente de la log-verosimilitud) para el parámetro o parámetros involucrados en dicha función, es decir, el valor o valores que se obtienen al igualar a cero la derivada de la función de log-verosimilitud: \\[\\frac{d}{d\\theta} LL(X | \\theta) = 0\\] 4.3.1.1 Estimador de una proporción La estimación de proporciones surge de forma natural en poblaciones Bernouilli cuya función de log-verosimilitud viene dada por: \\[LL(X |\\theta) = s*log(\\theta) + (n-s)*log(1-\\theta)\\] Derivando e igualando a cero: \\[\\frac{d}{d\\theta} LL(X | \\theta) = \\frac{s}{\\theta}+\\frac{-(n-s)}{1-\\theta} = 0\\] Despejando obtenemos: \\[\\hat{\\theta} = \\frac{s}{n}\\] que es el estimador habitual para obtener la proporción muestral. 4.3.1.2 Estimador de una media Si asumimos que la variable aleatoria es \\(N(\\mu,\\sigma^2)\\) la función de log verosimilitud viene dada por: \\[LL(X |\\mu,\\sigma^2) = -\\frac{n}{2}*log(2\\pi\\sigma^2)+\\frac{nS^2 + n(\\mu-\\bar{X})^2}{2\\sigma^2}\\] Si derivamos respecto de \\(\\mu\\) e igualamos a cero: \\[\\frac{d}{d\\mu}LL(X |\\mu,\\sigma^2) = -\\frac{2n(\\mu-\\bar{X})}{2\\sigma^2} = 0\\] Despejando obtenemos el estimador para la media: \\[\\hat\\mu = \\bar X\\] 4.3.1.3 Estimador de una varianza De forma similar, derivando respecto de \\(\\sigma^2\\) e igualando a cero la función de log-verosimilitud tenemos que el estimador para la varianza viene dado por: \\[\\hat \\sigma^2 = S^2\\] Podemos ver que en las situaciones habituales los estimadores de los parámetros poblacionales coinciden con las funciones que nos permiten obtener las medidas de localización y dispersión muestrales. El problema con la estimación puntual es que únicamente nos da un valor posible para el parámetro poblacional pero sin ninguna medida del posible error que estamos cometiendo, dado que la estimación obtenida depende de la muestra seleccionada. Dos muestras distintas podrían dar dos estimaciones distintas y por tanto dos valores para el parámetro poblacional. Para introducir una medida del error cometido con la muestra seleccionada se utiliza los procedimiento de inferencia basados en intervalos de confianza, pero antes de pasar con ellos es necesario describir un poco más el comportamiento aleatorio de los estimadores que acabamos de obtener. 4.3.2 Distribución en el muestreo Dado que todos los estimadores se construyen a partir de una colección de realizaciones aleatorias \\(X_1,...X_n\\) de la variable aleatoria \\(X\\), resulta que dicho estimador es una nueva variable aleatoria (que toma valores según los datos observados de la muestra) y por tanto su distribución puede ser deducida a partir de las distribuciones de cada una de las \\(X_i\\), utilizando la función de verosimilitud. En algunos casos (variables discretas) será necesario utilizar el Teorema Central del Límite para determinar una forma aproximada de dicha distribución de probabilidad que nos permita realizar los procesos inferenciales sin demasiada complejidad matemática. La distribución de los estimadores se conoce con el nombre de distribución en el muestreo En este punto siguiente se muestran las distribuciones en el muestro para los estimadores obtenidos en este apartado. Se eliminan todos los desarrollos matemáticos y simplemente se muestran las distribuciones obtenidas. 4.3.2.1 Distribución en el muestreo de una media poblacional con varianza poblacional conocida Tenemos una población de \\(N\\) sujetos sobre la que se desea estudiar una variable aleatoria de tipo continuo (\\(X\\)) que sigue una distribución \\(N(\\mu,\\sigma^2)\\) y cuyo parámetro de interés es la media (\\(\\mu\\)) pero donde conocemos el valor de \\(\\sigma^2\\). Por la aplicación directa del Teorema Central del Límite la distribución en el muestreo de \\(\\bar X\\) viene dada por: \\[\\bar X \\sim N\\left(\\mu,\\frac{\\sigma^2}{n}\\right)\\] y por tanto la variable tipificada tiene distribución Normal estándar, es decir: \\[\\frac{\\bar X - \\mu}{\\sigma/\\sqrt n} \\sim N(0,1)\\] 4.3.2.2 Distribución en el muestreo de una media poblacional con varianza poblacional desconocida Cuando la varianza es desconocida también se puede obtener la distribución en el muestreo de la media muestral sin más que sustituir la varianza poblacional por un estimador. Tipificando tenemos que: \\[T = \\frac{\\bar{X} - \\mu}{S/\\sqrt{n-1}} = \\frac{\\bar{X} - \\mu}{S_q/\\sqrt{n}}\\] se distribuye según una distribución \\(t\\) de Student con \\(n-1\\) grados de libertad, \\[ T \\sim t_{n-1}\\] 4.3.2.3 Distribución en el muestreo de una varianza poblacional En la situación poblacional anterior la distribución en el muestreo de la varianza si consideramos la variable aleatoria: \\[\\chi^2 = \\frac{nS^2}{\\sigma^2} = \\frac{(n-1)S_q^2}{\\sigma^2}\\] que se distribuye según una distribución Chi cuadrado con \\(n-1\\) grados de libertad, \\[ \\chi^2 \\sim \\chi^2_{n-1}\\] La obtención de esta distribución se hace a partir de la forma de la función de verosimilitud para una población Normal con ambos parámetros desconocidos. 4.3.2.4 Distribución en el muestreo de una proporción poblacional Tenemos una población de \\(N\\) sujetos sobre la que se desea estudiar una variable aleatoria de tipo discreto (\\(X\\)) cuyo parámetro de interés es la proporción de sujetos (\\(\\theta\\)) que cumplen con cierta condición. En esta situación si obtenemos una muestra de tamaño \\(n\\) de dicha variable \\(X_1,...,X_n\\) (donde cada uno de ellos toma el valor 1 si cumple con la condición y = si no cumple), la proporción de éxito muestral (\\(\\hat{\\theta}\\)) viene dada por: \\[\\hat{\\theta} = \\frac{\\sum_{i=1}^n X_i}{n}\\] En esta situación la distribución en el muestreo para \\(\\hat{\\theta}\\), cuando \\(n\\) es grande (\\(n \\geq 30\\)), viene dada por: \\[\\hat{\\theta} \\sim N \\left(\\theta, \\frac{\\theta (1-\\theta)}{n}\\right) \\] de forma que la variable aleatoria tipificada \\(Z\\) cumple que: \\[Z = \\frac{\\hat{\\theta}-\\theta}{\\sqrt{\\frac{\\theta (1-\\theta)}{n}}} \\sim N(0,1)\\] La obtención de dichas distribuciones en el muestreo nos permite realizar cálculos de probabilidades sobre dichas cantidades aleatorias, con lo que resulta posible conocer cuál es la probabilidad de que la media muestral supere cierto valor, y por tanto, podamos tener una mayor certeza del verdadero valor del parámetro poblacional. 4.3.2.5 Error estándar Para cuantificar la bondad de la estimación obtenida se define el error estándar (\\(es()\\)) como la desviación típica de la distribución en el muestreo del estimador. De esta forma: Error estándar de la media en una población Normal con varianza conocida \\[es(\\bar X) = \\frac{\\sigma}{\\sqrt n}\\] Error estándar de la media en una población Normal con varianza desconocida \\[es(\\bar X) = \\frac{S}{\\sqrt{n-1}}\\] Error estándar de una proporción en una población Bernouilli \\[es(\\hat{\\theta}) = \\sqrt{\\frac{\\hat{\\theta} (1-\\hat{\\theta}))}{n}}\\] 4.3.3 Estimación por intervalos de confianza Un intervalo de confianza al nivel \\(100*(1 - \\alpha)\\%\\) representa la confianza que tenemos en que el verdadero valor del parámetro de la población se encuentre contenido entre los limites de dicho intervalo, que se construye a partir de la información muestral y la distribución en el muestreo del estimador. Si tenemos un intervalo de confianza al 95%, es decir \\(\\alpha = 0.05\\), lo que estamos indicando es que si obtuviéramos 100 muestras y calculáramos los 100 intervalos asociados, solo en 95 de ellos contendrían al verdadero valor del parámetro poblacional. Dado que habitualmente tomamos una única muestra debemos confiar en que el intervalo producido sea uno de los 95 que contiene al verdadero valor del parámetro poblacional. El valor de \\(\\alpha\\) se conoce como significatividad. Supongamos que tenemos una población sobre la deseamos estudiar una variable aleatoria \\(X\\) cuya función de distribución es conocida y viene caracterizada por el parámetro \\(\\theta\\), \\(f(X|\\theta)\\). Vamos a obtener una muestra de tamaño \\(n\\), \\(X_1,...,X_n\\) y consideramos el estimador \\(\\hat\\theta\\) de \\(\\theta\\) del que conocemos su distribución en el muestreo, \\(f_n\\),y podemos especificar su error estándar, \\(es(\\hat{\\theta})\\). Si fijamos el valor de \\(\\alpha\\) el intervalo de confianza para el parámetro poblacional viene dado por la expresión: \\[IC_{1-\\alpha}(\\theta) = (\\hat{\\theta} - q_{\\alpha/2}*es(\\hat{\\theta}),\\hat{\\theta} + q_{1-\\alpha/2}*es(\\hat{\\theta}))\\] donde \\(q_{\\alpha/2}\\) y \\(q_{1-\\alpha/2}\\) son los cuantiles \\(\\alpha/2\\) y \\(1-\\alpha/2\\) de la distribución en el muestreo, es decir, \\[P(\\hat{\\theta} \\leq q_{\\alpha/2}) = \\alpha/2\\] \\[P(\\hat{\\theta} \\leq q_{1-\\alpha/2}) = 1-\\alpha/2\\] Si la distribución en el muestreo es simétrica \\(q_{1-\\alpha/2} = - q_{\\alpha/2}\\) Antes de estudiar la forma explicita de los intervalos de confianza para una proporción, una media, y una varianza vamos a ver una herramienta de simulación que nos permite comprobar el funcionamiento de dichos intervalos. El funcionamiento de la aplicación es: Fijar valor del parámetro poblacional Fijar el tamaño de la muestra Establecer el límite de confianza Establecer el número de muestras de trabajo y simularlas representando los intervalos de confianza obtenidos. Podemos ver entonces cuantos de esos intervalos contienen al verdadero valor del parámetro. Acceder a la aplicación 4.3.3.1 IC para una proporción El intervalo de confianza al nivel \\(100*(1 - \\alpha)\\%\\) para una proporción poblacional viene dado por: \\[IC_{1-\\alpha}(\\theta) = \\left(\\hat{\\theta} - q_{1-\\alpha/2}*\\sqrt{\\frac{\\hat{\\theta} (1-\\hat{\\theta}))}{n}},\\hat{\\theta} + q_{1-\\alpha/2}*\\sqrt{\\frac{\\hat{\\theta} (1-\\hat{\\theta}))}{n}}\\right)\\] donde \\(q_{1-\\alpha/2}\\) es el cuantil \\(1-\\alpha/2\\) de una distribución Normal estándar, \\(\\hat{\\theta}\\) es la proporción muestral y \\(n\\) es el tamaño muestral. 4.3.3.2 IC para la media El intervalo de confianza al nivel \\(100*(1 - \\alpha)\\%\\) para la media de una población Normal con varianza desconocida viene dado por: \\[IC_{1-\\alpha}(\\mu) = \\left(\\bar{x} - q_{1-\\alpha/2}*\\frac{s}{\\sqrt{n-1}},\\bar{x} + q_{1-\\alpha/2}*\\frac{s}{\\sqrt{n-1}}\\right)\\] donde \\(q_{1-\\alpha/2}\\) es el cuantil \\(1-\\alpha/2\\) de una distribución \\(t\\) se Student con \\(n-1\\) grados de libertad, \\(\\bar x\\) es la media muestral, \\(s\\) es la desviación típica muestral, y \\(n\\) es el tamaño de muestra. 4.3.3.3 Intervalo de confianza para la varianza El intervalo de confianza al nivel \\(100*(1 - \\alpha)\\%\\) para la varianza de una población Normal viene dado por: \\[IC_{1-\\alpha}(\\sigma^2) = \\left(\\frac{(n-1)s^2}{q_{1-\\alpha/2}}, \\frac{(n-1)s^2}{q_{\\alpha/2}}\\right)\\] donde \\(q_{1-\\alpha/2}\\) y \\(q_{\\alpha/2}\\) son los cuantiles \\(1-\\alpha/2\\) y \\(\\alpha/2\\) de una distribución \\(Chi^2\\) con \\(n-1\\) grados de libertad, \\(s^2\\) es la varianza muestral, y \\(n\\) es el tamaño de muestra. 4.3.4 Contraste de hipótesis Un procedimiento de contraste de hipótesis tiene por objetivo valorar la evidencia proporcionada por los datos a favor de alguna hipótesis planteada sobre el parámetro o parámetros que identifican a la población bajo estudio. En el caso más sencillo, imaginemos que tenemos un parámetro poblacional \\(\\theta\\) que puede tomar valores en el conjunto \\(\\Theta\\) Ejemplo: Estamos interesados en conocer si la proporción de alumnos que superan la asignatura de Estadística en la convocatoria de junio es mayor o igual al 50%. El parámetro de interés, \\(\\theta\\), es entonces la proporción de aprobados en la convocatoria de junio, y el conjunto de posibles valores de dicho parámetro puede tomar valores entre 0 y 100. El contraste de interés viene dado por: \\[\\theta \\geq 0.5\\] Para resolver cualquier procedimiento de contraste debemos establecer dos subconjuntos disjuntos del espacio paramétrico, \\(\\Theta_0\\) y \\(\\Theta_1\\) cumpliendo que \\(\\Theta = \\Theta_0 \\cup \\Theta_1\\), con los posibles valores del parámetro de interés que denominamos hipótesis: Hipótesis nula, que se denota por \\(H_0\\), y que generalmente expresa el valor o conjunto de valores del parámetro,\\(\\Theta_0\\), que corresponde con la idea que deseamos verificar. Hipótesis alternativa, que se denota por \\(H_a\\), y que generalmente expresa el valor o conjunto de valores complementarios, \\(\\Theta_1\\), a los dados en la hipótesis nula. Formalmente, el problema de contraste de hipótesis se plantea como: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta \\in \\Theta_0\\\\ H_a: &amp; \\theta \\in \\Theta_1\\end{array}\\right.\\] Estas hipótesis se deben establecer antes de obtener la información muestral ya que deben reflejar conocimiento previo sobre el parámetro poblacional de interés. La muestra recogida aportará las evidencias suficientes para rechazar o no rechazar la hipótesis nula planteada. En nuestro ejemplo \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta \\geq 0.5\\\\ H_a: &amp; \\theta &lt; 0.5\\end{array}\\right.\\] 4.3.4.1 Posibles contrastes Dada la estructura del procedimiento de contraste se plantean únicamente dos tipos de posibilidades: Contraste bilateral: El conjunto de posibles valores del parámetro de interés establecidos en la hipótesis nula se concentra en un único valor, \\(\\theta_0\\), es decir, \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta = \\theta_0\\\\ H_a: &amp; \\text{ no } \\theta_0 \\end{array}\\right.\\] Contraste unilateral: El conjunto de posibles valores del parámetro de interés establecidos en la hipótesis nula se concentra en un conjunto de valores dado por una desigualdad con respecto a \\(\\theta_0\\), es decir, \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta \\geq \\theta_0\\\\ H_a: &amp; \\text{ no } \\theta_0 \\end{array}\\right.\\] \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta \\leq \\theta_0\\\\ H_a: &amp; \\text{ no } \\theta_0 \\end{array}\\right.\\] 4.3.4.2 Resolución de contraste Para establecer evidencias a favor de una hipótesis u otra se debe: Elegir un nivel de significación, \\(\\alpha\\), que refleja el riesgo que tomamos cuando rechazamos la hipótesis nula o probabilidad de rechazar la hipótesis nula cuando es cierta, es decir: \\[\\alpha = P(\\text{ Rechazar } H_0 | H_0 \\text{ cierta})\\] Normalmente se eligen valores pequeños, \\(\\alpha=0,1, 0.05, y 0.01\\) que resultan los equivalentes del 90%, 95%, y 99% al nivel de confianza en el proceso de estimación. Ejemplo. Si tomamos una significación del 5%, tendremos una probabilidad de 0.05 de rechazar la hipótesis nula cuando en realidad es cierta. Establecer estadístico de contraste (\\(EC\\)) que nos permita, utilizando la información muestral, estudiar la compatibilidad de dicha información con la hipótesis nula planteada. La forma habitual suele ser: \\[EC = \\frac{\\theta - \\hat{\\theta}}{es(\\hat{\\theta})}\\] donde \\(\\hat{\\theta}\\) es un estimador puntual del parámetro poblacional y \\(es(\\hat{\\theta})\\) es una medida del error estándar que cometemos con el estimador utilizado. Para decidir sobre el contraste planteado utilizaremos el \\(p-valor\\), que representa la probabilidad de que el valor del EC sea superior al valor de dicho estadístico evaluado en los datos muestrales, \\(EC_{obs}\\),atendiendo a la distribución en el muestreo, es decir, \\[p-valor = P(EC \\geq EC_{obs})\\] Para tomar una decisión sobre el contraste miramos si el p-valor obtenido y concluimos que: Si \\(p-valor &lt; \\alpha\\), tenemos evidencias estadísticas suficientes para rechazar la hipótesis nula a favor de la hipótesis alternativa. Si \\(p-valor &gt; \\alpha\\), no tenemos evidencias estadísticas suficientes para rechazar la hipótesis nula. A continuación vemos como ampliar el procedimiento de contraste para una proporción y una media. El proceso de contraste sobre una varianza no suele tener interés práctico ya que resulta más habitual obtener un intervalo de confianza. Como veremos en el tema siguiente, si que resulta relevante el proceso de contraste cuando se involucran dos poblaciones y estamos interesados en comparar la variabilidad de ambas. 4.3.4.3 Una proporción Tenemos una población de tipo Bernouilli que viene especificada a partir de la proporción de sujetos que alcanzan el “éxito,” \\(\\theta\\), y una estimación de dicho parámetro dada por \\(\\hat{\\theta}\\). Anteriormente ya hemos visto que para una muestra de tamaño \\(n\\) el error estándar viene dado por: \\[es(\\hat{\\theta}) = \\sqrt{\\frac{\\hat{\\theta} (1-\\hat{\\theta}))}{n}}.\\] Tanto para el contraste unilateral como el bilateral el estadístico de contraste viene dado por: \\[EC = \\frac{\\theta - \\hat{\\theta}}{\\sqrt{\\frac{\\hat{\\theta} (1-\\hat{\\theta}))}{n}}}\\] cuya distribución en el muestreo es \\(N(0,1)\\). Dicho estadístico valora lo cerca que queda el estimador respecto del valor poblacional teniendo en cuenta el error cometido en el proceso de estimación. Ejemplo. Se está estudiando el efecto de los rayos X sobre la viabilidad huevo-larva en Tribolium casteneum. Se plantean tres situaciones: a) la proporción de viabilidad es del 50%, b) la proporción de viabilidad es superior al 60%, c) la proporción de viabilidad es inferior al 55%. Los contrastes asociados con cada situación son: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta = 0.5\\\\ H_a: &amp; \\theta \\neq 0,5 \\end{array}\\right.\\] \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta \\geq 0.6\\\\ H_a: &amp; \\theta &lt; 0.6 \\end{array}\\right.\\] \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta \\leq 0.55\\\\ H_a: &amp; \\theta &gt; 0.55 \\end{array}\\right.\\] Para verificar dichios contarstes se irradiaron 1000 huevos de los que resultaron 572 larvas. Para resolver contrastes en estas situaciones utiliamos la función prop.test() # Situación 1 n &lt;- 1000 larvas &lt;- 572 # Debemos fijar el valor del contraste, el tipo (two.sided), y el nivel de significación o su análogo como el nivel de confianza prop.test(larvas, n, p = 0.5, alternative = &quot;two.sided&quot;, conf.level = 0.95) ## ## 1-sample proportions test with continuity correction ## ## data: larvas out of n ## X-squared = 20.449, df = 1, p-value = 6.124e-06 ## alternative hypothesis: true p is not equal to 0.5 ## 95 percent confidence interval: ## 0.5406126 0.6028273 ## sample estimates: ## p ## 0.572 El p-valor resultante es 6.124e-06 que resulta inferior al nivel de significación prefijado de 0.05. Por lo tanto hay evidencias para rechazar la hipótesis nula y concluir que la proporción de viabilidad una vez irradiamos los huevos con rayos X es distinta del 50%. # Situación 2 n &lt;- 1000 larvas &lt;- 572 # Debemos fijar el valor del contraste, el tipo (two.sided), y el nivel de significación o su análogo como el nivel de confianza prop.test(larvas, n, p = 0.6, alternative = &quot;less&quot;, conf.level = 0.95) ## ## 1-sample proportions test with continuity correction ## ## data: larvas out of n ## X-squared = 3.151, df = 1, p-value = 0.03794 ## alternative hypothesis: true p is less than 0.6 ## 95 percent confidence interval: ## 0.0000000 0.5980029 ## sample estimates: ## p ## 0.572 El p-valor resultante es 0.03794 que resulta inferior al nivel de significación prefijado de 0.05. Por lo tanto hay evidencias para rechazar la hipótesis nula y concluir que la proporción de viabilidad una vez irradiamos los huevos es mayor o igual al 60%. # Situación 2 n &lt;- 1000 larvas &lt;- 572 # Debemos fijar el valor del contraste, el tipo (two.sided), y el nivel de significación o su análogo como el nivel de confianza prop.test(larvas, n, p = 0.55, alternative = &quot;greater&quot;, conf.level = 0.95) ## ## 1-sample proportions test with continuity correction ## ## data: larvas out of n ## X-squared = 1.8677, df = 1, p-value = 0.08587 ## alternative hypothesis: true p is greater than 0.55 ## 95 percent confidence interval: ## 0.545601 1.000000 ## sample estimates: ## p ## 0.572 El p-valor resultante es 0.08587 que resulta superior al nivel de significación prefijado de 0.05. Por lo tanto hay evidencias para no rechazar la hipótesis nula y concluir que la proporción de viabilidad una vez irradiamos los huevos puede ser menor o igual al 55%. 4.3.4.4 Una media Tenemos una población Normal que viene especificada a partir de la media (\\(\\mu\\)) y varianza (\\(\\sigma^2\\)). Por el momento estamos interesados en los procedimientos de contraste sobre la media cuando desconocemos el valor de la varianza poblacional. Tomamos los estimadores habituales \\(\\bar X\\), \\(S^2\\), y consideramos el error estándar: \\[es(\\bar X) = \\frac{s}{\\sqrt{n-1}}.\\] Tanto para el contraste unilateral como el bilateral el estadístico de contraste viene dado por: \\[EC = \\frac{\\mu - \\bar X}{\\frac{s}{\\sqrt{n-1}}}\\] cuya distribución en el muestreo es una \\(t\\) de Student con n-1 grados de libertad. Ejemplo. La concentración media de dióxido de carbono en el aire en una cierta zona no es habitualmente mayor que 335 ppmv (partes por millon en volumen). Se sospecha que esta concentración es mayor en la capa de aire más próxima a la superficie. Los investigadores quieren comprobar si la concentración en la superficie es mayor o igual a dicho valor con una significación de 0.05. Se plantea el contraste: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\mu \\geq 335\\\\ H_a: &amp; \\mu &lt; 335 \\end{array}\\right.\\] Para tratar de ratificar su hipótesis Se ha analizado el aire en 20 puntos elegidos aleatoriamente a una misma altura cerca del suelo, resultando los siguientes datos: 332, 320, 312, 270, 330, 354, 356, 310, 341, 313, 223, 224, 305, 321, 325, 333, 332, 345, 312, 331. Para resolver este contraste utilizamos la función t.test() datos &lt;- c(332, 320, 312, 270, 330, 354, 356, 310, 341, 313, 223, 224, 305, 321, 325, 333, 332, 345, 312, 331) # Debemos fijar el valor del contraste, el tipo (two.sided), y el nivel de significación o su análogo como el nivel de confianza t.test(datos, mu = 335, alternative = &quot;less&quot;, conf.level = 0.95) ## ## One Sample t-test ## ## data: datos ## t = -2.5219, df = 19, p-value = 0.01038 ## alternative hypothesis: true mean is less than 335 ## 95 percent confidence interval: ## -Inf 328.5403 ## sample estimates: ## mean of x ## 314.45 El p-valor resultante es 0.01038 que resulta inferior al nivel de significación prefijado de 0.05. Por lo tanto hay evidencias para rechazar la hipótesis nula y concluir que la media del nivel de dióxido de carbono en la capa de aire más cercana a la superficie es menor a 335 ppmv. 4.4 Inferencia para dos poblaciones En este sección completamos el estudio inferencial visto en los puntos anteriores. Más concretamente se muestra el análisis inferencial para la comparación de dos proporciones o dos medias. En la situación de la comparación de dos medias veremos también la influencia que tiene el estudio de las varianzas de ambas poblaciones. No se presentan todas las formulaciones y distribuciones asociadas con estos análisis sino que se presenta directamente la forma de resolverlos. se pueden consultar los desarrollos estadísticos en cualquier libro de estadística básica. Poblaciones Binomiales Sean dos poblaciones sobre las que se desea estudiar una misma característica de interés de tipo discreto (1 = éxito; 0 = fracaso), que identificamos por \\(X_{P1}\\) y \\(X_{P2}\\) respectivamente. El parámetro de interés en cada población es la proporción de éxito, \\(\\theta_1\\) y \\(\\theta_2\\) respectivamente, pero el interés inferencial principal es la comparación de \\(\\theta_1\\) y \\(\\theta_2\\), es decir, comprobar si la proporción de éxito en la población 1 es comparable con la proporción de éxito en la población 2. Para realizar dicha comparación se utiliza el parámetro que viene dado por la diferencia de proporciones de éxito: \\[\\theta_1 - \\theta_2\\] Si las proporciones son iguales la diferencia debería estar próximo a cero, mientras que si son distintas la diferencia sería estadísticamente diferente a cero. Poblaciones Normales Sean dos poblaciones normales sobre las que se desea estudiar una misma característica de interés de tipo continuo que identificamos por \\(X_{P1}\\) y \\(X_{P2}\\) respectivamente. Cada población viene caracterizada por su media y varianza, es decir, \\[X_{P1} \\sim N(\\mu_1,\\sigma^2_1) \\text{ ; } X_{P2} \\sim N(\\mu_2,\\sigma^2_2)\\] En este caso el proceso inferencial se centras en todos los parámetros, medias y varianzas, pero habitualmente el objetivo inferencial principal se centra en comprobar si las medias de ambas poblaciones pueden considerarse iguales o diferentes. Por tanto, el parámetro de interés es la diferencia de medias poblacionales: \\[\\mu_1 - \\mu_2\\] Como ocurre con las proporciones, se considera que las medias son iguales cuando la diferencia de las medias es estadísticamente cero. Sin embargo, para poder realizar dicho estudio es necesario conocer en primer lugar si las varianzas de ambas poblaciones pueden considerarse iguales o distintas. En función del resultado de dicha comparación se deberá utilizar un proceso inferencial diferente para la comparación de medias. Dado que las varianzas siempre son positivas el parámetro de interés para la comparación de varianzas viene dado por su cociente: \\[\\frac{\\sigma^2_1}{\\sigma^2_1}\\] 4.5 Inferencia para dos proporciones Dada una muestra aleatoria en cada una de las poblaciones de interés de tamaños \\(n_1\\) y \\(n_2\\), utilizamos los estimadores habituales de la proporción poblacional dados por las proporciones muestrales \\(\\hat{\\theta}_1\\) y \\(\\hat{\\theta}_2\\). Como ya hemos dicho el parámetro objetivo en esta situación es la diferencia de proporciones poblacionales. Ejemplo. La angina de pecho es una afección cardíaca en la que el paciente sufre ataque períodicos de dolor. En un estudio para analizar la efectividad de una nueva droga para prevenir dichos ataques se han seleccionado dos grupos de sujetos. Al primero de ellos se les dará la nueva droga mientras que al otro se les dará el tratamiento estándar. Los resultados obtenidos después de un periodo de 28 semanas viene dados en la tabla siguiente: Estado / Tratamiento Droga nueva Droga antigua Sin angina 44 19 Con angina 116 128 Total 160 147 Se está interesado en conocer con una confianza del 90% (significación de 0.1) si la porporción de pacientes mejorados con la nueva droga es diferente con respecto a la droga antigua. # carga de datos muestra &lt;- c(160,147) mejoras &lt;- c(44,19) # Tabla res &lt;- data.frame(mejoras, muestra) colnames(res) &lt;- c(&quot;mejoras&quot;,&quot;muestra&quot;) res Tabla 4.1: mejorasmuestra 44160 19147 4.5.1 Estimador puntual El estimador puntual de la diferencia de proporciones poblacionales se consigue partir de los estimadores puntuales de cada una de las proporciones de éxito muestrales. Para los datos de nuestro ejemplo, si la población 1 identifica a los usjetos que toman la nueva droga y la pobalción 2 a los que toman la droga antigua, tendríamos: \\(\\widehat{\\theta_1 - \\theta_2} = \\widehat{\\theta_1} - \\widehat{\\theta_2} = \\frac{44}{160} - \\frac{19}{147} = 0.1457\\) Se observa una diferencia en la mejora de los sujetos del 14.57% de los que toman la droga nueva frente a los que toman la droga estándar. 4.5.2 Estimador por intervalos de confianza Para obtener el intervalo de confianza para la diferencia de proporciones utilizamos la función prop.test(). Esta función también nos permite realizar el correspondiente contarte pero por le momento solo pediremos los resultados referidos al intervalo de confianza. analisis &lt;- prop.test(mejoras,muestra,conf.level = 0.90) # Intervalo de confianza analisis$conf.int ## [1] 0.0654468 0.2260498 ## attr(,&quot;conf.level&quot;) ## [1] 0.9 Para los datos de nuestro ejemplo el intervalo de confianza al 90% indica que la diferencia de proporciones de mejora entre los que usan la droga nueva frente a os que usan la droga estándar se sitúa entre el 6.5% y el 22.6%. 4.5.3 Contraste de hipótesis El contraste habitual en esta situación viene dado por: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\theta_1 = \\theta_2\\\\ H_a: &amp; \\theta_1 \\neq \\theta_2 \\end{array}\\right.\\] donde estamos interesados en verificar si las proporciones de éxito poblacionales pueden considerarse iguales o distintas. Para los datos de nuestro ejemplo tenemos: analisis &lt;- prop.test(mejoras,muestra,conf.level = 0.90) # Resultados completos analisis ## ## 2-sample test for equality of proportions with continuity correction ## ## data: mejoras out of muestra ## X-squared = 9.1046, df = 1, p-value = 0.00255 ## alternative hypothesis: two.sided ## 90 percent confidence interval: ## 0.0654468 0.2260498 ## sample estimates: ## prop 1 prop 2 ## 0.2750000 0.1292517 Dado que el pvalor obtenido (0.00255) es inferior al nivel de siginificación prefijado (0.1) hay eviedencias estadísticas para rechazar la hipótesis nula, es decir, hay evidendaicas para concluir que las proporciones de mejora con mabsa drogas son distintas. Además el intervalo de confianza ya nos indicaba qye dicha mejoría era a favor de la droga nueva con los valores obtenidos en el aprtado anterior 4.6 Inferencia para dos medias Los problemas de inferencia asociados con la comparación de dos medias poblacionales para variables Normales presentan diferentes situaciones: Estudio de dos poblaciones independientes con variabilidades iguales Estudio de dos poblaciones independientes con variabilidades distintas Estudio de la evolución de una población (medidas antes - después) A continuación se detalla como realizar el análisis de cada uno de ellos, pero antes de pasar con ellos debemos estudiar el problema de como comparar las variabilidades en dos poblaciones independientes. Presentamos en primer lugar los diferentes ejemplos de trabajo. Ejemplo 1. Para realizar un estudio de la concentración de una hormona en una solución vamos a utilizar dos métodos. Disponemos de 10 dosis preparadas en el laboratorio y medimos la concentración de cada una con los dos métodos. Se obtienen los siguientes resultados: Dosis 1 2 3 4 5 6 7 8 9 10 Método A 10.7 11.2 15.3 14.9 13.9 15 15.6 15.7 14.3 10.8 Método B 11.1 11.4 15 15.1 14.3 15.4 15.4 16 14.3 11.2 Se desea realizar el estudio inferencial con una confianza del 95%. Ejemplo 2. Una compañía contrata 10 tubos con filamentos del tipo A y 12 tubos con filamentos del tipo B. Las duraciones medias observadas se muestran en la siguiente tabla: Tipo/Duración 1 2 3 4 5 6 7 8 9 10 11 12 A 1614 1094 1293 1643 1466 1270 1340 1380 1081 1497 B 1383 1138 920 1143 1017 961 1627 821 1711 865 1662 1698 Se desea realizar el estudio inferencial con una confianza del 90%. Ejemplo 3. En una unidad del sueño se está probando con un nuevo somnífero. Para comprobar su eficacia se toman 10 individuos al azar. Un día no se les suministra el somnífero y se les anota el número de horas de sueño, al día siguiente se les suministra y se vuelve a comprobar las horas de sueño. Los resultados entes y después del tratamiento han sido los siguientes: Instante/Sujeto 1 2 3 4 5 6 7 8 9 10 Antes 7.3 8.2 6.3 5.2 6.9 5.8 5.3 7.1 6.9 8.1 Después 8.2 7.9 6.4 5.1 7.1 6.3 5.9 8.2 7.1 7.7 Se desea realizar el estudio inferencial con una confianza del 90%. 4.6.1 Análisis de dos varianzas poblacionales Supongamos que tenemos dos poblaciones Normales y que deseamos comprobar si la variabilidad en ambas poblaciones pueden considerarse estadísticamente iguales o distintas. Como ya vimos en la introducción este problema se reduce a la comparación de ambas varianzas a través del cociente de ambas. Para resolver este problema utilizamos la función var.test(). El contraste utilizado es: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\frac{\\sigma^2_1}{\\sigma^2_2} = 1\\\\ H_a: &amp; \\frac{\\sigma^2_1}{\\sigma^2_2} \\neq 1 \\end{array}\\right.\\] Para los datos del ejemplo 1 # Cargamos los datos MetodoA &lt;- c(10.7, 11.2, 15.3, 14.9, 13.9, 15, 15.6, 15.7, 14.3, 10.8) MetodoB &lt;- c(11.1, 11.4, 15, 15.1, 14.3, 15.4, 15.4, 16, 14.3, 11.2) var.test(MetodoA, MetodoB, conf.level = 0.95) ## ## F test to compare two variances ## ## data: MetodoA and MetodoB ## F = 1.1229, num df = 9, denom df = 9, p-value = 0.8657 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.2789187 4.5208902 ## sample estimates: ## ratio of variances ## 1.122925 Dado que el pvalor resultante es superior a la significatividad prefijada, tenemos evidencias estadísticas para no rechazar la hipótesis nula, y por tanto concluir que ambas varianzas no pueden considerarse distintas. Para los datos del ejemplo 2 # Cargamos los datos TipoA &lt;- c(1614,1094,1293,1643,1466,1270,1340,1380,1081,1497) TipoB &lt;- c(1383,1138,920,1143,1017,961,1627,821,1711,865,1662,1698) var.test(TipoA, TipoB, conf.level = 0.9) ## ## F test to compare two variances ## ## data: TipoA and TipoB ## F = 0.3052, num df = 9, denom df = 11, p-value = 0.08543 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 90 percent confidence interval: ## 0.1053789 0.9468807 ## sample estimates: ## ratio of variances ## 0.3052007 Puesto que el pvalor es inferior a la significatividad prefijada podemos concluir que hya evidencias estad´sitivas apra concluir que las varaibilidades en ambas poblaciones pueden considerarse distintas. En todos los análisis inferenciales asociados con la comparación de dos medias utilizamos la función t.test(), aunque con difrentes opciones en función de que las varianzas sean iguales o no, o de que las muestras sean independientes o no.* 4.6.2 Dos medias para poblaciones independientes con varianzas iguales El contraste de hipótesis para esta situación viene dado por: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\mu_1 = \\mu_2\\\\ H_a: &amp; \\mu_1 \\neq \\mu_2 \\end{array}\\right.\\] Utilizamos los datos del ejemplo 1, ya que como hemos visto anteriormente las varianzas de ambas pobalciones puden considerarse iguales # Cargamos los datos MetodoA &lt;- c(10.7, 11.2, 15.3, 14.9, 13.9, 15, 15.6, 15.7, 14.3, 10.8) MetodoB &lt;- c(11.1, 11.4, 15, 15.1, 14.3, 15.4, 15.4, 16, 14.3, 11.2) t.test(MetodoA, MetodoB, alternative = &quot;two.sided&quot;, var.equal = TRUE, conf.level = 0.95) ## ## Two Sample t-test ## ## data: MetodoA and MetodoB ## t = -0.20323, df = 18, p-value = 0.8412 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -2.040763 1.680763 ## sample estimates: ## mean of x mean of y ## 13.74 13.92 Dado que el pavalor es superior a la significatividad prefijada, hay evidencias estadísticas para concluir que las medias de concentración con ambos métodos pueden considerarse iguales. 4.6.3 Dos medias para poblaciones independientes con varianzas distintas El constaste de hipótesis en esta situación es el mismo que en el punto anterior. Utilizamos los datos del ejemplo 2, ya que como hemos visto anteriormente las varianzas de ambas pobalciones puden considerarse distintas # Cargamos los datos TipoA &lt;- c(1614,1094,1293,1643,1466,1270,1340,1380,1081,1497) TipoB &lt;- c(1383,1138,920,1143,1017,961,1627,821,1711,865,1662,1698) t.test(TipoA, TipoB, alternative = &quot;two.sided&quot;, var.equal = TRUE, conf.level = 0.9) ## ## Two Sample t-test ## ## data: TipoA and TipoB ## t = 0.98508, df = 20, p-value = 0.3364 ## alternative hypothesis: true difference in means is not equal to 0 ## 90 percent confidence interval: ## -91.82747 336.42747 ## sample estimates: ## mean of x mean of y ## 1367.8 1245.5 Dado que el pvalor es superior a la significatividad prefijada, hay evidencias estadísticas para concluir que las medias de duración de los filamentos en ambos tipos pueden considerarse iguales. 4.6.4 Dos medias para poblaciones emparejadas Es muy habitual que en ciertas situaciones experimentales nos encontramos que queremos estudiar la evolución (medidas antes -después) de un grupo de sujetos después de ser sometidos a cierta prueba experimental. En esta caso no tenemos dos poblaciones independientes sino sólo una que medimos en dos ocasiones. Por tanto, los procedimientos anteriores tienen que ser modificados para tener en cuenta esta situación. El constaste de hipótesis para esta situación viene dado por: \\[\\left\\{\\begin{array}{ll} H_0: &amp; \\mu_{antes} = \\mu_{despues}\\\\ H_a: &amp; \\mu_{antes} \\neq \\mu_{despues} \\end{array}\\right.\\] De nuevo podemos utilizar la función t.test() con el parámetro paired. Utilizamos los datos del ejemplo 3, donde tenemos una única muestra de sujetos # Cargamos los datos antes &lt;- c(7.3,8.2,6.3,5.2,6.9,5.8,5.3,7.1,6.9,8.1) despues &lt;- c(8.2,7.9,6.4,5.1,7.1,6.3,5.9,8.2,7.1,7.7) t.test(antes, despues, alternative = &quot;two.sided&quot;, paired = TRUE, var.equal = TRUE, conf.level = 0.9) ## ## Paired t-test ## ## data: antes and despues ## t = -1.7925, df = 9, p-value = 0.1066 ## alternative hypothesis: true difference in means is not equal to 0 ## 90 percent confidence interval: ## -0.566341394 0.006341394 ## sample estimates: ## mean of the differences ## -0.28 Dado que el pvalor es superior a la significatividad prefijada, hay evidencias estadísticas para concluir que las horas medias de sueño antes y después de tomar el somnifero no pueden considerarse estadísticamente distintas. 4.7 Procedimientos no paramétricos Todos los procedimientos de inferencia sobre dos medias se basan en la suposición de que las variables sobre las que estamos trabajando se puede considerar que se distribuyen normalmente. Sin embargo, cuando tenemos tamaños muestrales pequeños o simplemente por el tipo de variable que estamos midiendo, dicha suposición no resulta creible y es necesario comporbarla antes de poder aplicar estos procedimientos. SI la distribución no resulta Normal podemos utilizar los procedimientos denominados no parámetricos para la comparación de dos medias. A continuación presentamso el test de normalidad y los contrastes no paramétricos. 4.7.1 Normalidad Este requisito implica que la variable objetivo tiene que distribuirse según una normal para cualquiera de las pobalciones donde se pueda medir. El test utilizado para resolver este problema es el de Shapiro-Wilks. En R utilizamos la función shapiro.test() para concluir estadísticamente sobre este contraste. Siempre utilizamos significatividad de 0.05 en estas situaciones. Para los datos del ejemplo 1 comprobamos si los datos muestrales en cada población pueden considerarse que se distribuyen según una normal. # Cargamos los datos MetodoA &lt;- c(10.7, 11.2, 15.3, 14.9, 13.9, 15, 15.6, 15.7, 14.3, 10.8) MetodoB &lt;- c(11.1, 11.4, 15, 15.1, 14.3, 15.4, 15.4, 16, 14.3, 11.2) shapiro.test(MetodoA) ## ## Shapiro-Wilk normality test ## ## data: MetodoA ## W = 0.8058, p-value = 0.01705 shapiro.test(MetodoB) ## ## Shapiro-Wilk normality test ## ## data: MetodoB ## W = 0.80577, p-value = 0.01704 En ambos casos las conclusión es que rechazamos que los datos se distribuyan según una normal, ya que el pvalor es inferior a la significatividad prefijada. Para los datos del ejemplo 2: # Cargamos los datos TipoA &lt;- c(1614,1094,1293,1643,1466,1270,1340,1380,1081,1497) TipoB &lt;- c(1383,1138,920,1143,1017,961,1627,821,1711,865,1662,1698) shapiro.test(TipoA) ## ## Shapiro-Wilk normality test ## ## data: TipoA ## W = 0.95009, p-value = 0.6696 shapiro.test(TipoB) ## ## Shapiro-Wilk normality test ## ## data: TipoB ## W = 0.86377, p-value = 0.05451 En ambos casos no podemos rechzar que los datos sean normales, ya que el pvalor es superior a la significatividad. 4.7.2 Dos medianas en poblaciones independientes El test no paramétrico no se centra en la comparación de medias sino en la comparación de las medianas. Esto es así porque uno de los incumplimientos más habituales de la normalidad es porque los datos no son simétricos, es decir, la media coincide con la mediana. Para resolver este contraste utilizamos el test de Wilcoxon y su función en R wilcox.test(). Dado que los datos del ejmplo 1 no pueden considerarse normales, utilizamos el test no paramétrico apra concluir si las medianas de ambas poblaciones pueden considerarse iguales o distintas. Fijamos la significatividad en 0.05. # Cargamos los datos MetodoA &lt;- c(10.7, 11.2, 15.3, 14.9, 13.9, 15, 15.6, 15.7, 14.3, 10.8) MetodoB &lt;- c(11.1, 11.4, 15, 15.1, 14.3, 15.4, 15.4, 16, 14.3, 11.2) wilcox.test(MetodoA,MetodoB) ## ## Wilcoxon rank sum test with continuity correction ## ## data: MetodoA and MetodoB ## W = 44, p-value = 0.6768 ## alternative hypothesis: true location shift is not equal to 0 Dado que el pvalor es superior a la significatividad, tenemos evidencias para concluir que no podemos considerar que las medianas de ambas poblaciones sean distintas. 4.7.3 Dos medianas en poblaciones dependientes También existe una versión del test de wilcoxon para la comparación en poblaciones dependientes. Este es muy habitual ya que en este tipo de situaciones lo nomral es tener pocos sujetos, y por tanto la hipótesis de normalidad es muy difícil de verificar. Para los datos del ejemplo 3 tenemos: # Cargamos los datos antes &lt;- c(7.3,8.2,6.3,5.2,6.9,5.8,5.3,7.1,6.9,8.1) despues &lt;- c(8.2,7.9,6.4,5.1,7.1,6.3,5.9,8.2,7.1,7.7) wilcox.test(antes, despues,paired = TRUE) ## ## Wilcoxon signed rank test with continuity correction ## ## data: antes and despues ## V = 12.5, p-value = 0.1389 ## alternative hypothesis: true location shift is not equal to 0 Dado que el pvalor es superior a la significatividad, podemos conluir que la mediana antes y después no pueden considerarse distintas. "],["modelstats.html", "Unidad 5 Modelos estadísticos 5.1 Componentes del modelo 5.2 Tipos de modelos 5.3 Fases en la construcción de un modelo", " Unidad 5 Modelos estadísticos De forma habitual, cuando el investigador (o investigadores) se plantea un diseño experimental y comienza con la recogida de datos es porque persigue el estudio de o verificación de un objetivo planteado sobre la población bajo estudio. Estos objetivos se suelen establecer en base a teorías o hipótesis que se desean verificar sobre le funcionamiento de la población bajo ciertas condiciones experimentales. Por ejemplo: Teorías que establezcan la posible relación entre dos características de la población. Teorías que plateen la idea de comportamientos distintas para una característica de la población en función de una variable que clasifica a los sujetos bajo estudio en diferentes grupos. Es entonces cuando la modelización estadística interviene y el analista busca el mejor modelo que ajusta los datos disponibles y proporciona predicciones fiables. El objetivo de la modelización estadística es el planteamiento de una expresión matemática que representa el comportamiento general de la población bajo estudio, teniendo en cuenta el diseño experimental establecido y el objetivo u objetivos que se desean verificar 5.1 Componentes del modelo Un primer paso en la modelización estadística es el planteamiento de una expresión matemática que represente el comportamiento general de la población bajo estudio teniendo en cuenta el diseño experimental establecido y el objetivo u objetivos que se desean verificar. Esto es lo que se conoce como componente sistemática del modelo y se basa únicamente en la parte controlada del diseño experimental. Por ejemplo, si nos planteamos como objetivo conocer la suma de dos números \\(a\\) y \\(b\\), la función matemática (sistemática) que permite expresar la suma de forma única es \\(a+b\\). Esta componente sistemática es una función determinista, pues siempre proporciona el mismo resultado si los valores de entrada son iguales. Al proponer la parte sistemática (o determinista) de un modelo será siempre necesario concretar la variable que se asocia al objetivo o hipótesis planteada sobre la población (representada por \\(Y\\)) y la variable o variables \\((X_1, X_2,…)\\) relacionadas o supuestamente relacionadas con ella a través de la función matemática especificada. Supongamos un diseño experimental en el que tenemos una variable \\(Y\\) que está ligada directamente con el objetivo de la investigación, y un conjunto de variables \\(X_1, X_2,…,X_k\\), que se supone que pueden influir en el comportamiento de \\(Y\\). Habitualmente a \\(Y\\) se la denomina variable respuesta o variable dependiente y a las \\(X’s\\) variables predictoras, variables explicativas e incluso covariables cuando se trata de variables de tipo numérico continuo. Cuando las variables \\(X\\) son de tipo categórico se suelen denominar factores explicativos o de clasificación. A las variables \\(X\\) se las suele denominar también variables independientes, asumiendo independencia entre ellas, aunque esta acepción puede estar algo alejada de la realidad como discutiremos más adelante; en adelante no utilizaremos esta denominación y optaremos por cualquiera de las anteriormente presentadas. En la situación más sencilla donde la respuesta puede venir influenciada de forma directa por las posibles predictoras, la respuesta media (\\(\\hat{Y}\\)) se puede modelizar a través de una función \\(f\\) que describe la componente sistemática del modelo: \\[\\begin{equation} \\hat{Y} = f(X_1,X_2,...,X_k) \\tag{5.1} \\end{equation}\\] Si nuestro modelo es adecuado, esta función debe reflejar el comportamiento medio esperado de la variable respuesta. Dado que sujetos distintos con los mismos valores de las \\(X’s\\) producirán generalmente valores distintos en la respuesta, se hace necesaria la introducción de una componente variable en el modelo. Esta componente se denomina componente aleatoria y está relacionada directamente con la variabilidad de los sujetos en la respuesta para una misma combinación de valores de las variables predictoras. La denotaremos habitualmente por: \\[\\begin{equation} \\epsilon \\tag{5.2} \\end{equation}\\] que es una variable aleatoria con distribución de probabilidad \\(F\\). Asumiendo que (5.1) y (5.2) tienen un efecto aditivo sobre la respuesta, nuestro modelo base de partida vendrá dado por la expresión: \\[\\begin{equation} Y = \\hat{Y} + \\epsilon = f(X_1,X_2,...,X_k) + \\epsilon \\tag{5.3} \\end{equation}\\] En función del tipo de variable respuesta, las predictoras, de la relación que se pueden establecer entre ellas a través de \\(f\\), y del establecimiento de las estructuras aleatorias \\(F\\) para los errores tendremos diferentes tipos de modelos. A lo largo de esta materia veremos las diferentes posibilidades de modelización. 5.2 Tipos de modelos En función del tipo de variable respuesta, las predictoras, de la relación que se pueden establecer entre ellas a través de \\(f\\), y del establecimiento de las estructuras aleatorias \\(F\\) para los errores tendremos diferentes tipos de modelos. A lo largo de esta materia veremos las diferentes posibilidades de modelización. A lo largo de las unidades siguientes iremos estudiando las características de los diferentes modelos, pero estos se pueden agrupar en dos grandes apartados: Modelos Lineales (LM), que engloban los modelos de regresión, los modelos ANOVA y los modelos ANCOVA. Modelos Lineales Generalizados (GLM), que engloba los modelos de respuesta binomial (modelos de regresión logística), modelos de respuesta poisson, modelos para tablas de contingencia (modelos log-lineales), y modelos de supervivencia. Introduciremos además los modelos de suavizado y una breve introducción a los modelos de efectos aleatorios, que pueden ser utilizados en conjunción con los LM y los GLM. 5.3 Fases en la construcción de un modelo El proceso de modelización y análisis estadístico de un banco de datos se puede estructurar según las siguientes pautas de actuación: Contextualización del problema. Definición de objetivos y variables. Diseño del experimento y recogida de información. Registro y procesado previo de la información disponible. Inspección gráfica e identificación de tendencias. Consideración de hipótesis distribucionales y relacionales. Propuesta de modelización. Ajuste del modelo. Comparación y selección del mejor modelo. Diagnóstico y validación del modelo ajustado. Valoración de la capacidad predictiva del modelo y predicción. Interpretación y conclusiones. Si la revisión/validación del modelo nos lleva a descartarlo (punto 7), será preciso una nueva propuesta, de modo que entraremos en un bucle entre los puntos (5)-(7) que culminará cuando quedemos satisfechos con el diagnóstico y la validación del modelo. A la hora de representar gráficamente la información de cada banco de datos tendremos en cuenta esta serie de principios básicos: La información asociada con la variable respuesta que identifica el objetivo del estudio debe situarse siempre en el eje Y o eje de ordenadas. El tipo de las variables que pueden influir en nuestra variable objetivo condiciona el tipo de gráfico. Así si estas son de tipo numérico debemos realizar un gráfico de dispersión, situando cada una de las variables predictoras \\(X\\) en el eje de abcisas. Si las predictoras son de tipo categórico deberemos realizar un gráfico de cajas, visualizando las distintas categorías en el eje X (si bien siempre podremos invertir los ejes para mostrar las cajas en sentido horizontal y no vertical). Si combinamos variables de tipo numérico y categórico debemos realizar gráficos múltiples de dispersión donde mostremos la relación \\(Y\\) versus \\(X\\) para las variables numéricas en cada uno de los niveles de las variables \\(X\\) categóricas. "],["rls.html", "Unidad 6 Regresión Lineal Simple (RLS) 6.1 Bancos de datos 6.2 El modelo RLS 6.3 Estimación del modelo 6.4 Bondad del Ajuste 6.5 Diagnóstico del Modelo 6.6 Predicción del modelo", " Unidad 6 Regresión Lineal Simple (RLS) Nos preocupamos en este tema del Modelo de Regresión Lineal Simple (RLS), que podemos catalogar como el modelo lineal más sencillo, a través del cual pretendemos explicar (predecir) una variable respuesta continua \\(Y\\) a partir de una variable predictora también continua \\(X\\). Tal modelo vendrá justificado por unos buenos resultados previos en el análisis de correlación (lineal) entre las dos variables en cuestión. En el experimento o estudio del que obtenemos los datos, los valores de \\(Y\\) se han observado y los de \\(X\\), bien se han observado, bien se han prefijado por parte del investigador. En cualquier caso, asumimos que la aleatoriedad (incertidumbre) está contenida sólo en la variable \\(Y\\), mientras que la \\(X\\) carece de aleatoriedad y simplemente informa de lo que ocurre en los valores observados. La variable explicativa puede ser, tanto una causa de la respuesta, como un mero testigo que informa sobre cómo varía la respuesta. De ahora en adelante denotamos por \\((x_1, x_2,...,x_n)\\) e \\((y_1, y_2,...,y_n)\\) a los valores observados de las variables \\(X\\) e \\(Y\\) en un experimento dado. 6.1 Bancos de datos Presentamos a continuación los bancos de datos con los que trabajamos a lo largo de esta unidad. Ejemplo 1. Datos de Corrosión. Treinta aleaciones del tipo 90/10 Cu-Ni, cada una con un contenido específico de hierro son estudiadas bajo un proceso de corrosión. Tras un período de 60 días se obtiene la pérdida de peso (en miligramos al cuadrado por decímetro y día) de cada una de las aleaciones debido al proceso de corrosión. El objetivo es estudiar el nivel de corrosión en función del contenido de hierro. A continuación se presenta el banco de datos y se realiza la primera inspección gráfica. hierro &lt;- c(0.01, 0.48, 0.71, 0.95, 1.19, 0.01, 0.48, 1.44, 0.71, 1.96, 0.01, 1.44, 1.96) peso &lt;- c(127.6, 124, 110.8, 103.9, 101.5, 130.1, 122, 92.3, 113.1, 83.7, 128, 91.4, 86.2) corrosion &lt;- data.frame(hierro,peso) ggplot(corrosion, aes(x = hierro, y = peso)) + geom_point() + labs(x = &quot;Contenido en hierro&quot;, y = &quot;Pérdida de peso&quot;) Figura 6.1: Gráfico de dispersión de pérdida de peso vs contenido en hierro. En la figura 6.1 se observa cómo al ir aumentando el contenido en hierro de la aleación disminuye linealmente la pérdida de peso. El modelo estadístico que propongamos deberá ser capaz de explicar dicho comportamiento. Ejemplo 2. Datos de Papel Queremos estudiar la relación existente entre la concentración de madera contenida en la pulpa a partir de la que se elabora papel (madera), y la resistencia (tension, en términos de tensión que soporta) del papel resultante. El objetivo del análisis es describir la tendencia observada. A continuación se presenta el banco de datos y se realiza la primera inspección gráfica. madera &lt;- c(1, 1.5, 2, 3, 4, 4.5, 5, 5.5, 6, 6.5, 7, 8, 9, 10, 11, 12, 13, 14, 15) tension &lt;- c(6.3, 11.1, 20.0, 24, 26.1, 30, 33.8, 34, 38.1, 39.9, 42, 46.1, 53.1, 52, 52.5, 48, 42.8, 27.8, 21.9) papel &lt;- data.frame(madera, tension) ggplot(papel, aes(x = madera, y = tension)) + geom_point() + labs(x = &quot;Concentración de madera&quot;, y = &quot;Resistencia del papel&quot;) Figura 6.2: Gráfico de dispersión de resistencia del papel vs concentración de madera. En la figura 6.2 podemos ver cómo la resistencia del papel crece al aumentar la concentración de madera hasta llegar a valores de 9 y disminuye a partir de ese valor. En este caso la relación apreciada es de tipo parabólico (descrita por una parábola). Este hecho se debe tener en cuenta en la propuesta de un modelo preliminar. Ejemplo 3. Datos de Viscosidad. Se ha realizado un experimento para tratar de conocer la viscosidad de cierto compuesto en función de la cantidad de un tipo der aceite que se usa en su fabricación. Se asume una relación de tipo lineal entre la viscosidad y la cantidad de aceite utilizada. aceite &lt;- c(0, 12, 24, 36, 48, 60, 0, 12, 24, 36, 48, 60, 0, 12, 24, 36, 48, 60, 12, 24, 36, 48, 60) viscosidad &lt;- c(26, 38, 50, 76, 108, 157, 17, 26, 37, 53, 83, 124, 13, 20, 27, 37, 57, 87, 15, 22, 27, 41, 63) aceites&lt;-data.frame(aceite, viscosidad) ggplot(aceites, aes(x = aceite, y = viscosidad)) + geom_point() + labs(x = &quot;Cantidad de aceite&quot;, y = &quot;Viscosidad&quot;) Figura 6.3: Gráfico de dispersión de viscosidad vs cantidad de aceite. 6.2 El modelo RLS El modelo de Regresión lineal Simple (RLS) de la variable respuesta (\\(Y\\)) sobre la variable predictora (\\(X\\)) se formula prediciendo la respuesta media para un valor observado de \\(X = x\\), con una recta de regresión: \\[\\begin{equation} E(y\\mid x=x) = \\beta_{0} + \\beta_{1}x. \\tag{6.1} \\end{equation}\\] Es de esperar cierta desviación ‘aleatoria’ entre la respuesta observada y la respuesta media. Dicha desviación es denominada error aleatorio y denotada habitualmente por \\(\\epsilon\\). Así, el modelo completo de regresión simple se formula según: \\[\\begin{equation} Y = \\beta_{0} + \\beta_{1}X + \\epsilon. \\tag{6.2} \\end{equation}\\] Los coeficientes de la regresión, esto es, los parámetros que hemos de estimar para ajustar el modelo RLS son: \\(\\beta_{0}\\).- la interceptación de la recta, esto es, la altura de la recta cuando \\(x = 0\\). \\(\\beta_{1}\\).- la pendiente de la recta, que refleja cuánto varía la respuesta media \\(E\\)(y) cuando pasamos de observar x = \\(x\\) a x = \\(x\\) + 1. Dada una muestra de valores observados \\(\\{{(x_{i},y_{i})}_{i=1}^{n}\\}\\), el modelo propuesto implica que todas las observaciones responden a la ecuación (6.2), de forma que: \\[\\begin{equation} y_{i} = \\beta_{0} + \\beta_{1}x_{i}+\\epsilon_{i}, \\ \\ \\ \\ i=1,\\ldots,n, \\tag{6.3} \\end{equation}\\] donde \\(\\epsilon_{i}\\) son errores aleatorios, que además se consideran incorrelados, con media cero y varianza constante \\(\\sigma^{2}\\). Estas características constituyen las hipótesis básicas del modelo RLS, que formulamos con más detalle a continuación sobre los errores aleatorios \\(\\epsilon_{i}\\): Incorrelación: \\(Corr(\\epsilon_{i},\\epsilon_{j}) = 0\\). Significa que las observaciones de la respuesta y, \\(y_{1},y_{2},\\ldots,y_{n}\\) están incorreladas entre sí, esto es, los valores de unas no afectan a los de otras. Media cero: \\(E(\\epsilon_{i}) = 0\\). Lo que implica que la respuesta esperada según el modelo RLS depende linealmente de los coeficientes de regresión \\(\\beta_{0}\\) y \\(\\beta_{1}\\). Varianza constante: \\(Var(\\epsilon_{i} = \\sigma^{2})\\). Lo que significa que las observaciones \\(\\{y_{i},i=1,\\ldots,n\\}\\) provienen de una misma población cuya variabilidad respecto de su media, \\(\\{\\beta_{0} + \\beta_{1}x_{i}, i=1,\\ldots,n\\}\\), viene dada por \\(\\sigma^{2}\\). 6.3 Estimación del modelo Estimar la recta de regresión consiste en estimar los coeficientes de la regresión \\(\\beta_{0}\\) y \\(\\beta_{1}\\) para obtener la recta: \\[\\begin{equation} \\hat{Y} = \\hat{\\beta_{0}} + \\hat{\\beta_{1}}X, \\tag{6.4} \\end{equation}\\] donde \\(\\hat{Y}\\) denota el valor de Y predicho por la recta para el valor observado de \\(X = x\\). Disponemos de dos criterios básicos de estimación, que proporcionan la misma solución. Utilizar uno u otro depende de nuestros intereses estadísticos. Si tan sólo queremos determinar la recta, basta con considerar el criterio de Mínimos Cuadrados. Si además pretendemos utilizarla con fines inferenciales o predictivos, hablaremos de que nuestra solución es la máximo-verosímil, pero a su vez habremos de ser más exigentes con las hipótesis del modelo, como veremos a continuación. 6.3.1 Estimación Mínimos Cuadrados El criterio de mínimos cuadrados o minimización del error cuadrático medio, consiste en minimizar las distancias entre los puntos observados y los predichos por la recta de ajuste. El error cuadrático medio de la recta se define como: \\[\\begin{equation} S(\\beta) = \\sum_{i=1}^{n} (y_{i}-\\hat{y_{i}}(\\beta))^2 = \\sum_{i=1}^{n} [y_{i}-(\\beta_{0}+\\beta_{1}x_{i})]^2 \\tag{6.5} \\end{equation}\\] La solución de mínimos cuadrados \\(\\hat{\\beta} = (\\hat{\\beta_{0}},\\hat{\\beta_{1}})\\) se obtiene minimizando \\(S(\\beta)\\). El mínimo se consigue derivando \\(S(\\beta)\\) respecto de \\(\\beta_{0}\\) y \\(\\beta_{1}\\) e igualando a cero: \\[ \\frac{\\partial S(\\beta)}{\\partial \\beta_{0}} \\mid_{\\hat{\\beta_{0}},\\hat{\\beta_{1}}} = -2 \\sum_{i=1}^{n} (y_{i} - \\hat{\\beta_{0}}-\\hat{\\beta_{1}}x_{i}) = 0 \\] \\[ \\frac{\\partial S(\\beta)}{\\partial \\beta_{1}} \\mid_{\\hat{\\beta_{0}},\\hat{\\beta_{1}}} = -2 \\sum_{i=1}^{n} (y_{i} - \\hat{\\beta_{0}}-\\hat{\\beta_{1}}x_{i})x_{i} = 0. \\] De ahí se obtienen las ecuaciones normales: \\[ n\\hat{\\beta_{0}}+\\hat{\\beta_{1}}\\sum_{i=1}^{n} x_{i}= \\sum_{i=1}^{n} y_{i} \\] \\[ \\hat{\\beta_{0}}\\sum_{i=1}^{n} x_{i} + \\hat{\\beta_{1}} \\sum_{i=1}^{n} x_{i}^{2} = \\sum_{i=1}^{n} y_{i}x_{i} \\] de donde las estimaciones para \\(\\beta_{0}\\) y \\(\\beta_{1}\\) resultan: \\[ \\hat{\\beta_{0}}=\\bar{y}-\\hat{\\beta_{1}}\\bar{x} \\] \\[ \\hat{\\beta_{1}}=\\frac{S_{xy}}{S_{xx}}, \\] con: \\[ \\bar{y} = \\frac{\\sum_{i=1}^{n} y_{i}}{n} \\] \\[ \\bar{x} = \\frac{\\sum_{i=1}^{n} x_{i}}{n} \\] \\[ S_{xx} = \\sum_{i=1}^{n} (x_{i}-\\bar{x})^2 \\] \\[ S_{xy} = \\sum_{i=1}^{n} (x_{i}-\\bar{x})(y_{i}-\\bar{y}). \\] 6.3.2 Estimación Máximo Verosímil Habitualmente el objetivo de un análisis de regresión no consiste únicamente en estimar la recta, sino en inferir con ella, esto es, asociar un error a las estimaciones obtenidas, contrastar un determinado valor de los parámetros, y/o incluso predecir la respuesta, junto con una banda de confianza, para un \\(X = x\\) dado. En ese caso, precisamos de distribuciones de probabilidad para controlar la incertidumbre y el error. Añadimos pues, una hipótesis más sobre la distribución de la variable respuesta, o lo que es lo mismo, sobre el error aleatorio \\(\\epsilon\\). Dicha hipótesis es la de normalidad de los errores. Así, el total de hipótesis básicas del modelo de regresión con fines inferenciales, viene resumido en la siguiente expresión: \\[\\begin{equation} \\epsilon_{i} \\overset{iid}{\\sim} N(0,\\sigma^{2}), \\qquad i=1,\\ldots,n. \\tag{6.6} \\end{equation}\\] esto es, hablamos de errores aleatorios independientes e idénticamente distribuidos (iid) según una distribución Normal con media cero y varianza \\(\\sigma^{2}\\), lo que implica directamente que la distribución para la variable respuesta será: \\[\\begin{equation} y_{i} \\overset{iid}{\\sim} N(\\beta_{0} + \\beta_{1}x_{i}, \\sigma^{2}), \\qquad i=1,\\ldots,n. \\tag{6.7} \\end{equation}\\] Desde este momento, los datos proporcionan información sobre los parámetros del modelo, \\(\\beta = (\\beta_{0},\\beta_{1})\\), a través de la verosimilitud conjunta: \\[\\begin{equation} L(\\beta;y)=exp\\left\\{-\\frac{\\sum_{i=1}^n (y_i-\\beta_0-\\beta_1 x_i)^2}{2 \\sigma^2}\\right\\}. \\tag{6.8} \\end{equation}\\] Por tanto, obtener la solución más factible a la vista de los datos observados \\(\\{(x_i,y_i), i=1,\\ldots, n\\}\\) equivale a obtener la solución máximo-verosímil, esto es, la que maximiza la verosimilitud (6.8). Maximizar la verosimilitud es equivalente a maximizar la log-verosimilitud \\(l(\\beta,y)\\), que tiene una expresión más sencilla sin exponenciales. La solución máximo-verosímil se obtiene derivando e igualando a cero \\(l(\\beta,y)\\), lo que da lugar, de nuevo, a las ecuaciones normales. Así pues, la solución máximo-verosímil coincide con la de mínimos cuadrados. 6.3.3 Estimación con R Para obtener el ajuste máximo verosímil con R utilizamos la función lm() que permite el ajuste de cualquier modelo lineal. Su expresión más básica viene dada por: \\[model &lt;- lm(y \\sim x, data = ´´data´´)\\] donde \\(y\\) es la respuesta y \\(x\\) es la predictora. Para obtener las estimaciones del modelo podemos hacer uso de diferentes funciones: tidy(model) de la librería tidymodels que nos proporciona el modelo estimado, los errores en la estimación y la soluciones del contraste sobre cada parámetro del modelo que veremos en el apartado de inferencia sobre los coeficientes del modelo. glm_coef(model) de la librería pubh que nos proporciona las estimaciones del modelo, los intervalos de confianza al 95% de cada parámetro, y el p-valor asociado a los contrastes sobre cada uno de los parámetros del modelo. summary(model) que proporciona un resumen completo del modelo (inferencia sobre los parámetros del modelo y bondad de ajuste). Por el momento utilizamos las dos primeras para mostrar los resultados del ajuste. Además utilizaremos la función plot_model para representar gráficamente el modelo obtenido como alternativa a la función ggplot() que hemos utilizado en la figura 6.4. 6.3.4 Ejemplos Para los datos de Corrosión se propone un modelo de regresión lineal simple para estudiar la relación entre la pérdida de peso debida a la corrosión y el contenido de hierro de la forma siguiente: \\[ \\text{peso} = \\beta_{0} + \\beta_{1}*\\text{hierro} + \\epsilon \\] # Ajuste del modelo fit &lt;- lm(peso ~ hierro, data = corrosion) # Solución con tidy tidy(fit) Tabla 6.1: termestimatestd.errorstatisticp.value (Intercept)1301.4&nbsp;92.52.93e-17 hierro-241.28-18.81.06e-09 # Solución con glm_coef glm_coef(fit) Tabla 6.1: ParameterCoefficientPr(&gt;|t|) (Intercept)129.79 (126.7, 132.87)&lt; 0.001 hierro-24.02 (-26.84, -21.2)&lt; 0.001 de forma que el modelo estimado viene dado por: \\[ \\widehat{\\text{peso}} = 129.79 - 24.02*\\text{hierro} \\] esto es, un aumento de una unidad del contenido de hierro reporta una pérdida de peso de 24.02 unidades. Representamos gráficamente la recta del ajuste obtenida: # Gráfico del ajuste plot_model(fit,&quot;pred&quot;, terms = ~hierro, ci.lvl = NA, show.data = TRUE, axis.title = c(&quot;Contenido en hierro&quot;, &quot;Peso&quot;), title = &quot; &quot;) Figura 6.4: Ajuste de mínimos cuadrados para los datos de corrosión. 6.3.5 Propiedades de la recta de regresión. Las propiedades más relevantes y básicas del ajuste de la recta de regresión son las siguientes: La estimación de la respuesta para un valor de x=\\(x\\) concreto según el modelo de regresión lineal simple se obtiene de la recta de regresión ajustada: \\[ \\hat{y}=\\hat{\\beta_0}+\\hat{\\beta_1} x. \\] La suma de los residuos de una recta de regresión con término de interceptación \\(\\beta_0\\) es cero, \\[ e_i=y_i-\\hat{y} \\rightsquigarrow \\sum_i e_i=0. \\] La media de los valores observados \\(y_i\\) coincide con la media de los valores predichos \\(\\hat{y_i}\\), \\[ \\frac{1}{n}\\,\\sum_i y_i=\\frac{1}{n} \\,\\sum_i \\hat{y}_i. \\] La recta de regresión pasa por el centroide de medias \\((\\bar{x},\\bar{y})\\). La suma de los residuos ponderados por el valor correspondiente de la variable predictora \\(x\\) es cero, \\[ \\sum_i x_i e_i=0. \\] La suma de los residuos ponderados por el valor ajustado por la recta \\(\\hat{y}\\) es cero, \\[ \\sum_i \\hat{y}_i e_i=0. \\] 6.3.6 Estimación varianza del modelo. La varianza \\(\\sigma^2\\) de los errores es una medida de la variabilidad (heterogeneidad) entre los individuos respecto a la media cuando el modelo RLS describe adecuadamente la tendencia entre las variables \\(y\\) y \\(x\\), o lo que es lo mismo, de la dispersión de las observaciones respecto de la recta de regresión. Así pues, da una medida de bondad de ajuste del modelo de regresión a los datos observados. Cuando el modelo de regresión ajustado es bueno para nuestros datos, es posible conseguir una estimación de la varianza \\(\\sigma^2\\) a partir de la suma de cuadrados residual \\(SSE\\), también llamada suma de cuadrados debida al error: \\[ SSE=\\sum_i (y_i-\\hat{y}_i)^2=S_{yy}-\\hat{\\beta}_1 S_{xy}. \\] \\(SSE\\) da una medida de la desviación entre las observaciones \\(y_i\\) y las estimaciones que proporciona la recta de regresión, \\(\\hat{y}_i\\). Puesto que en el modelo de regresión lineal simple se estiman \\(2\\) parámetros, los grados de libertad asociados a \\(SSE\\) son \\(n-2\\). Se define pues el cuadrado medio residual, \\(MSE\\), como un estimador de \\(\\sigma^2\\), que además resulta ser insesgado (esto es, su valor esperado es \\(\\sigma^2\\)): \\[ s^2=MSE=\\frac{SSE}{n-2}. \\] El error estándar residual viene dado por \\(s=\\sqrt{MSE}\\). 6.3.7 Inferencia sobre los coeficientes del modelo Los estimadores de mínimos cuadrados \\(\\hat{\\beta}_0\\) y \\(\\hat{\\beta}_1\\) son insesgados y de mínima varianza de entre todos los estimadores insesgados. El hecho de especificar una distribución normal sobre los errores para la estimación máximo-verosímil, permite derivar de forma directa la distribución de dichos estimadores, que resulta también normal: \\[ \\hat{\\beta}_0 \\sim N\\left( \\beta_0, \\frac{\\sum_{i=1}^n x_{i}^2}{nS_{xx}} \\sigma^2 \\right) \\] \\[ \\hat{\\beta}_1 \\sim N\\left( \\beta_1, \\frac{\\sigma^2}{S_{xx}}\\right), \\] Cuando el modelo de regresión es adecuado, podemos estimar las varianzas de dichas distribuciones sustituyendo \\(\\sigma^2\\) por \\(s^2\\) . De ahí podemos construir los estadísticos \\(t\\) para inferir sobre los parámetros: \\[ t_0 = \\frac{\\hat{\\beta}_0-\\beta_0}{s \\ \\sqrt{\\sum_i x_i^2/n S_{xx}}} \\] \\[ t_1 = \\frac{\\hat{\\beta}_1-\\beta_1}{s/\\sqrt{S_{xx}}} \\] Ambos estadísticos se distribuyen según una distribución \\(t\\)-Student con \\(n-2\\) grados de libertad, que nos permite inferir (estimar y resolver contrastes de hipótesis) sobre los coeficientes del modelo, y en particular contestar a preguntas sobre la relación entre las variables respuesta y explicativa. 6.3.7.1 Procedimientos de estimación Las estimaciones puntuales de \\(\\beta_0\\) y \\(\\beta_1\\) las obtenemos directamente de las ecuaciones normales. Los intervalos de confianza al nivel de confianza \\((1-\\alpha)100\\%\\) para \\(\\beta_0\\) y \\(\\beta_1\\) se construyen a partir de los estadísticos \\(t\\) y resultan: \\[ IC( \\beta_0;1-\\alpha) = \\hat{\\beta}_0 \\pm t_{\\left(n-2,1-\\frac{\\alpha}{2}\\right)} \\sqrt{\\frac{\\sum_{i=1}^n x_i^2}{n S_{xx}} \\ s^2} \\] \\[ IC(\\beta_1;1-\\alpha) = \\hat{\\beta}_1 \\pm t_{\\left(n-2,1-\\frac{\\alpha}{2}\\right)} \\ \\sqrt{\\frac{s^2}{S_{xx}}}, \\] donde \\(t_{\\left(n-2,1-\\frac{\\alpha}{2}\\right)}\\) es el cuantil \\(1-\\alpha/2\\) de una distribución \\(t\\)-Student con \\(n-2\\) grados de libertad (los correspondientes a \\(s^2\\)). 6.3.7.2 Procedimientos de Contrastes de Hipótesis Si queremos contrastar Hipótesis sobre los coeficientes de la regresión: \\[\\left\\{\\begin{array}{ll} H_{0}:&amp; \\beta_{i} = \\beta^{*} \\\\ H_{1}:&amp; \\beta_{i} \\neq \\beta^{*}, i=0,1\\\\ \\end{array} \\right.\\] basta con considerar los estadísticos \\(t\\) anteriores, y sustituir el valor \\(\\beta_i\\) por el que se pretende contrastar, \\(\\beta^*\\). Estos estadísticos, bajo \\(H_0\\), tienen una distribución \\(t\\)-Student con \\(n-2\\) grados de libertad. La resolución del contraste consiste en calcular el p-valor asociado al valor absoluto de la estimación, \\(|t_0|\\) o \\(|t_1|\\), según el caso, esto es, \\(p-valor=Pr[t_{n-2}&gt;|t_i|]\\), donde \\(t_{n-2}\\) representa una variable t-Student con \\(n-2\\) grados de libertad, y \\(t_i\\) es el valor observado para el estadístico correspondiente. Dicho contraste se resuelve de la forma habitual: se rechaza \\(H_{0}\\) a nivel de confianza \\(1-\\alpha\\) cuando \\(p-valor \\leq \\alpha\\), si \\(p-valor &gt; \\alpha\\), se dice que los datos no proporcionan suficientes evidencias en contra de la hipótesis nula y ésta no se puede rechazar. Cuando el contraste propuesto sobre \\(\\beta_0\\) o \\(\\beta_1\\) tiene \\(\\beta^*=0\\), en realidad se está contrastando, respectivamente, si la recta de regresión tiene interceptación o pendiente nula. Contrastar \\(\\beta_1=0\\) es equivalente a contrastar correlación nula entre las variables \\(X\\) e \\(Y\\), esto es, ausencia de relación lineal. Si conseguimos rechazar esta hipótesis con significatividad, concluiremos que la variable \\(X\\) está relacionada linealmente con \\(Y\\) y por lo tanto se puede utilizar para predecir \\(Y\\) a través de la recta de regresión ajustada. 6.3.8 Ejemplo Realizamos el proceso de inferencia para el modelo para los datos de corrosión e interpretamos los resultados obtenidos. Concretamente: Construir intervalos de confianza al 95% para \\(\\beta_0\\) y \\(\\beta_1\\). ¿Qué podemos decir de la relación entre dichas variables? Concluir sobre los contrastes \\(\\beta_0=0\\) y \\(\\beta_1=0\\). Comprobar también que el último contraste \\(\\beta_1=0\\) es equivalente al contraste de correlación nula entre las variables del modelo. Recapturamos el resumen del modelo obtenido con la función glm_coef()- # Ajuste del modelo fit &lt;- lm(peso ~ hierro, data = corrosion) glm_coef(fit) Tabla 6.2: ParameterCoefficientPr(&gt;|t|) (Intercept)129.79 (126.7, 132.87)&lt; 0.001 hierro-24.02 (-26.84, -21.2)&lt; 0.001 Como se puede observar en los resultados ninguno de los intervalos de confianza incluye al cero, lo que habla positivamente de su significatividad estadística, esto es, tenemos evidencias para predecir la pérdida de peso con el contenido de hierro inicial a través de una recta con interceptación y pendientes (significativamente) distintas de cero. De esta forma podemos ver que el efecto asociado con un incremento en una unidad de hierro produce una pérdida de peso de entre 22.01 y 26.03 unidades. Puestos a resolver el contraste \\(H_0^i:\\beta_i=0\\), para \\(i=0,1\\), observamos los p-valores obtenidos en el proceso de estimación que resultan ambos significativos (&lt;0.001 para \\(\\beta_0\\) y &lt;0.001 para \\(\\beta_1\\)), lo que concluye contundentemente sobre la significatividad de ambos a favor de que son distintos de cero (se rechazan \\(H_0^0\\) y \\(H_0^1\\)), como ya habíamos comentado a partir de los intervalos de confianza. En particular, el contenido en hierro explica significativamente la pérdida de peso a través del modelo lineal ajustado. 6.4 Bondad del Ajuste Cuando hemos realizado el ajuste de un modelo de regresión lineal, hemos de verificar que efectivamente dicho modelo proporciona un buen ajuste a la hora de explicar (predecir) la variable respuesta. Básicamente la bondad del ajuste la cuantificamos con el tanto por ciento de variabilidad de la respuesta, que consigue ser explicada por el modelo ajustado. Para ello contamos con varios tipos de medidas que cuantifican esta variabilidad de diversos modos. Como medidas fundamentales de bondad de ajuste contamos con: el error residual estimado \\(s = \\hat{\\sigma}\\); el test \\(F\\) de bondad de ajuste que se obtiene de la Tabla de Anova; el coeficiente de determinación \\(R^2\\). Todas estas medidas las desglosamos a continuación. Para obtenerlas con R utilizaremos las funciones glance(), anova() y summary(). 6.4.1 Error residual Es una medida de bondad del ajuste relativa a la escala de medida utilizada. En general, se prefieren modelos con menor error residual estimado \\(s\\), donde \\(s^2\\) denota la estimación de la varianza \\(\\sigma^2\\) del modelo, dada en el apartado @ref(rls_varmodel). 6.4.2 Tabla Anova Una medida de lo bueno que resulta un modelo para ajustar unos datos pasa por cuantificar cuánta de la variabilidad contenida en éstos ha conseguido ser explicada por dicho modelo. Un modelo es bueno si la variabilidad explicada es mucha, o lo que es lo mismo, si las diferencias entre los datos y las predicciones según el modelo son pequeñas. Construir la tabla de ANOVA o Análisis de la Varianza consiste en: descomponer la variabilidad de los datos en la parte que es explicada por el modelo y la parte que se deja sin explicar, es decir, la variabilidad de los residuos, compararlas y valorar estadísticamente si la variabilidad explicada por el modelo ajustado es suficientemente grande. Si partimos de la identidad: \\[\\begin{equation} y_i - \\bar{y} = (y_i - \\hat{y}_i) + (\\hat{y}_i - \\bar{y}) \\tag{6.9} \\end{equation}\\] y el hecho de que \\(\\sum_{i} (y_i - \\hat{y}_i)(\\hat{y}_i - \\bar{y}) = 0\\), podemos escribir: \\[\\begin{equation} \\underbrace{\\sum_{i=1}^n (y_i-\\bar{y})^2}_{SST} = \\underbrace{\\sum_{i=1}^n (y_i-\\hat{y}_i)^2}_{SSE} + \\underbrace{\\sum_{i=1}^n(\\hat{y}_i-\\bar{y})^2}_{SSR} \\tag{6.10} \\end{equation}\\] Las abreviaturas \\(SST\\), \\(SSE\\) y \\(SSR\\) provienen del inglés para suma de cuadrados (Sum of Squares): Total, debida al Error (o residual) y debida a la Regresión, respectivamente. A partir de ellas es posible calcular la variabilidad total, la variabilidad explicada por el modelo obtenido, y la variabilidad que queda por explicar o variabilidad residual, sin más que dividir las sumas de cuadrados por sus respectivos grados de libertad. Obtenemos así los cuadrados medios asociados, \\(MST=SST/(n-1)\\), \\(MSE=SSE/(n-2)\\) y \\(MSR=SSR/1\\). Contrastar la bondad del ajuste de la recta de regresión significa resolver el contraste: \\[\\begin{array}{cc} H_0:&amp; \\mbox{ el modelo lineal NO explica bien la respuesta} \\\\ H_1:&amp; \\mbox{ el modelo lineal explica bien la respuesta}, \\tag{6.11} \\end{array}\\] que, en el modelo RLS, resulta equivalente a contrastar \\(H_0:\\beta_1=0, \\ vs. \\ H_1:\\beta_1 \\neq 0\\), esto es, si la variable predictora \\(X\\) explica suficientemente bien la variable respuesta \\(Y\\) a través del modelo lineal propuesto. El estadístico de bondad de ajuste de la regresión está basado en comparar la variabilidad explicada por el modelo con la que queda sin explicar, esto es, en el cociente de las sumas de cuadrados medias \\(MSR\\) y \\(MSE\\), que resulta tener una distribución \\(F\\) con \\(1\\) y \\(n-2\\) grados de libertad cuando el modelo es correcto: \\[\\begin{equation} F=\\frac{SSR/\\sigma^2}{\\frac{SSE/\\sigma^2}{n-2}}=\\frac{MSR}{MSE} \\sim F_{1,n-2}. \\tag{6.12} \\end{equation}\\] En el modelo RLS, el estadístico \\(F\\) es igual al estadístico \\(t\\) asociado a \\(\\beta_1\\), elevado al cuadrado. Ya hemos dicho antes que el contraste de bondad de ajuste es equivalente al de \\(\\beta_1=0\\). Concluiremos que la recta de regresión es significativa para predecir la respuesta \\(Y\\) al nivel de confianza \\((1-\\alpha)100\\%\\), cuando el valor que obtenemos para el estadístico \\(F\\) supera el valor crítico que se corresponde con el cuantil \\(1-\\alpha\\) de una distribución \\(F\\) con \\(1\\) y \\(n-2\\) grados de libertad. Esto es equivalente a que el p-valor asociado al contraste resulte inferior a \\(\\alpha\\). En otro caso, diremos que no hemos obtenido evidencias suficientes para rechazar que el modelo lineal no es útil para predecir la variable \\(Y\\) a través de \\(X\\). Todas estas sumas de cuadrados y estadísticos se suelen presentar en una tabla de análisis de la variabilidad o tabla ANOVA, cuya apariencia es: Fuente gl SS MS estadístico \\(F\\) p-valor Regresión 1 \\(SSR\\) \\(MSR=\\frac{SSR}{1}\\) \\(F=\\frac{MSR}{MSE}\\) \\(Pr(F_{1,n-2}&gt;F)\\) Error \\(n-2\\) \\(SSE\\) \\(MSE=\\frac{SSE}{n-2}\\) Total \\(n-2\\) \\(S_{yy}\\) En R la \\(SSR\\) se descompone a su vez para cada uno de los efectos o variables predictoras en el modelo. 6.4.3 Coeficiente de determinación Otro estadístico útil para chequear la bondad del ajuste de la recta de regresión es el coeficiente de determinación \\(R^2\\). Éste se define como la proporción de la varianza que es explicada por la recta de regresión y se obtiene a partir de la descomposición (6.10) como: \\[\\begin{equation} R^2=\\frac{SSR}{SST}. \\tag{6.13} \\end{equation}\\] De hecho, en el modelo RLS, \\(R^2\\) es el cuadrado del coeficiente de regresión lineal entre la respuesta \\(Y\\) y el predictor \\(X\\). Puesto que \\(0\\leq R^2 \\leq 1\\) (al tratarse del coeficiente de correlación al cuadrado), un valor cercano a \\(1\\) (entre 0.6 y 1) implicará que buena parte de la varianza es explicada por la recta de regresión, y \\(R^2\\approx 0\\) significará que prácticamente toda la variabilidad de los datos queda sin explicar por la recta. Sin embargo, \\(R^2\\) no sirve para medir la idoneidad del modelo de regresión para describir los datos. De hecho, \\(R^2\\) puede resultar grande a pesar de que la relación entre \\(X\\) e \\(Y\\) no sea lineal (de hecho tiene la misma interpretación que un coeficiente de correlación, válido para cuantificar la relación lineal sólo cuando ésta existe). Siempre ha de ser utilizado con cautela. Así por ejemplo, la magnitud de \\(R^2\\) depende del rango de variabilidad de la variable explicativa. Cuando el modelo de regresión es adecuado, la magnitud de \\(R^2\\) aumenta (o disminuye) cuando lo hace la dispersión de \\(X\\). Por otro lado, podemos obtener un valor muy pequeño de \\(R^2\\) debido a que el rango de variación de \\(X\\) es demasiado pequeño, y entonces impedirá que se detecte su relación con \\(Y\\). 6.4.4 Ejemplo Analizamos la bondad del ajuste obtenido para los datos de corrosión. # Medidas de bondad del ajuste glance(fit) Tabla 6.3: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.970.9673.063521.06e-091-31.969.871.51031113 Esta función proporciona diferentes medidas de bondad de ajuste, algunas de ellas las utilizaremos en las unidades siguientes, pero en este caso nos centramos en las que hace referencia al modelo de RLS: r.squared: \\(R^2\\) del modelo ajustado, sigma: error residual, statistic: valor del estadístico de contraste (6.12) asociado a la tabla ANOVA, p.value: p-valor del contraste (6.12), df: grados de libertad asociados con \\(MSR\\), df.residual: grados de libertad asociados con \\(MSE\\). Para este modelo el error residual tiene una magnitud de 3.05778, pero dado que no podemos comparar con otro modelo resulta difícil interpretar este valor como una medida de bondad de ajuste al no tener una escala de medida que nos indique si este valor es lo suficientemente pequeño. El valor del estadístico F (352.27) y su p-valor (1.055e-09) nos permiten concluir que podemos rechazar la hipótesis \\(H_0:\\beta_1=0\\), o lo que es lo mismo, \\(H_0\\): el modelo no explica los datos, a favor de que el contenido en hierro resulta útil para predecir el la pérdida de peso debido a la corrosión a través de un modelo de regresión lineal. Veamos la descomposición de la tabla ANOVA. anova(fit) Tabla 6.4: DfSum SqMean SqF valuePr(&gt;F) 13.29e+033.29e+033521.06e-09 11103&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Simplemente observando la Tabla de Anova, vemos que la variabilidad explicada por la recta (en términos de sumas de cuadrados), \\(SSR = 3293.8\\), es superior a la que queda por explicar, \\(SSE = 102.9\\) (casi tres veces superior). En este caso, al tener una única variable en el modelo la \\(SSR\\) coincide con la correspondiente a la variable hierro tal y como aparece en la tabla anterior. A la vista de estos resultados podemos concluir que efectivamente el modelo obtenido resulta útil para explicar la mayor parte de la variabilidad existente en la respuesta a partir de la variabilidad explicada por dicho modelo. Por último, el valor del coeficiente de determinación es \\(R^2= 0.9697198\\), lo que implica que alrededor del \\(97\\%\\) de la variabilidad de la pérdida de peso es explicada por la recta ajustada. Es un valor especialmente alto que refleja el gran poder predictivo del contenido de hierro para tratar de conocer la pérdida de peso final del compuesto. Una versión resumida de las características del modelo ajustado se puede obtener con la función summary(). Con ella podemos obtener la ecuación del modelo, contrastes individuales sobre cada coeficiente, la varianza residual y el test F asociado. Los criterios utilizados nos permiten concluir que el modelo obtenido es adecuado desde el punto de vista de su capacidad explicativa, es decir, a la hora de medir la asociación entre la respuesta y la predictora. Sin embargo, es importante tener presente los pasos que hemos de dar a la hora de aceptar finalmente un modelo como bueno. No sólo es preciso superar la bondad del ajuste. Una vez superada esta prueba, hay que llevar a cabo el diagnóstico y validación del modelo, o verificación de las hipótesis del modelo RLS y de la capacidad predictiva del mismo. De entre todos los modelos propuestos para predecir una respuesta \\(Y\\) que hayan superado la bondad del ajuste, el diagnóstico y la validación, podremos optar por el mejor según algún criterio preferido de comparación y selección de modelos. En los modelos de RLS esta tarea es sencilla ya que el modelo ajustado es único, pero se complicará cuando se añadan más variables predictoras como veremos en las unidades siguientes. 6.5 Diagnóstico del Modelo Una vez ajustado un modelo y habiendo superado las pruebas de bondad de ajuste pertinentes (fundamentalmente el test \\(F\\) de Anova), hemos de proceder con el diagnóstico del modelo, que consiste en verificar si éste satisface las hipótesis básicas del modelo de regresión, que son: linealidad entre las variables \\(X\\) e \\(Y\\) \\[\\begin{array}{ll} H_{0}: &amp; Linealidad\\\\ H_{1}: &amp; No\\ linealidad \\tag{6.14} \\end{array}\\] para los errores del modelo, \\(\\epsilon_{i}\\): media cero varianza constante u homocedasticidad \\[\\begin{array}{ll} H_{0}: &amp; Varianza\\ constante\\\\ H_{1}: &amp; Varianza\\ no\\ constante \\tag{6.15} \\end{array}\\] Si rechazamos la hipótesis nula estaremos concluyendo que nuestro modelo incumple la hipótesis de varianza constante. incorrelación \\[\\begin{array}{ll} H_{0}: &amp; Residuos\\ no\\ correlados \\\\ H_{1}: &amp; Residuos\\ correlados \\tag{6.16} \\end{array}\\] normalidad \\[\\begin{array}{ll} H_{0}: &amp; Residuos\\ normales\\\\ H_{1}: &amp; Residuos\\ no\\ normales \\tag{6.17} \\end{array}\\] El análisis de los residuos del modelo nos permitirá detectar deficiencias en la verificación de estas hipótesis, así como descubrir observaciones anómalas o especialmente influyentes en el ajuste. Una vez encontradas las deficiencias, si existen, cabrá considerar el replanteamiento del modelo, bien empleando transformaciones de las variables, bien proponiendo modelos alternativos al de RLS, que trataremos con detalle en las unidades siguientes. El diagnóstico del modelo se lleva a cabo fundamentalmente a partir de la inspección de los residuos del modelo. Éstos sólo son buenos estimadores de los errores cuando el modelo ajustado es bueno. Aun así, es lo más aproximado con lo que contamos para indagar qué ocurre con los errores y si éstos satisfacen las hipótesis del modelo. El análisis de los residuos habitual es básicamente gráfico, si bien existen varios tests estadísticos útiles para detectar inadecuaciones del modelo, que presentaremos brevemente. Definimos los residuos de un modelo lineal como las desviaciones entre las observaciones y los valores ajustados: \\[ r_i = y_i - \\hat{y}_i, \\qquad i=1,\\ldots,n. \\] En ocasiones, es preferible trabajar con los residuos estandarizados, que tienen media cero y varianza aproximadamente unidad, y facilitan la visualización de las hipótesis: \\[ d_i = \\frac{r_i}{\\sqrt{MSE}}, \\qquad i=1,\\ldots,n. \\] Los residuos asociados a un modelo ajustado se pueden obtener con la función fortify(). Esta función proporciona además las medidas de influencia para detectar observaciones anómalas, es decir, observaciones con residuos excesivamente grandes. 6.5.1 Linealidad y homocedasticidad. Los gráficos de residuos estandarizados frente a valores ajustados nos permiten detectar varios tipos de deficiencias del modelo ajustado. Si los residuos están distribuidos alrededor del cero y el gráfico no presenta ninguna tendencia entonces el modelo se considera adecuado. Cuando aparece alguna tendencia como una forma de embudo o un abombamiento, etc., podemos tener algún problema con la hipótesis de varianza constante para los errores (heterocedasticidad). Cuando se aprecia alguna tendencia hablamos de violación de la hipótesis de linealidad: el modelo lineal ha sido incapaz de capturar una tendencia no lineal apreciada en los residuos, posiblemente debido a que existen otras variables explicativas adicionales no consideradas en el modelo, o a que la variable predictora explica la respuesta de un modo más complejo (quizás polinómico, etc.) al considerado en el modelo lineal. Para verificar la hipótesis de homocedasticidad podemos usar el test de Breusch-Pagan para variables predictoras de tipo numérico, y el de Bartlett para variables predictoras de tipo categórico (ver unidades siguientes). Para realizar el test de Breusch-Pagan utilizamos la función bptest() de la librería lmtest, mientras que para realizar el test de Bartlett utilizamos la función bartlett.test(). 6.5.2 Ejemplo Analizamos la hipótesis de homocedasticidad para el modelo obtenido para los datos de corrosión. En primer lugar obtenemos los residuos del modelo. # Residuos y medidas de diagnóstico diagnostico &lt;- fortify(fit) # Gráfico de residuos estandarizados vs ajustados ggplot(diagnostico, aes(x = .fitted, y = .stdresid)) + geom_point() + stat_smooth(method = &quot;lm&quot;, se = FALSE) + theme_bw() Figura 6.5: Gráfico de residuos estandarizados vs valores ajustados. Se puede concluir que se verifica la hipótesis de linealidad (recta horizontal), ya que no existen tendencias en los residuos. Además con los residuos se comportan de forma aleatoria sin agrupaciones ni tendencias podemos concluir que se cumple la hipótesis de homogeneidad de varianzas. Hay que tener mucho cuidad con la interpretación de estos gráficos, ya que cuando el tamaño de muestra es pequeño, resulta difícil apreciar tenencias o agrupaciones en los residuos. Por este motivo realizamos el test de diagnóstico. # Test de diagnóstico bptest(fit) ## ## studentized Breusch-Pagan test ## ## data: fit ## BP = 0.024539, df = 1, p-value = 0.8755 Dado que el p-valor del contraste es superior a 0.05 no podemos rechazar la hipótesis nula dada en (6.15), y por tanto podemos concluir que se verifica la hipótesis de homogeneidad o varianza constante. 6.5.3 Normalidad Para verificar la normalidad de los errores, disponemos de gráficos qq-plot de normalidad, en los que se representan los residuos ordenados \\(r_{[i]}\\) (cuantiles empíricos) versus los cuantiles correspondientes a una normal estándar, \\(\\Phi^{-1}[(i-1)/n]\\). Si es cierta la normalidad de los residuos, los puntos han de estar alineados con la diagonal. Desviaciones de la diagonal más o menos severas en las colas, e incluso en el centro de la distribución, dan indicios de desviaciones de normalidad. La hipótesis de normalidad se puede chequear también con histogramas de los residuos cuando el tamaño muestral es grande. Los residuos estandarizados también son útiles para detectar desviaciones de la normalidad. Si los errores se distribuyen según una normal, entonces aproximadamente el \\(68\\%\\) de los residuos estandarizados quedarán entre \\(-1\\) y \\(+1\\), y el \\(95\\%\\) entre \\(-2\\) y \\(+2\\). Para diagnosticar la hipótesis de normalidad se utiliza el test de Shapiro-Wilks, donde rechazar la hipótesis nula implica el rechazo de la hipótesis de normalidad. Para realizar dicho contraste utilizamos la función shapiro.test(). # grafico qq ggplot(diagnostico, aes(sample = .stdresid)) + stat_qq() + geom_abline() + theme_bw() (#fig:rls011, )Gráfico de normalidad de los residuos estandarizados. El gráfico de normalidad muestra un comportamiento correcto ya que los punto se distribuyen a lo largo de la recta de normalidad. No se realiza el histograma ya que el tamaño muestral es demasiado pequeño. Pasamos al test de diagnóstico. # Test de diagnóstico shapiro.test(diagnostico$.stdresid) ## ## Shapiro-Wilk normality test ## ## data: diagnostico$.stdresid ## W = 0.92905, p-value = 0.3312 Dado que el p-valor del contraste es superior a 0.05 no podemos rechazar la hipótesis nula dada en (6.17), y por tanto podemos considerar que los residuos se distribuyen normalmente. 6.5.4 Independencia. La correlación entre los datos es un proceso intrínseco al muestreo; saber cómo se ha llevado a cabo éste da información, generalmente suficiente, para poder hablar de correlación o incorrelación. En todo caso, los gráficos secuenciales de residuos sirven para detectar problemas de correlación de éstos (autocorrelación), o de inestabilidad de la varianza a lo largo del tiempo. También son útiles para esto los gráficos en que se representa un residuo versus el anterior en la secuencia en que han sido observados; si hay correlación se apreciará tendencia. Detectar autocorrelación llevará a considerar otro tipo de modelos distintos (autocorrelados: modelos de series temporales). Aparte de los métodos gráficos, para resolver dicho contraste se utiliza el test de Durbin-Watson, cuya función es dwtest(). Rechazar la hipótesis nula implica el rechazo de la hipótesis de incorrelación. # grafico función autocorrelación acf(diagnostico$.stdresid) (#fig:rls013, )Gráfico de autocorrelación de los residuos estandarizados. El gráfico de la función de autocorrelación muestra la independencia de las observaciones. Todos los lags quedan dentro del rango de independencia. # Test de diagnóstico dwtest(fit, alternative = &quot;two.sided&quot;) ## ## Durbin-Watson test ## ## data: fit ## DW = 2.5348, p-value = 0.2952 ## alternative hypothesis: true autocorrelation is not 0 Dado que el p-valor del contraste es superior a 0.05 no podemos rechazar la hipótesis nula dada en (6.16), y por tanto podemos considerar que los residuos se distribuyen de froma independiente. 6.5.5 Otros gráficos de diagnóstico Los gráficos de residuos versus valores de la variable predictora son útiles para apreciar tendencias en los residuos que han quedado sin explicar por el modelo ajustado. Básicamente se interpretan como los gráficos de residuos versus valores ajustados \\(\\hat{y}_i\\). Es deseable que los residuos aparezcan representados en una banda horizontal sin tendencias alrededor del cero. Por ejemplo, si hay tendencias de tipo cuadrático, posiblemente hayamos de incorporar la variable \\(x^2\\) en el modelo, o bien abordar algún tipo de transformación que permita una relación de tipo lineal entre predictor y respuesta. 6.5.6 Incumplimiento de hipótesis Una vez identificado el incumplimiento de alguna de las hipótesis del modelo, hay que tratar de identificar porque se produce dicho incumplimiento. Se estudia si el incumplimiento es debido a: Subconjunto de los datos que influye desproporcionadamente en el ajuste del modelo propuesto, con lo cual las estimaciones y predicciones dependen mucho de él. En primer lugar, el objetivo es identificar dichas observaciones. Una vez detectadas la forma de proceder es la siguiente: Comprobar si la influencia se debe a un error en la toma de observaciones, si es así se corrigen los defectos encontrados y se comienza de nuevo. Si los datos son correctos y el subconjunto de influyentes es pequeño se opta casi siempre por su eliminación del banco de datos. En otras ocasiones se puede optar por estudiar de forma separada a dichas observaciones. Comportamiento sistemático del modelo. Este caso es más complicado y requiere de procedimientos más sofisticados para corregir los defectos que aparezcan en el modelo. De la primera parte se encarga de analizarla los diagnósticos de influencia, mientras que en el segundo caso se trata principalmente de realizar transformaciones de las variables involucradas en el modelo. 6.5.7 Análisis de influencia El análisis de influencia pretende detectar aquellas observaciones cuya inclusión/exclusión en el ajuste altera sustancialmente los resultados. Es interesante siempre, localizar este tipo de datos, si existen, y evaluar su impacto en el modelo. Si estos datos influyentes son “malos” (provienen de errores en la medición, o de condiciones de experimentación diferentes, etc.) habrían de ser excluidos del ajuste; si son “buenos,” contendrán información sobre ciertas características relevantes a considerar en el ajuste. A primera vista, observaciones que dan lugar a un residuo grande, pueden influir notablemente en el ajuste. Las denominaremos OBSERVACIONES ALEJADAS. Su existencia puede indicar también la inadecuación del modelo asumido a la realidad experimental. Si dicha observación tiene un residuo exageradamente grande la denominamos ANÓMALA (outlier en inglés). Por otra parte, observaciones que adoptan valores extremos de alguna o varias variables explicativas pueden tener más influencia que las usuales. Las denominaremos OBSERVACIONES ATÍPICAS. Sin embargo, las dos características no siempre suponen que las observaciones que las manifiestan sean también influyentes. Generalmente se dice que una observación es alejada si el valor absoluto del residuo es mayor que 2. Se considera anómala si el valor absoluto del residuo es mayor que 3. Un criterio para valora la influencia de una observación sobre los coeficientes del modelo es el cálculo de la distancia de CooK. Se consideran como observaciones influyentes todas aquellas cuyo valor de la distancia sea mayor que 1. Dicha distancia se obtiene directamente con la función fortify(modelo) en al columna denominada .cooksd. Existen otro tipo de medidas de influencia (se pueden obtener con la función influence.measures(ajuste)) pero las estudiaremos en las unidades siguientes. Si el incumplimiento de las hipótesis no es debido a la presencia de observaciones influyentes, sino más bien a un comportamiento sistemático del modelo, los remedios para corregir estas deficiencias pasan principalmente por: Propuesta de otros modelos adecuados a la distribución de la respuesta y su relación con los predictores. Este punto o trataremos ampliamente más adelante Transformar la variable respuesta (si es de tipo continuo), o las variables predictoras (si son de tipo continuo). 6.5.8 Transformaciones El tipo de transformaciones que podemos realizar se pueden dividir en tres apartados: Transformaciones debidas al modelo teórico. Existen situaciones experimentales donde ya partimos de un tipo de modelo de carácter no lineal pero que se podría convertir en lineal con una sencilla transformación de la respuesta o la predictora, o de ambas. Ejemplos de estos modelos teóricos que se pueden convertir en modelos de RLS son: Modelo Teórico Transformación y modelo a plantear \\(Y = \\beta_0 X^{\\beta_1}\\) \\(log(Y) \\sim log(X)\\) \\(Y = \\beta_0 exp^{\\beta_1 X}\\) \\(log(Y) \\sim X\\) \\(Y = \\beta_0 + \\beta_1 log(X)\\) \\(Y \\sim log(X)\\) \\(Y = \\frac{X}{\\beta_0 + \\beta_1 X}\\) \\(1/Y \\sim 1/X\\) \\(Y = \\frac{1}{\\beta_0 + \\beta_1 X}\\) \\(1/Y \\sim X\\) \\(Y = \\beta_0 + \\beta_1 \\frac{1}{X}\\) \\(Y \\sim 1/X\\) Transformaciones sobre la predictora. Se utilizan principalmente ante la falta de linealidad, y se basan principalmente en la construcción de modelos de predicción polinómicos. Estos modelos los estudiaremos con más detalle en la unidad siguiente. Transformaciones sobre la respuesta. Esta suele ser la opción más habitual. Obtener una transformación adecuada de la respuesta sin alterar las variables predictoras. Se suelen utilizar ante el incumplimiento de las hipótesis de normalidad o varianza constante. Como buscar una transformación adecuada es un tema que puede resulta costoso, se utilizar un procedimiento automático que nos da una transformación rápida. Dicho procedimiento se conoce con el nombre de transformaciones de Box-Cox, y sde puede obtener en R con la función boxcox(). Dicho procedimiento consiste en obtener un intervalo de confianza para un parámetro (\\(\\lambda\\)) que refleja la transformación de la respuesta a utilizar. Las transformaciones más habituales son: \\(\\lambda\\) Transformación -2 \\(1/Y^2\\) -1 \\(1/Y\\) -1/2 \\(1/\\sqrt{Y}\\) 0 \\(log(Y)\\) 1/2 \\(\\sqrt{Y}\\) 1 \\(Y\\) 2 \\(Y^2\\) Una vez realizado el estudio de influencia la forma de proceder consiste en eliminar las observaciones influyentes y obtener un nuevo modelo sin ellas, o bien realizar alguna de las transformaciones planteadas y ajustar el nuevo modelo. Una vez construido deberemos ajustar el nuevo modelo y realizar un nuevo diagnóstico para verificar que se cumple las hipótesis. Se trata pues de un proceso circular donde a cada modificación debemos obtener un nuevo modelo y analizarlo completamente hasta llegar a un modelo que cumpla con todas las especificaciones. Sin embargo, en ocasiones puede ocurrir que no seamos capaces de encontrar un modelo que cumpla las hipótesis y deberemos buscar entre modelos más complejos de los planteados aquí. 6.5.9 Ejemplos Procedemos con el análisis de los bancos de datos de Papel y Viscosidad presentados al inicio de esta unidad para estudiar los posibles problemas de diagnóstico que hemos venido trabajando. 6.5.9.1 Papel Planteamos y ajustamos el modelo correspondiente a los datos de Papel. # Ajuste del modelo fit.papel &lt;- lm(tension ~ madera, data = papel) # Solución con glm_coef glm_coef(fit.papel) Tabla 6.5: ParameterCoefficientPr(&gt;|t|) (Intercept)21.32 (9.86, 32.78)0.001 madera1.77 (0.4, 3.14)0.014 # Gráfico del ajuste plot_model(fit.papel, &quot;pred&quot;, terms = ~madera, ci.lvl = NA, show.data = TRUE, axis.title = c(&quot;Concentración de madera&quot;, &quot;Tensión del papel&quot;), title = &quot; &quot;) Figura 6.6: Ajuste para los datos de resitencia del papel Parece obvio que el modelo planteado no es adecuado, ya que no captura de forma adecuada la tendencia de los datos observados. De hecho, el coeficiente asociado con madera resulta no significativo, lo que daría a entender que la concentración de madera no es relevante para explicar la tensión del papel. Esta afirmación es claramente falsa ya que se aprecia claramente una tendencia de tipo cuadrático. Realizamos los gráficos de diagnóstico para corroborar este hecho. # Obtenemos los residuos del modelo diganostico.papel &lt;- fortify(fit.papel) # Gráfico de residuos vs ajustados ggplot(diganostico.papel, aes(x = .fitted, y = .stdresid)) + geom_point() + theme_bw() Figura 6.7: Gráfico de residuos vs ajustados para el modelo de papel Se observa claramente una tendencia de tipo cuadrática en los residuos lo que indica que un modelo más adecuado para estos datos sería: \\[tension \\sim madera + madera^2\\] Realizamos el análisis de influencia para completar el diagnóstico, a pesar de que la introducción de la nueva pedictora proporcionará un modelo más adecuado. # Valoramos si hay alguna observación con distancia mayor que 1 abs(diganostico.papel$.cooksd) &gt; 1 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE No se observa ninguna observación influyente por lo que el problema de ajuste se debe a la falta de tendencia del modelo propuesto. 6.5.9.2 Viscosidad Planteamos y ajustamos el modelo correspondiente a los datos de Viscosidad. # Ajuste del modelo fit.aceite &lt;- lm(viscosidad ~ aceite, data = aceites) # Solución con glm_coef glm_coef(fit.aceite) Tabla 6.6: ParameterCoefficientPr(&gt;|t|) (Intercept)6.32 (-12.9, 25.53)0.502 aceite1.47 (0.95, 1.99)&lt; 0.001 # Gráfico del ajuste plot_model(fit.aceite,&quot;pred&quot;, terms = ~aceite, ci.lvl = NA, show.data = TRUE, axis.title = c(&quot;Cantidad de aceite&quot;, &quot;Viscosidad&quot;), title = &quot; &quot;) Figura 6.8: Ajuste para los datos de viscosidad El modelo ajustado indica que la cantidad de aceite puede explicar la viscosidad final (p-valor significativo), de forma que por cada unidad que aumentamos la cantidad de aceite la viscosidad aumenta en 1.47 unidades. El modelo obtenido viene dado por: \\[ \\widehat{\\text{viscosidad}} = 6.32 + 1.47*\\text{aceite} \\] Estudiamos la capacidad explicativa del modelo: glance(fit.aceite) Tabla 6.7: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.6240.60623.834.97.31e-061-1042152181.19e+042123 El \\(R^2\\) nos indica que el 62.4% de la variabilidad viene explicada por el modelo. Además el p-valor asociado a la tabla ANOVA resulta significativo indicando que el modelo tiene capacidad explicativa, es decir, podemos utilizar la cantidad de aceite para conocer el grado de viscosidad. Pasamos al diagnóstico del modelo. diagnostico.aceite &lt;- fortify(fit.aceite) En este cao utilizamos los tests estadísticos en lugar de los gráficos para concluir sobre el diagnóstico: # Varianza constante bptest(fit.aceite) ## ## studentized Breusch-Pagan test ## ## data: fit.aceite ## BP = 6.0786, df = 1, p-value = 0.01368 # Normalidad shapiro.test(diagnostico.aceite$.stdresid) ## ## Shapiro-Wilk normality test ## ## data: diagnostico.aceite$.stdresid ## W = 0.95818, p-value = 0.4276 # Independencia dwtest(fit.aceite) ## ## Durbin-Watson test ## ## data: fit.aceite ## DW = 0.51202, p-value = 5.084e-06 ## alternative hypothesis: true autocorrelation is greater than 0 Como se puede ver debemos rechazar las hipótesis de varianza constante y de independencia (p-valores inferiores a 0.05). Planteamos la familia de transformaciones de Box-Cox para tratar de corregir los problemas con las hipótesis del modelo: boxcox(fit.aceite) El intervalo de confianza al 95% para \\(\\lambda\\) incluye el valor de \\(\\lambda = 0\\), de forma que podríamos utilizar la transformación logaritmo para tratar de corregir los defectos encontrados en el modelo propuesto inicialmente. # Calculamos la nueva variable aceites &lt;- aceites %&gt;% mutate(lviscosidad = log(viscosidad)) # Ajuste el nuevo modelo fit.aceite2 &lt;- lm(lviscosidad ~ aceite, data = aceites) # Solución con glm_coef glm_coef(fit.aceite2) Tabla 6.8: ParameterCoefficientPr(&gt;|t|) (Intercept)2.81 (2.52, 3.1)&lt; 0.001 aceite0.03 (0.02, 0.04)&lt; 0.001 # Gráfico del ajuste plot_model(fit.aceite2,&quot;pred&quot;, terms = ~aceite, ci.lvl = NA, show.data = TRUE, axis.title = c(&quot;Cantidad de aceite&quot;, &quot;log(Viscosidad)&quot;), title = &quot; &quot;) El modelo resulta significativo con ecuación dada por: \\[ \\widehat{\\text{lviscosidad}} = 2.81 + 0.03*\\text{aceite} \\] La bondad del ajuste glance(fit.aceite2) Tabla 6.9: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.7380.7260.36359.31.52e-071-8.3122.6262.772123 nos da una capacidad explicativa del 73.8%. Hemos mejorado nuestra capacidad explicativa al transformar la respuesta. Por último realizamos el diagnóstico del nuevo modelo: diagnostico.aceite2 &lt;- fortify(fit.aceite2) # Varianza constante bptest(fit.aceite2) ## ## studentized Breusch-Pagan test ## ## data: fit.aceite2 ## BP = 0.39756, df = 1, p-value = 0.5284 # Normalidad shapiro.test(diagnostico.aceite2$.stdresid) ## ## Shapiro-Wilk normality test ## ## data: diagnostico.aceite2$.stdresid ## W = 0.92282, p-value = 0.07659 # Independencia dwtest(fit.aceite2) ## ## Durbin-Watson test ## ## data: fit.aceite2 ## DW = 0.24384, p-value = 6.044e-10 ## alternative hypothesis: true autocorrelation is greater than 0 El modelo verifica las hipótesis de varianza constante y normalidad. la hipótesis de independencia resulta significativa debido a la propia estructura de los datos, y más concretamente de la variable predictora, ya que como se puede ver solo se dan ciertos valores específicos (como si se tratara de una variable categórica más que una numérica). Podemos verificar este hecho con el gráfico de autocorrelación: # gráfico función autocorrelación acf(diagnostico.aceite2$.stdresid) Figura 6.9: Gráfico de autocorrelación de los residuos estandarizados. En esta situación este incumplimiento no resulta concluyente y podemos utilizar el modelo construido para establecer una relación entre la cantidad de aceite y el logaritmo de la viscosidad. 6.6 Predicción del modelo Una vez obtenido un modelo definitivo, la última fase de la modelización consiste en la predicción de la respuesta a partir de un nuevo conjunto de valores de la predictora o predictoras. Básicamente se trata de utilizar valores dentro del rango de la variable predictora para conocer el valor de la respuesta sin necesidad de realizar el diseño experimental. Una vez ajustado el modelo si consideramos una observación \\(X = x_0\\) dentro del rango de valores de \\(X\\) la predicción de la respuesta se puede obtener a través del modelo ajustado mediante: \\[y_0 = \\widehat{\\beta_0} + \\widehat{\\beta_1} x_0.\\] Esto nos proporciona una estimación puntual del valor predicho, pero sin embargo es necesario proporcionar un intervalo de confianza para dicho valor para tener en cuenta la variabilidad observada en el modelo propuesto. Existen dos posibilidades de predicción en este sentido: Predicción del valor medio de la respuesta. Se trata de predecir el valor medio de la respuesta para un valor especifico de la variable predictora (\\(X = x_0\\)). Esta es la herramienta de predicción habitual ya que tiene una menor variabilidad. La idea es que para un mismo valor de \\(X = x_0\\) obtendremos diferentes valores predichos de la respuesta, y por tanto, más que interesarnos la predicción de la respuesta, nos centramos en predecir la media de todos esos posibles valores de la respuesta. Predicción del valor de la respuesta. Se trata de predecir el valor de la respuesta para un valor especifico de la variable predictora (\\(X = x_0\\)). Dado que estamos intentando predecir un único valor y no la media de un conjunto de valores el intervalo de confianza de predicción es mayor que en el caso anterior. Tenemos más variabilidad cuando queremos predecir un valor que cuando queremos predecir la media de un conjunto de valores. Utilizaremos la función predict() para construir la predicción para un modelo dado. Veremos su aplicación en los diferentes ejemplos. 6.6.1 Respuesta media Como ya hemos indicado resulta posible obtener una estimación puntual del valor de la respuesta media a través de: \\[\\begin{equation} \\hat{y}_{x_0} = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_0. \\tag{6.18} \\end{equation}\\] para un \\(X = x_0\\) dado. Un intervalo de confianza para la estimación del valor esperado de la respuesta para un \\(X = x_0\\) dado es: \\[\\begin{equation} IC(E(\\bar{y}_n \\mid x_0);1-\\alpha) = \\hat{y}_{x_0} \\pm t_{(n-2,1-\\frac{\\alpha}{2})} \\ s \\sqrt{\\frac{1}{n} + \\frac{(x_0 - \\bar{x})^2}{S_{xx}}}. \\tag{6.19} \\end{equation}\\] 6.6.2 Nueva observación Predeciremos una futura observación de la variable \\(Y\\) para cierto valor de \\(X = x_0\\), con \\[\\begin{equation} \\hat{y}_{x_0}=\\hat{\\beta}_0 + \\hat{\\beta}_1 x_0 = \\bar{y} + \\hat{\\beta}_1 (x_0 - \\bar{x}), \\tag{6.20} \\end{equation}\\] y el intervalo de confianza vendrá dado por: \\[\\begin{equation} IC(y_{x_0};1-\\alpha) = \\hat{y}_{x_0} \\pm t_{\\left(n-2,1-\\frac{\\alpha}{2}\\right)} \\ s \\ \\sqrt{1+\\frac{1}{n} + \\frac{(x_0-\\bar{x})^2}{S_{xx}}} \\tag{6.21} \\end{equation}\\] Notar que tanto la estimación de la respuesta media como la predicción coinciden, aunque difieren en cuanto al grado de incertidumbre de la misma. Como es de esperar, predecir un hecho puntual en el futuro conlleva más incertidumbre que estimar en términos medios qué va a a ocurrir. Por último, comentar que cuando hemos utilizado alguna transformación (monótona) sobre la respuesta y queremos recuperar la estimación o predicción de ésta en su escala original, basta con utilizar la transformación recíproca sobre el valor predicho para obtener la predicción en la escala original. 6.6.3 Ejemplos Dado que la estimación puntual de la predicción coincide con el modelo ajustado, ya hemos mostrado anteriormente como representar gráficamente la ecuación del modelo o predicción de la respuesta en diferentes ejemplos. En este punto nos limitamos a mostrar como obtener y representar los intervalos de confianza asociados, y como obtener la predicción para un conjunto determinado de valores de la variable predictora. 6.6.3.1 Corrosión En primer lugar recuperamos los datos y modelo obtenido para los datos de corrosión. Estamos interesados en conocer la pérdida de peso medio (estimación de la media) y la pérdida de peso específica (predicción de una futura observación) para una barra en particular cuando el contenido en hierro es de 0.5, 1, y 1.5. # cargamos datos de predicción newpred &lt;- data.frame(hierro = c(0.5, 1, 0.5)) # Predicción para la media de la respuesta # Opción interval = &quot;confidence&quot; newdata &lt;- data.frame(newpred, predict(fit, newpred, interval = &quot;confidence&quot;)) round(newdata, 2) Tabla 6.10: hierrofitlwrupr 0.5118116120 1&nbsp;&nbsp;106104108 0.5118116120 Hemos obtenido la estimación (fit) e intervalo de confianza ((lwr,upr)) al 95% de la predicción de la pérdida de peso medio para valores específicos de contenido de hierro. # cargamos datos de predicción newpred &lt;- data.frame(hierro = c(0.5, 1, 0.5)) # Predicción de un único valor # Opción interval = &quot;prediction&quot; newdata &lt;- data.frame(newpred, predict(fit, newpred, interval = &quot;prediction&quot;)) round(newdata, 2) Tabla 6.11: hierrofitlwrupr 0.5118111&nbsp;&nbsp;125 1&nbsp;&nbsp;10698.8113 0.5118111&nbsp;&nbsp;125 Como ya habíamos comentado la estimación que obtenemos es la misma pero los intervalos de confianza son más amplios. A continuación se muestra como representar gráficamente la predicción de la respuesta media y los intervalos de predicción al 95% de confianza para todo el rango de valores de la predictora. # Gráfico del ajuste plot_model(fit, &quot;pred&quot;, terms = ~hierro, ci.lvl = 0.95, show.data = TRUE, axis.title = c(&quot;Contenido en hierro&quot;, &quot;Peso&quot;), title = &quot; &quot;) Figura 6.10: Predicción para los datos de corrosión (media e IC95%). 6.6.3.2 Viscosidad Vamos a realizar la predicción para el modelo ajustado a los datos de viscosidad. Recordemos que en este caso hemos transformado la respuesta con la función logaritmo para asegurar que se cumple las hipótesis del modelo, y por tanto nuestra predicción inicial es sobre dicha variable y no sobre la viscosidad. Resulta necesario deshacer la transformación logaritmo para poder obtener la predicción en la escala original de la viscosidad. Estamos interesados en conocer la viscosidad media (estimación de la media) del producto final cuando el contenido de aceite es de 10, 20, 30, 40, y 50. # cargamos datos de predicción newpred &lt;- data.frame(aceite = c(10, 20, 30, 40, 50)) # Predicción para la media de la respuesta # Opción interval = &quot;confidence&quot; newdata &lt;- data.frame(newpred, predict(fit.aceite2, newpred, interval = &quot;confidence&quot;)) round(newdata, 2) Tabla 6.12: aceitefitlwrupr 103.1&nbsp;2.873.33 203.4&nbsp;3.213.58 303.693.533.85 403.983.814.15 504.274.064.49 # Deshacemos la transformación para volver a la escala de viscosidad newdata[,2:4] &lt;- exp(newdata[,2:4]) round(newdata,2) Tabla 6.13: aceitefitlwrupr 1022.317.728.1 2029.824.935.8 3040&nbsp;&nbsp;34.146.8 4053.645.163.6 5071.857.989.1 De esta forma obtenemos las predicciones en la escala original de la variable viscosidad. ¿Cómo interpretamos los valores de predicción obtenidos? Realizamos ahora los gráficos de predicción para log(viscosidad) y viscosidad. Para este último introducimos el código necesario para deshacer la transformación. # Gráfico del ajuste plot_model(fit.aceite2, &quot;pred&quot;, terms = ~aceite, ci.lvl = 0.95, show.data = TRUE, axis.title = c(&quot;Contenido de aceite&quot;, &quot;log(Viscosidad)&quot;), title = &quot; &quot;) Figura 6.11: Predicción para los datos de log(viscosidad) (media e IC95%). # Construímos una secuencia de predicción newdata &lt;- data.frame(aceite = seq(min(aceites$aceite), max(aceites$aceite), length = 50)) # Predicción para la media de la respuesta newdata &lt;- data.frame(newdata, predict(fit.aceite2, newdata, interval = &quot;confidence&quot;)) # Deshacemos la transformación para volver a la escala de viscosidad newdata[,2:4] &lt;- exp(newdata[,2:4]) # Gráfico del ajuste ggplot(newdata, aes(x = aceite, y = fit)) + geom_line() + geom_ribbon(aes(ymax = upr, ymin = lwr), alpha = 1/5) + geom_point(data = aceites, aes(x = aceite, y = viscosidad)) + labs(x = &quot;Cantidad de aceite&quot;, y = &quot;Viscosidad&quot;) + theme_bw() Figura 6.12: Predicción para los datos de viscosidad (media e IC95%). En este segundo gráfico se puede ver el efecto de la transformación propuesta. De hecho, la predicción obtenida captura la tendencia observada en los datos originales. "],["rlm.html", "Unidad 7 Regresión Lineal Múltiple y Polinómica 7.1 Tipos de modelos 7.2 Estimación e inferencia 7.3 Bondad del ajuste 7.4 Comparación y selección de modelos 7.5 Multicolinealidad 7.6 Diagnóstico 7.7 Predicción 7.8 Ejercicios", " Unidad 7 Regresión Lineal Múltiple y Polinómica Como extensión a los modelos de regresión lineal simple presentados en la Unidad 6 estudiamos los modelos de regresión lineal múltiple (RLM) y los modelos polinómicos (MP). La diferencia principal entre estos modelos y el de RLS es que estos involucran al menos dos variables predictoras de tipo numérico para tratar de explicar el comportamiento de la respuesta. Aunque la base de construcción del modelo es similar a lo tratado en la unidad anterior veremos y estudiaremos con detalle las particularidades de estos modelos. De hecho, veremos que todos los modelos se pueden expresar matemáticamente de una forma única lo que facilita su estudio, y nos permite considerar tanto modelos simples (con pocas predictoras) como los más complejos (con muchas predictoras). Antes de pasar a la presentación de estos modelos vamos a ver los ejemplos que iremos trabajando a lo largo de esta unidad. Al igual que en el modelo RLS el primer paso es la representación de los datos recogidos y realizar un pequeño estudio descriptivo sobre la posible asociación entre la respuesta y cada una de las predictoras consideradas, dado que resulta imposible realizar gráficos multivariantes de la respuesta vs todas las predictoras. Veamos los diferentes ejemplos con los que vamos a trabajar a lo largo de esta unidad. Ejemplo 1. Datos de Bosque. Para estimar la producción en madera de un bosque se suele realizar un muestreo previo en el que se realizan una serie de medidas no destructivas. Disponemos de mediciones para 20 árboles, así como el volumen (VOL) de madera que producen una vez cortados. Las variables consideradas son: HT o altura en pies, DBH el diámetro del tronco a 4 píes de altura (en pulgadas), D16 el diámetro del tronco a 16 pies de altura (en pulgadas), y VOL el volumen de madera conseguida (en pies cúbicos). El objetivo del análisis es determinar cuál es la relación entre dichas medidas y el volumen de madera, con el fin de poder predecir este último en función de las primeras. dbh &lt;- c(10.2, 13.72, 15.43, 14.37, 15, 15.02, 15.12, 15.24, 15.24, 15.28, 13.78, 15.67, 15.67, 15.98, 16.5, 16.87, 17.26, 17.28, 17.87, 19.13) d16 &lt;- c(9.3, 12.1, 13.3, 13.4, 14.2, 12.8, 14, 13.5, 14, 13.8, 13.6, 14, 13.7, 13.9, 14.9, 14.9, 14.3, 14.3, 16.9, 17.3) ht &lt;- c(89, 90.07, 95.08, 98.03, 99, 91.05, 105.6, 100.8, 94, 93.09, 89, 102, 99, 89.02, 95.09, 95.02, 91.02, 98.06, 96.01, 101) vol &lt;- c(25.93, 45.87, 56.2, 58.6, 63.36, 46.35, 68.99, 62.91, 58.13, 59.79, 56.2, 66.16, 62.18, 57.01, 65.62, 65.03, 66.74, 73.38, 82.87, 95.71) bosque &lt;- data.frame(vol, dbh, d16, ht) # Gráficos parciales datacomp = melt(bosque, id.vars = &#39;vol&#39;) ggplot(datacomp) + geom_jitter(aes(value, vol, colour = variable)) + facet_wrap(~variable, scales = &quot;free_x&quot;) + labs(x = &quot;&quot;, y = &quot;Volumen&quot;) Figura 7.1: Gráfico de dispersión de Volumen respecto de cada predictora. A simple vista todas las predictoras tienen un efecto positivo en el volumen de madera obtenido, lo cual es bastante obvio, ya que cuanto más grande sea el árbol se espera que su volumen sea más grande. Sin embargo, parece que el efecto de los diámetros es superior al de la altura del árbol (pendientes más pronunciadas) aunque resulta difícil distinguir que diámetro puede ser más relevante ya que ambos se comportan de forma similar. Podemos confirmar este hecho realizando un análisis de correlación para este banco de datos. Ejemplo 2. Datos de Concentración. Se ha llevado a cabo un experimento para estudiar la concentración presente de un fármaco en el hígado después de sufrir un tratamiento. Se piensa que las variables que pueden influir en la concentración son el peso del cuerpo, el peso del hígado y la dosis de fármaco administrada. p.cuerpo &lt;- c(176, 176, 190, 176, 200, 167, 188, 195, 176, 165, 158, 148, 149, 163, 170, 186, 146, 181, 149) p.higado &lt;- c(6.5, 9.5, 9.0, 8.9, 7.2, 8.9, 8.0, 10.0, 8.0, 7.9, 6.9, 7.3, 5.2, 8.4, 7.2, 6.8, 7.3, 9.0, 6.4) dosis &lt;- c(.88, .88, 1.0, .88, 1.0, .83, .94, .98, .88, .84, .80, .74, .75, .81, .85, .94, .73, .90, .75) concen &lt;- c(.42, .25, .56, .23, .23, .32, .37, .41, .33, .38, .27, .36, .21, .28, .34, .28, .30, .37, .46) concentracion &lt;- data.frame(p.cuerpo, p.higado, dosis, concen) # Gráficos parciales datacomp = melt(concentracion, id.vars = &#39;concen&#39;) ggplot(datacomp) + geom_jitter(aes(value, concen, colour = variable)) + facet_wrap(~variable, scales = &quot;free_x&quot;) + labs(x = &quot;&quot;, y = &quot;Concentración del fármaco&quot;) Figura 7.2: Gráfico de dispersión de la concentración del fármaco respecto de cada predictora. En este caso ninguno de los gráficos parciales muestra una gran asociación entre la concentración del fármaco y cada una de las predictoras. En todos ellos se aprecia una observación un poco más alejada del resto (concentración &gt; 0.6) que podría ser influyente en la obtención del modelo correspondiente. Ejemplo 3. Datos de Papel. Banco de datos de Papel de la unidad anterior, donde ya pudimos ver que la tendencia observada se comportaba más como una parábola (polinomio de grado 2) que como una recta. madera &lt;- c(1, 1.5, 2, 3, 4, 4.5, 5, 5.5, 6, 6.5, 7, 8, 9, 10, 11, 12, 13, 14, 15) tension &lt;- c(6.3, 11.1, 20.0, 24, 26.1, 30, 33.8, 34, 38.1, 39.9, 42, 46.1, 53.1, 52, 52.5, 48, 42.8, 27.8, 21.9) papel &lt;- data.frame(madera, tension) ggplot(papel, aes(x = madera, y = tension)) + geom_point() + labs(x = &quot;Concentración de madera&quot;, y = &quot;Resistencia del papel&quot;) Figura 7.3: Gráfico de dispersión de resistencia del papel vs concentración de madera. 7.1 Tipos de modelos Vemos las diferencias de expresión de cada uno de los modelos que trabajaremos en esta unidad. 7.1.1 Modelos de RLM Los modelos de regresión lineal múltiple surgen cuando tratamos de explicar el comportamiento de una variable predictora de tipo continuo a través de un conjunto de variables predictoras de tipo continuo mediante una función lineal. De hecho, se trata de describir dicha relación a través de una superficie, lineal en las variables explicativas, lo más próxima posible a los valores observados de la respuesta. Si \\(X_1, X_2, ..., X_p\\) son las variables predictoras el modelo viene dado por: \\[\\begin{equation} Y = \\beta_0 + \\beta_1 X_1 + \\beta_2 X_2 + ... + \\beta_p X_p + \\epsilon \\tag{7.1} \\end{equation}\\] Las hipótesis de este modelo es que los errores se distribuyen de forma independiente mediante una distribución Normal de media cero y varianza constante \\(\\sigma^2\\). Los parámetros desconocidos de este modelo son \\((\\beta_0, \\beta_1, ... , \\beta_p, \\sigma^2)\\) donde: \\(\\beta_0\\) se conoce como interceptación y representa el valor de la respuesta cuando la variable predictora toma el valor cero, interpretándose como un efecto común en la relación entre la predictora y la respuesta. Los \\(\\beta_i\\) son las pendientes de la recta asociadas con cada predictora y representa el aumento o disminución del valor de la respuesta cuando aumentamos en una unidad el valor de la predictora. En este tipo de modelos dicho parámetro se conoce también como el efecto de la predictora sobre la respuesta. \\(\\sigma^2\\) es la varianza residual del modelo. Dada un muestra de \\(n\\) sujetos de la variable respuesta \\((y_1, ..., y_n)\\) y de las variables predictoras \\((x_{11}, ..., x_{n1}), (x_{12}, ..., x_{n2}), ..., (x_{1p}, ..., x_{np})\\), el modelo de regresión lineal múltiple se puede escribir como: \\[Y = \\left(\\begin{array}{c} y_1 \\\\ y_2 \\\\ ...\\\\ y_n\\\\ \\end{array} \\right) = \\left(\\begin{array}{cccc} 1 &amp; x_{11} &amp; ... &amp; x_{1p}\\\\ 1 &amp; x_{21} &amp; ...&amp; x_{2p}\\\\ ...&amp; ... &amp; ...&amp; ...\\\\ 1 &amp; x_{n1}&amp; ...&amp; x_{np}\\\\ \\end{array} \\right) \\left(\\begin{array}{c} \\beta_0 \\\\ \\beta_1 \\\\ ....\\\\ \\beta_p\\\\ \\end{array} \\right) + \\left(\\begin{array}{c} e_1 \\\\ e_2 \\\\ ...\\\\ e_n \\end{array} \\right) = X \\beta + \\epsilon\\] donde \\(X\\) se denomina matriz del diseño, representando el efecto común (columna de 1’s) y el efecto de las predictoras (cada columna con los valores de la variable), y los \\(e_i\\) representan los errores aleatorias para cada uno de los sujetos de la muestra. Los bancos de datos de bosque y concentración quedarían englobados dentro de este conjunto de modelos con la siguiente propuesta: Datos de bosque \\[ \\text{vol} = \\beta_{0} + \\beta_{1}\\text{dbh} + \\beta_{2}\\text{d16} + \\beta_{3}\\text{ht} + \\epsilon \\] Datos de concentración \\[ \\text{concen} = \\beta_{0} + \\beta_{1}\\text{p.cuerpo} + \\beta_{2}\\text{p.higado} + \\beta_{3}\\text{dosis} + \\epsilon \\] 7.1.2 Modelos de RP Los modelos de regresión lineal múltiple surgen cuando tratamos de explicar el comportamiento de una variable predictora de tipo continuo a través de una variable predictora de tipo continuo mediante una función polinómica lineal. En general, los modelos polinómicos son útiles cuando se aprecia una tendencia curvilínea entre los predictores y la respuesta. Asimismo, a veces constituyen una aproximación sencilla (por serie de Taylor) a modelos complejos e incluso no-lineales. Si \\(X\\) es la variable predictora y queremos un polinomio de grado \\(k\\) el modelo viene dado por: \\[\\begin{equation} Y = \\beta_0 + \\beta_1 X + \\beta_2 X^2 + ... + \\beta_k X^k + \\epsilon \\tag{7.2} \\end{equation}\\] Las hipótesis de este modelo es que los errores se distribuyen de forma independiente mediante una distribución Normal de media cero y varianza constante \\(\\sigma^2\\). Los parámetros desconocidos de este modelo son \\((\\beta_0, \\beta_1, ... , \\beta_k, \\sigma^2)\\) donde: \\(\\beta_0\\) se conoce como interceptación y representa el valor de la respuesta cuando la variable predictora toma el valor cero, interpretándose como un efecto común en la relación entre la predictora y la respuesta. Los \\(\\beta_i\\) son las pendientes de la recta asociadas con cada predictora y representa el aumento o disminución del valor de la respuesta cuando aumentamos en una unidad el valor de la predictora. En este tipo de modelos dicho parámetro se conoce también como el efecto de la potencia de la predictora sobre la respuesta. \\(\\sigma^2\\) es la varianza residual del modelo. Dada un muestra de \\(n\\) sujetos de la variable respuesta \\((y_1, ..., y_n)\\) y de la variable predictora \\((x_{11}, ..., x_{n1})\\), el modelo de regresión polinómico se puede escribir como: \\[Y = \\left(\\begin{array}{c} y_1 \\\\ y_2 \\\\ ...\\\\ y_n\\\\ \\end{array} \\right) = \\left(\\begin{array}{cccc} 1 &amp; x_{11} &amp; ... &amp; x^k_{11}\\\\ 1 &amp; x_{21} &amp; ...&amp; x^k_{21}\\\\ ...&amp; ... &amp; ...&amp; ...\\\\ 1 &amp; x_{n1}&amp; ...&amp; x^k_{n1}\\\\ \\end{array} \\right) \\left(\\begin{array}{c} \\beta_0 \\\\ \\beta_1 \\\\ ....\\\\ \\beta_k\\\\ \\end{array} \\right) + \\left(\\begin{array}{c} e_1 \\\\ e_2 \\\\ ...\\\\ e_n \\end{array} \\right) = X \\beta + \\epsilon\\] donde \\(X\\) se denomina matriz del diseño, representando el efecto común (columna de 1’s) y el efecto del grado del polinomio (cada columna con los valores de la variable), y los \\(e_i\\) representan los errores aleatorias para cada uno de los sujetos de la muestra. El banco de datos de papel quedaría englobado dentro de este conjunto de modelos con la siguiente propuesta: \\[ \\text{tension} = \\beta_{0} + \\beta_{1}\\text{madera} + \\beta_{2}\\text{madera}^2 + \\epsilon \\] Ambos tipos de modelos se pueden describir mediante una única formulación: \\[\\begin{equation} Y = X \\beta + \\epsilon \\tag{7.3} \\end{equation}\\] 7.1.3 Expresión en R de los modelos Antes de ver como afecta a la estimación del modelo la presencia de más de una predictora o posible efecto sobre la respuesta, vamos a ver como podemos expresar los modelos RLM y MP en R. El modelo RLM dado en (7.1) se expresa como: \\[Y \\sim X_1 + X_2 + ... + X_p\\] El modelo RLM para una predictora \\(X\\) dado en (7.2) se expresa como: \\[Y \\sim X + I(X^2) + ... + I(X^k)\\] Estas expresiones son una generalización directa del modelo RLS presentado en la unidad anterior. 7.1.4 Modelo saturado y anidado En modelos donde hay más de un efecto sobre la predictora, es decir, tenemos diferentes predictoras o un modelo polinómico, debemos introducir dos conceptos que resultan muy relevantes, y que utilizaremos de forma muy habitual en la selección del mejor modelo. El modelo saturado es aquel que contiene todos los efectos asociados con las diferentes predictoras consideradas. Para los tres ejemplos considerados tendríamos: \\[\\left\\{ \\begin{array}{lc} \\text{Ejemplo 1} &amp; vol \\sim dbh + d16 + ht\\\\ \\text{Ejemplo 2} &amp; concen \\sim p.cuerpo + p.higado + dosis\\\\ \\text{Ejemplo 3} &amp; resistencia \\sim madera + madera^2\\\\ \\end{array} \\right. \\] Los modelos anidados son todos los modelos que podemos considerar y que no contienen todos los efectos asociados con las predictoras. Si tenemos un modelo con dos predictoras \\(X_1\\), y \\(X_2\\) lo modelos anidados del modelo saturado \\[Y \\sim X_1 +X_2\\] son: \\[\\left\\{ \\begin{array}{lc} \\text{con } X_1 &amp; Y \\sim X_1\\\\ \\text{con } X_2 &amp; Y \\sim X_2\\\\ \\text{Sin ninguna} &amp; Y \\sim 1\\\\ \\end{array} \\right. \\] Todos ellos están “anidados” dentro del modelo saturado y reflejan diferente información. El primero refleja que la respuesta sólo está relacionada con \\(X_1\\), el segundo que la respuesta está relacionada con \\(X_2\\), y el último refleja que no hay ninguna predictora relacionada con la respuesta. Debemos tener en cuenta que al incluir más de una predictora debemos decidir si todas ellas son relevantes para explicar el comportamiento de la respuesta, o bien si podemos prescindir de algunas de ellas. La consideración de los diferentes modelos anidados varía en función del modelo con el que trabajemos. En el caso de los de RLM el orden de los modelos anidados no es relevante, pero sin embargo si lo es los modelos polinómicos. No tiene sentido considerar un modelo en el que sólo se incluya el efecto del polinomio de grado 2 pero que no se incluya el de grado 1. Por su propia construcción cuando consideramos un modelo polinómico de grado \\(k\\) se deben considerar obligatoriamente todos los grados desde \\(1\\) hasta \\(k-1\\). Si consideramos un modelo polinómico de grado 4, el orden de los modelos anidados viene dado por: \\[\\left\\{ \\begin{array}{ll} \\text{saturado } &amp; Y \\sim X + X^2 + X^3 + X^4\\\\ \\text{grado 3 } &amp; Y \\sim X + X^2 + X^3 \\\\ \\text{grado 2 } &amp; Y \\sim X + X^2 \\\\ \\text{grado 1 } &amp; Y \\sim X \\\\ \\text{sin efectos } &amp; Y \\sim 1 \\\\ \\end{array} \\right. \\] A la hora de ajustar un modelo polinómico, siempre serán preferibles modelos con órdenes pequeños antes que grandes (principio de parsimonia o simplicidad). Siempre trataremos de seleccionar le modelo con un orden más pequeño, es decir, con menos efectos pero con igual predictivo que el modelo saturado. 7.2 Estimación e inferencia Los procesos de estimación e inferencia del RLM y MP se basan en los mismos principios que los del modelo RLS estudiados en la unidad anterior. De hecho, las hipótesis sobre los errores de incorrelación, varianza constante y media cero son suficientes para obtener el ajuste por mínimos cuadrados del modelo propuesto. La normalidad es necesaria para obtener las inferencias y concluir sobre su fiabilidad. Sin embargo, este tipo de modelos de regresión que consideran más de una predictora adolecen de un problema que puede ser muy relevante en su análisis. Dado que todas las predictoras no vendrán medidas en la misma escala de medida, el modelo obtenido (más concretamente los coeficientes del modelo) exhibe una dependencia de dicha escala que puede provocar que una variable con una variabilidad pequeña aparezca con un coeficiente grande en el modelo estimado. Para evitar esa dependencia se suele trabajar con las variables estandarizadas, es decir, corregidas por su media y desviación típica para eliminar los efectos de escala. Aunque en el apartado teórico mostraremos la solución para las variables en escala original, en la parte práctica mostraremos los coeficientes para las variables estandarizadas y veremos los cambios entre ambos modelos. Para denotar las variables transformadas añadiremos el prefijo Z al nombre de la predictora a la hora de escribir los modelos obtenidos. 7.2.1 Mínimos cuadrados Para estimar \\(\\beta\\) seguimos el criterio de minimizar la suma de cuadrados debida al error, esto es, \\[ min_{\\beta} \\quad \\epsilon&#39;\\epsilon = min_{\\beta} \\quad (Y-X \\beta)&#39;(Y-X \\beta) = min_{\\beta} \\quad Y&#39;Y -2 \\beta&#39;X&#39;Y + \\beta&#39;X&#39;X\\beta. \\] Tras derivar la expresión anterior respecto de \\(\\beta\\) e igualarlo a cero, se obtiene el estimador de mínimos cuadrados de \\(\\beta\\) para el modelo (7.3), \\(\\hat{\\beta}\\), resolviendo las \\(p\\) ecuaciones normales: \\[\\begin{equation} X&#39;X \\beta=X&#39;Y. \\tag{7.4} \\end{equation}\\] A la hora de resolver (7.4), se pueden presentar dos situaciones: Las \\(p\\) ecuaciones normales que resultan de (7.4) no son independientes y por lo tanto no existe la inversa de \\(X&#39;X\\). Esto ocurre cuando las variables explicativas no son independientes entre sí. Entonces el modelo ha de expresarse en términos de menos parámetros (modificarse) o han de incorporarse restricciones adicionales sobre los parámetros para dar una matriz no singular. Cuando \\((X&#39;X)\\) es singular, el estimador de \\(\\beta\\) se obtiene a partir de una matriz inversa generalizada \\(X&#39;X\\), \\((X&#39;X)^{-}\\), como: \\[\\begin{equation} \\hat{\\beta}=(X&#39;X)^{-} X&#39;Y. \\tag{7.5} \\end{equation}\\] Así, diferentes elecciones de la inversa generalizada \\((X&#39;X)^{-}\\) producen diferentes estimaciones de \\(\\beta\\). Sin embargo, el modelo ajustado es el mismo, esto es, \\(\\hat{y}=X \\hat{\\beta}\\) es invariante a la inversa generalizada elegida. Las \\(p\\) ecuaciones normales son independientes, con lo que \\(X&#39;X\\) es no singular y existe su inversa. El estimador de mínimos cuadrados resulta: \\[\\begin{equation} \\hat{\\beta}=(X&#39;X)^{-1} (X&#39;Y). \\tag{7.6} \\end{equation}\\] 7.2.2 Propiedades Cuando prescindimos de la hipótesis de normalidad de los errores, obtenemos la estimación por mínimos cuadrados, que tiene las siguientes propiedades: El estimador de mínimos cuadrados \\(\\hat{\\beta}\\) minimiza \\(\\epsilon&#39;\\epsilon\\), independientemente de la distribución de los errores. La hipótesis de normalidad se añade para justificar las inferencias basadas en estadísticos \\(t\\) o \\(F\\). Los elementos de \\(\\hat{\\beta}\\) son funciones lineales de las observaciones \\(y_1, \\ldots, y_n\\) y son estimadores insesgados de mínima varianza, sea cual sea la distribución de los errores. Así tenemos: \\[ E(\\hat{\\beta})=\\beta \\ \\quad \\mbox{ y }\\ \\quad Var(\\hat{\\beta})=\\sigma^2 (X&#39;X)^{-1} . \\] Las estimaciones/predicciones de la variable respuesta \\(y\\) se obtienen con el modelo lineal ajustado: \\[ \\hat{y}=X\\hat{\\beta}. \\] Los residuos \\(e=y-X\\hat{\\beta}\\) verifican: \\(\\sum_{i=1}^n e_i \\hat{y}_i = 0 \\ \\Leftrightarrow \\ e&#39;\\hat{y}=\\hat{y}&#39; e = 0\\) La ortogonalidad entre los vectores de estimaciones y de residuos, \\(\\hat{y}\\) y \\(e\\) respectivamente, implica el teorema de Pitágoras: \\[ |y|^2=|\\hat{y}|^2+|e|^2 \\ \\Leftrightarrow \\ \\sum_{i=1}^n y_i^2= \\sum_{i=1}^n \\hat{y}_i^2 + \\sum_{i=1}^n e_i^2. \\] \\(\\sum_{i=1}^n e_i = 0 \\ \\Leftrightarrow \\ e&#39;\\mathbf{1}=\\mathbf{1}&#39; e = 0\\) 7.2.3 Máxima verosimilitud Como ocurría en el modelo RLS el estimador de mínimos cuadrados coincide con el máximo verosímil, ya que bajo la hipótesis de normalidad de los errores aleatorios, la verosimilitud conjunta tiene la forma: \\[ L(\\beta;y) \\propto f(y;\\beta) \\propto \\left(\\frac{1}{\\sigma^2}\\right)^{n/2} \\quad exp\\left\\{-\\frac{(y-X\\beta)&#39;(y-X\\beta)}{2 \\sigma^2}\\right\\}, \\] y maximizar la verosimilitud es equivalente a minimizar la log-verosimilitud cambiada de signo, que coincide con la suma de cuadrados del error para un valor fijo de \\(\\sigma^2\\). De nuevo utilizaremos la hipótesis de normalidad para proceder con el proceso de inferencia sobre el modelo (7.3). 7.2.4 Inferencia Para establecer los procedimientos de inferencia asociados con el modelo (7.3) es preciso incorporar la hipótesis de normalidad de los errores. A partir de ella podemos obtener la distribución de los estadísticos y estimadores involucrados en el proceso de inferencia con el modelo lineal ajustado. 7.2.4.1 Varianza del modelo Podemos obtener un estimador de \\(\\sigma^2\\) basado en la variabilidad que ha quedado sin explicar por el modelo, cuantificada por lo que llamamos suma de cuadrados residual SSE: \\[ \\begin{array}{ll} SSE=\\sum_{i=1}^n (y_i-\\hat{y}_i)^2 &amp;= e&#39;e \\\\ &amp;= y&#39;y - 2 \\hat{\\beta}&#39; X&#39;y + \\hat{\\beta}&#39;X&#39;X \\hat{\\beta} \\\\ &amp;= y&#39;y - \\hat{\\beta}&#39; X&#39;y. \\end{array} \\] Puesto que en el modelo lineal propuesto se estiman \\(p\\) parámetros, la suma de cuadrados residual \\(SSE\\) tiene asociados \\(n-p\\) grados de libertad (el número de datos menos el de coeficientes del modelo). El cociente entre \\(SSE\\) y sus grados de libertad, \\(n-p\\), es el estimador de mínimos cuadrados de \\(\\sigma^2\\), y es además, un estimador insesgado: \\[ \\hat{\\sigma}^2=s^2 = MSE=\\frac{SSE}{n-p}. \\] Asumiendo que el modelo es cierto, la distribución de probabilidad de la varianza del modelo es proporcional a una \\(\\chi^2\\) con \\(n-p\\) grados de libertad, \\[ \\frac{(n-p)s^2}{\\sigma^2} \\sim \\chi^2_{n-p}. \\] 7.2.4.2 Coeficientes del modelo Bajo la hipótesis de normalidad de los errores, tenemos que el estimador máximo-verosímil \\(\\hat{\\beta}\\) tiene una distribución normal: \\[ \\hat{\\beta} \\sim N(\\beta, \\sigma^2 (X&#39;X)^{-1}). \\] Esto implica que la distribución marginal de cada uno de los coeficientes de la regresión, \\(\\hat{\\beta}_i\\), también es normal, \\[ \\hat{\\beta}_i \\sim N(\\beta_i, \\sigma^2 C^{X}_{ii}), \\ \\ i=0, \\ldots, p-1, \\] con \\(C^{X}_{ii}\\) el \\(i\\)-ésimo elemento de la diagonal de la matriz \\((X&#39;X)^{-1}\\). En consecuencia, para construir intervalos de confianza o resolver contrastes sobre cada uno de los coeficientes del modelo, individualmente, podemos utilizar estadísticos \\(t\\) que se distribuyen con una distribución t de Student con \\(n-p\\) grados de libertad: \\[ \\frac{\\hat{\\beta}_i-\\beta_i}{\\sqrt{s^2 C^X_{ii}}} \\ \\sim \\ t_{n-p}, \\ \\ i=1, \\ldots, n, \\] construidos a partir del estimador de \\(\\sigma^2\\), \\(s^2\\). Así, un intervalo de confianza para un coeficiente de interés \\(\\beta_i\\) al nivel \\((1-\\alpha)100\\%\\) viene dado por: \\[ \\hat{\\beta}_i \\pm t_{(n-p, 1-\\alpha/2)} \\ \\sqrt{s^2 \\ C^X_{ii}}, \\] donde \\(t_{(n-p, 1-\\alpha/2)}\\) es el cuantil \\(1-\\alpha/2\\) de una distribución \\(t\\) con \\(n-p\\) grados de libertad. El contraste \\(H_0:\\beta_i=0\\) se resolverá con el rechazo de \\(H_0\\) a nivel \\(1-\\alpha\\) si \\[ |\\hat{\\beta}_i| &gt; t_{(n-p, 1-\\alpha/2)} \\ \\sqrt{s^2 \\ C^X_{ii}}. \\] Cuando se pretende obtener intervalos de confianza para varios coeficientes del modelo a la vez, es recomendable ser más conservador. Hay diversas soluciones propuestas para realizar “comparaciones múltiples,” esto es, testar todos los coeficientes a la vez, y obtener regiones de confianza conjuntas. Quizá el más conocido es el ajuste de Bonferroni, basado en sustituir el cuantil \\(t_{(n-p, 1-\\alpha/2)}\\) en la expresión anterior, por \\(t_{(n-p, 1-\\alpha/2q)}\\), si \\(q\\) es el número de coeficientes para los que se desea una estimación en intervalo. Se obtendrán entonces unos intervalos de confianza ‘ensanchados’ respecto a los intervalos de confianza individuales. Si no tenemos ninguna prioridad particular sobre determinados coeficientes, lo lógico será obtener conjuntamente los intervalos de confianza para todos los coeficientes del modelo, esto es, \\(q=p\\). Otra opción para la estimación en intervalo es construir una región de confianza conjunta para todos los parámetros \\(\\beta\\) del modelo, determinando los puntos \\(\\beta\\) de la elipse definida por: \\[ (\\beta-\\hat{\\beta})&#39;X&#39;X (\\beta-\\hat{\\beta})= (p+1) \\ s^2 \\ F_{(p, n-p, 1-\\alpha)}, \\] donde \\(F_{(p, n-p, 1-\\alpha)}\\) es el cuantil \\(1-\\alpha\\) de una distribución \\(F\\) con \\(p\\) y \\(n-p\\) grados de libertad. Es posible construir regiones de confianza conjuntas de este tipo para cualquier subconjunto de coeficientes del modelo. Bastará variar adecuadamente los grados de libertad \\(p\\) y \\(n-p\\). Estas regiones acaban siendo complicadas de interpretar, especialmente cuando la dimensión de \\(\\beta\\) es grande. Sin embargo, en la práctica no se suele hacer cuando el número de predictoras es elevado. 7.2.5 Ejemplos Realizamos el proceso de estimación e inferencia para los modelos saturados correspondientes a los ejemplos presentados al inicio de esta unidad. Obtendremos el modelo para las predictoras en escala original y estandarizadas, representaremos los intervalos de confianza de los coeficientes del modelo, y obtendremos el ajuste final del modelo. Utilizaremos la función tab_model de la libreria sjplot para el análisis de los coeficientes del modelo, ya que nos proporciona más información que la función glm_coef. 7.2.5.1 Datos de Bosque Ajustamos un modelo RLM para el conjunto de datos bosque. # Ajuste del modelo fit.bosque &lt;- lm(vol ~ dbh + d16 + ht, data = bosque) # Inferencia sobre los parámetros del modelo glm_coef(fit.bosque) Tabla 7.1: ParameterCoefficientPr(&gt;|t|) (Intercept)-108.58 (-138.56, -78.6)&lt; 0.001 dbh1.63 (-0.55, 3.8)0.133 d165.67 (3.12, 8.22)&lt; 0.001 ht0.69 (0.35, 1.04)&lt; 0.001 de forma que el ajuste obtenido viene dado por: \\[ \\widehat{\\text{vol}} = -108.58 + 1.63*\\text{dbh} + 5.67*\\text{d16} + 0.69*\\text{ht} \\] La interpretación de los coeficientes nos indica que el valor predicho de volumen aumenta en 1.63 unidades por el aumenta de una unidad de DBH, en 5.67 unidades por cada unidad de D16, y 0.69 unidades por cada unidad de HT. A la vista de los contrastes individuales (p-valores) podemos concluir que los coeficientes asociados con D16 y HT son significativos, es decir, sus coeficientes si sólo esa variable estuviera presente en el modelo serían distintos de cero. Esta información se ve reforzada por los intervalos de confianza individuales, que además muestran que dichos coeficientes son positivos indicando que el VOL aumenta directamente al aumentar los valores de D16 y HT. Por tanto, el modelo anidado dado por: \\[vol \\sim d16 + ht\\] podría ser igualmente válido que el que contiene todas las predictoras. A continuación, se presenta el ajuste obtenido para cada variable de forma marginal. Representamos gráficamente la estimación e intervalo de confianza de los coeficientes del modelo para apreciar los efectos descritos: # Gráfico del ajuste plot_model(fit.bosque, show.values = TRUE, vline.color = &quot;yellow&quot;) Comparamos los resultados con los del modelo estandarizado. La tabla proporciona las estimaciones e intervalo de confianza al 95% de los parámetros en la escala original (Estimates y CI), las estimaciones y CI de los coeficientes del modelo estandarizado (std.Beta y standarized CI), y el p-valor asociado a cada coeficiente # Inferencia sobre los parámetros del modelo tab_model(fit.bosque, show.std = TRUE, show.r2 = FALSE)   vol Predictors Estimates std. Beta CI standardized CI p (Intercept) -108.58 0.00 -138.56 – -78.60 -0.10 – 0.10 &lt;0.001 dbh 1.63 0.21 -0.55 – 3.80 -0.07 – 0.50 0.133 d16 5.67 0.65 3.12 – 8.22 0.36 – 0.95 &lt;0.001 ht 0.69 0.24 0.35 – 1.04 0.12 – 0.36 0.001 Observations 20 Se aprecia como la variable más relevante para explicar el comportamiento del volumen de madera es el diámetro del tronco a 16 pies de altura con un coeficiente estandarizado de 0.65, que es tres veces superior a los coeficientes de las otras predictoras. Podemos ver el gráfico de las estimaciones para el modelo estandarizado: # Gráfico del ajuste plot_model(fit.bosque, show.values = TRUE, vline.color = &quot;yellow&quot;, type = &quot;std&quot;) Por último, obtenemos los gráficos del modelo ajustado. Para obtener estos gráficos se asume como valor para la predictoras que no están en el gráfico igual a su media muestral Por ejemplo, para el gráfico de vol con respecto dbh utilizamos el modelo: \\[ \\widehat{\\text{vol}} = -108.58 + 1.63*\\text{dbh} + 5.67*\\overline{\\text{d16}} + 0.69*\\overline{\\text{ht}} \\] donde \\(\\overline{\\text{d16}}\\) y \\(\\overline{\\text{ht}}\\) son respectivamente las medias muestrales de d16 y ht. Los gráficos para cada predictora son: # Gráfico del ajuste plot_model(fit.bosque, &quot;pred&quot;, ci.lvl = NA, show.data = TRUE, title = &quot;Modelo ajustado&quot;) ## $dbh ## ## $d16 ## ## $ht 7.2.5.2 Datos de concentración Ajustamos un modelo RLM para el conjunto de datos de concentración. # Ajuste del modelo fit.concen &lt;- lm(concen ~ p.cuerpo + p.higado + dosis, data = concentracion) # Inferencia tab_model(fit.concen, show.std = TRUE, show.r2 = FALSE)   concen Predictors Estimates std. Beta CI standardized CI p (Intercept) 0.27 0.00 -0.15 – 0.68 -0.43 – 0.43 0.192 p cuerpo -0.02 -3.96 -0.04 – -0.00 -7.13 – -0.79 0.018 p higado 0.01 0.20 -0.02 – 0.05 -0.31 – 0.70 0.419 dosis 4.18 4.05 0.93 – 7.42 0.90 – 7.20 0.015 Observations 19 de forma que el ajuste obtenido viene dado por: \\[ \\widehat{\\text{concen}} = 0.27 - 0.02*\\text{p.cuerpo} + 0.01*\\text{p.higado} + 4.18*\\text{dosis} \\] La interpretación de los coeficientes nos indica que el valor predicho de la concentración aumenta con el peso del hígado y dosis suministrada, pero disminuye con el peso del cuerpo. Los valores tan pequeños de los coeficientes asociados a los pesos podrían indicar que dichas variables no tienen gran capacidad predictiva, pero hay que tener en cuenta que dichas variables están medidas en un escala distinta de la dosis, y que por tanto la estimación de los coeficientes se ve influenciada por dicha escala. Si nos fijamos en los coeficientes estandarizados apreciamos la misma tendencia en todas la preditoras (signo del coeficiente) pero vemos como tanto el p.cuerpo como la dosis tienen un peso similar para explicar el comportamiento de la concentración. Del análisis de los contrastes individuales podríamos descartar la variable peso del hígado (p-valor &gt;0.05) para explicar el comportamiento de la concentración del compuesto (algo que deberemos comprobar posteriomente), y considerar el resto de predictoras en el modelo anidado: \\[concen \\sim p.cuerpo + dosis\\] Los gráficos de los coeficientes del modelo (no estandarizados y estandarizados) nos permite ver gráficamente estas conclusiones: # Gráfico del ajuste sin estandarizar plot_model(fit.concen, show.values = TRUE, vline.color = &quot;yellow&quot;) # Gráfico del ajuste estandarizados plot_model(fit.concen, show.values = TRUE, vline.color = &quot;yellow&quot;, type = &quot;std&quot;) En el gráfico de coeficientes sin estandarizar se aprecia el efecto de trabajar en la escala original, dado que el intervalo de confianza del peso del cuerpo es inapreciable y puede llegar a parecer que no tiene efecto sobre la concentración, lo que si queda más claro en el gráfico de los coeficientes estandarizados. ¿qué ocurre cuando realizamos el gráfico del ajuste para este conjunto de datos? 7.2.5.3 Datos de papel Ajustamos un modelo MP de grado 2 para el conjunto de datos de papel presentados en la unidad anterior. # Ajuste del modelo fit.papel &lt;- lm(tension ~ madera + I(madera^2), data = papel) # Inferencia tab_model(fit.papel, show.std = TRUE, show.r2 = FALSE)   tension Predictors Estimates std. Beta CI standardized CI p std. p (Intercept) -6.67 0.81 -13.88 – 0.53 0.58 – 1.03 0.067 &lt;0.001 madera 11.76 0.79 9.64 – 13.89 0.63 – 0.96 &lt;0.001 &lt;0.001 madera^2 -0.63 -0.85 -0.77 – -0.50 -1.03 – -0.68 &lt;0.001 &lt;0.001 Observations 19 de forma que el ajuste obtenido viene dado por: \\[ \\widehat{\\text{tension}} = -6.67 + 11.76*\\text{madera} - 0.63*\\text{madera}^2 \\] El ajuste obtenido es una parábola invertida (coeficiente negativo en la potencia 2) tal y como se observaba en el gráfico de los datos (Figura 6.2). En este tipo de modelos el análisis inferencial se debe centrar en el estudio del orden más alto, para determinar si es adecuado o si podríamos construir un modelo de un orden más simple. La significatividad del coeficiente (p-valor &lt; 0.05) indica que dicho grado es necesario en el modelo. De hecho, los coeficientes estandarizados muestran un efecto similar tanto en el grado 1 como en grado 2. Lo vemos gráficamente: # Gráfico del ajuste sin estandarizar plot_model(fit.papel, show.values = TRUE, vline.color = &quot;yellow&quot;) # Gráfico del ajuste estandarizados plot_model(fit.papel, show.values = TRUE, vline.color = &quot;yellow&quot;, type = &quot;std&quot;) Vemos el gráfico del ajuste obtenido: # Gráfico del ajuste plot_model(fit.papel, &quot;pred&quot;, ci.lvl = NA, show.data = TRUE, title = &quot;Modelo ajustado&quot;) ## $madera La tendencia ajustada se corresponde con la observada en los datos del experimento. 7.3 Bondad del ajuste En este punto presentamos los procedimientos de bondad de ajuste habituales en los modelos de regresión: Análisis de la tabla Anova, el coeficiente de determinación, y el coeficiente de determinación ajustado. Por el momento nos centraremos en el estudio de bondad de ajuste del modelo saturado. En las secciones siguientes veremos como determinar el conjunto de predictoras más relevantes para explicar el comportamiento de la respuesta, y utilizaremos de nuevo estos criterios para valorar el ajuste obtenido. 7.3.1 Tabla ANOVA Habitualmente, la primera forma de juzgar la calidad del ajuste obtenido consiste en valorar la variabilidad de la respuesta que se ha podido explicar con el modelo propuesto. En lo que sigue, asumiremos que el modelo ajustado es \\(\\hat{y}=X\\hat{\\beta}\\), donde la matriz de diseño \\(X\\) tiene por columnas todas las variables explicativas consideradas, sean continuas o dummies definidas para representar algún factor. En todo caso, suponemos que hemos estimado \\(p\\) coeficientes, esto es, \\(\\hat{\\beta} \\in \\mathbb{R}^p\\). Descomponemos pues la variabilidad de las observaciones \\(y\\), en la parte explicada por el modelo ajustado y corregida por la media de los datos (suma de cuadrados de la regresión), \\(SSR\\), y la parte residual (suma de cuadrados debida al error) que ha quedado sin explicar, \\(SSE\\): \\[ \\underbrace{(y-\\bar{y}1)&#39;(y-\\bar{y}1)}_{S_{yy}}= \\underbrace{(\\hat{y}-\\bar{y}1)&#39;(\\hat{y}-\\bar{y}1)}_{SSR} +\\underbrace{e&#39;e}_{SSE}, \\] donde \\(\\bar{y}=\\sum_i y_i/n\\). Los grados de libertad asociados a \\(SSR\\) son \\(p-1\\), pues se pierde un parámetro al corregir la estimación \\(\\hat{y}\\) (obtenida a partir de \\(p\\) parámetros) por la media \\(\\bar{y}\\). La suma de cuadrados del error \\(SSE\\) tiene asociados \\(n-p\\) grados de libertad, esto es, el número de datos menos el número de parámetros estimados en el modelo. Al dividir las sumas de cuadrados por sus grados de libertad respectivos, obtenemos los cuadrados medios correspondientes, \\(MSR=SSR/(p-1)\\) y \\(MSE=SSE/(n-p)\\), que nos resultan útiles para valorar la bondad del ajuste. El test de bondad de ajuste propone el contraste: \\[\\begin{equation} H_0: \\beta_1=\\beta_2=\\ldots=\\beta_{p-1}=0, \\qquad H_1: \\mbox{ algún } \\beta_i \\neq 0. \\tag{7.7} \\end{equation}\\] Cuando el modelo es bueno, \\(MSR\\) y \\(MSE\\) siguen sendas distribuciones proporcionales a chi-cuadrados independientes (con la misma constante de proporcionalidad \\(\\sigma^2\\)), con \\(p-1\\) y \\(n-p\\) grados de libertad respectivamente; de ahí que su cociente (libre ya de la constante desconocida \\(\\sigma^2\\)) resulta tener una distribución \\(F\\) con \\(p-1\\) y \\(n-p\\) grados de libertad: \\[\\begin{equation} F=\\frac{SSR/(p-1)}{SSE/(n-p)}=\\frac{MSR}{MSE} \\ \\sim \\ F_{(p-1, n-p)}. \\tag{7.8} \\end{equation}\\] Así, con dicho estadístico \\(F\\) contrastamos si la variabilidad explicada por el modelo ajustado es suficientemente grande comparada con la que queda sin explicar (la de los residuos); en otras palabras, si el modelo ajustado es significativo para explicar la variabilidad de los datos. Si el p-valor asociado al estadístico F es inferior a la significatividad considerada (generalmente 0.05), rechazamos que el modelo propuesto no explique conjuntamente la respuesta, y concluimos a favor de que algunas de las covariables contienen información significativa para predecir la respuesta, esto es, a favor de la bondad del ajuste. En otro caso, no podemos garantizar significativamente la bondad del modelo propuesto. La Tabla de Anova es la forma habitual de presentar toda la información de las sumas, medias de cuadrados, estadísticos \\(F\\) y p-valores asociados al contraste de bondad de ajuste del modelo. La salida de la Tabla Anova que proporciona R no es exactamente la habitual presentada en todos los libros. En dicha tabla, en lugar de contrastar globalmente el ajuste a través de la suma de cuadrados asociada a la regresión, se contrasta secuencialmente la significatividad de cada una de las covariables a la hora de explicar la variable respuesta en presencia de las variables que ya han sido incorporadas al modelo (las que quedan por encima en la salida). Sin embargo, con dicha salida es posible calcular el test F de bondad de ajuste. Utilizaremos diferentes funciones para obtener el estadístico F y el p-valor asociado, y las funciones anova() para obtener la descomposición de la tabla ANOVA. 7.3.2 Coeficiente determinación El coeficiente de determinación, \\(R^2\\), se define como la parte proporcional de la variabilidad de los datos que es explicada por el modelo ajustado: \\[\\begin{equation} R^2 = \\frac{SSR}{S_{yy}} = 1 - \\frac{SSE}{S_{yy}} \\tag{7.9} \\end{equation}\\] Por definición tenemos que \\(0 \\leq R^2 \\leq 1\\). Un ajuste perfecto de los datos produciría \\(R^2=1\\). Si ninguna de las variables predictoras \\(X_1, \\ldots, X_{p-1}\\) es útil para explicar la respuesta \\(Y\\), entonces \\(R^2=0\\). Siempre es posible conseguir \\(R^2\\) suficientemente grande, simplemente añadiendo más términos en el modelo. Por ejemplo, si hay más de un valor de \\(y\\) para un mismo \\(x\\) observado, un polinomio de grado \\(n-1\\) proporcionará un ajuste “perfecto” (\\(R^2=1\\)) para \\(n\\) datos. Cuando esto no ocurre y hay únicamente un valor de \\(y\\) por cada \\(x\\), \\(R^2\\) nunca puede ser igual a 1 porque el modelo no puede explicar la variabilidad debida al error puro. Aunque \\(R^2\\) siempre aumenta cuando añadimos una variable explicativa al modelo, esto no significa necesariamente que el nuevo modelo sea superior al antiguo, es decir, que dicha variable sea útil para explicar mejor los datos. A pesar de que la suma de cuadrados residual \\(SSE\\) del nuevo modelo se reduce por una cantidad igual al anterior \\(MSE\\), el nuevo modelo tendrá un \\(MSE\\) mayor debido a que pierde un grado de libertad. Por lo tanto, el nuevo modelo será de hecho, peor que el antiguo. En consecuencia, algunos analistas prefieren utilizar una versión ajustada del estadístico \\(R^2\\). El \\(R^2\\) ajustado penaliza los modelos que incorporan variables innecesarias dividiendo las sumas de cuadrados por sus grados de libertad, esto es, \\[\\begin{equation} R^2_a=1-\\frac{SSE/(n-p)}{S_{yy}/(n-1)}=1-(1-R^2)\\left(\\frac{n-1}{n-p}\\right). \\tag{7.10} \\end{equation}\\] \\(R^2_a\\) es preferible a \\(R^2\\) cuando sus valores difieren mucho. Su interpretación tiene algún problema debido a que puede tomar valores negativos; esto ocurre cuando el estadístico \\(F\\) toma valores inferiores a 1 (o produce p-valores mayores que 0.05). 7.3.3 Ejemplos Analizamos los diferentes ejemplos con los que venimos trabajando a lo largo de la unidad. 7.3.3.1 Datos de Bosque Bondad de ajuste para los datos bosque. # Bondad del ajuste glance(fit.bosque) Tabla 7.2: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.9590.9513.11252.59e-113-48.71071121531620 # Tabla ANOVA anova(fit.bosque) Tabla 7.2: DfSum SqMean SqF valuePr(&gt;F) 13.09e+033.09e+03322&nbsp;&nbsp;5.05e-12 1332&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;332&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;34.62.3e-05&nbsp; 1173&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;173&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.10.000606 16153&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9.58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tanto el \\(R^2\\) como el \\(R^2\\) ajustado muestran porcentajes del 95% indicando que el modelo ajustado tiene buena capacidad explicativa. Además, el test \\(F\\) de la regresión resulta significativo (p-valor &lt; 0.05) indicando que las predictoras consideradas pueden ser utilizadas para describir el comportamiento del volumen. Los tests individuales de la tabla ANOVA 7.3.3.2 Datos de Concentración Bondad de ajuste para los datos de concentración # Bondad del ajuste glance(fit.concen) Tabla 7.3: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.3640.2370.07732.860.072323.9-37.9-33.10.08961519 # Tabla ANOVA anova(fit.concen) Tabla 7.3: DfSum SqMean SqF valuePr(&gt;F) 10.003220.003220.5380.474&nbsp; 10.003070.003070.5130.485&nbsp; 10.045&nbsp;&nbsp;0.045&nbsp;&nbsp;7.53&nbsp;0.0151 150.0896&nbsp;0.00597&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; El \\(R^2\\) y el \\(R^2\\) ajustado muestran valores bastante bajos indicando poco poder explicativo. Además, el p-valor del test \\(F\\) resulta no significativo indicando que todos los coeficientes del modelo podrían ser considerados iguales a cero. Esto contradice lo visto durante el proceso de estimación de los parámetros del modelo y la tabla ANOVA obtenida donde se aprecia que el efecto asociado con dosis resulta significativo. Este comportamiento puede ser debido al considerar más predictoras de las necesarias o simplemente a que las predictoras no son adecuadas para explicar el comportamiento de la concentración. En el punto siguiente, donde se tratará la selección del mejor modelo, analizaremos este modelo con más detalle y podremos concluir sobre la validez de las predcitoras. 7.3.3.3 Datos de Papel Bondad de ajuste para los datos de papel # Bondad del ajuste glance(fit.papel) Tabla 7.4: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.9090.8974.4279.44.91e-092-53.61151193131619 # Tabla ANOVA anova(fit.papel) Tabla 7.4: DfSum SqMean SqF valuePr(&gt;F) 11.04e+031.04e+0353.41.76e-06 12.06e+032.06e+03105&nbsp;&nbsp;1.89e-08 16313&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; En términos de \\(R^2\\) y \\(R^2\\) ajustado el modelo tiene buena capacidad explicativa (porcentajes del 90%) y el test \\(F\\) resulta significativo, indicando que alguno de los coeficientes del modelo debe ser considerado distinto de cero. Dado que se trata de un modelo polinómico nos debemos fijar de la significatividad del término de mayor orden en la tabla ANOVA. En este caso dicho efecto resulta significativo indicando que el modelo propuesto de grado 2 es necesario para explicar el comportamiento de la tensión del papel. 7.4 Comparación y selección de modelos La modelización de datos es siempre una faena tediosa debido a la innumerable cantidad de alternativas posibles. Está por determinar el tipo de modelo, las transformaciones más adecuadas, identificar las variables más relevantes, descartar las innecesarias, y posteriormente abordar la diagnosis y validación del modelo, que trataremos en las secciones siguientes. Si el modelo está mal especificado, las estimaciones de los coeficientes pueden resultar considerablemente sesgadas. Una buena especificación del modelo es un trabajo, en general, complicado de obtener. Si se ha optado por la modelización lineal de una respuesta en función de una serie de posibles variables predictoras, y el objetivo es seleccionar el mejor subconjunto de predictores para explicar la respuesta, el planteamiento es siempre el de obtener “buenas” predicciones. Sin embargo, sabemos que cuantos más predictores incluyamos en el modelo, mejores predicciones tendremos (menos sesgo), pero a la vez menos precisión sobre ellas (ya que la varianza es proporcional al número de variables predictoras en el modelo). Para la selección del “mejor” modelo habremos de llegar a un compromiso entre estos dos propósitos. Tratamos pues la selección de variables como un problema de comparación y selección de modelos. Vamos a presentar diversos criterios para comparar modelos y seleccionar el mejor modelo de entre dos alternativas. En ocasiones todos darían los mismos resultados, pero generalmente no, por lo que habrá de ser el analista el que decida qué criterio utilizar en función de sus intereses prioritarios. La selección del modelo se puede realizar con múltiples criterios pero aquí presentamos los más habituales basados en: la significatividad de los predictores que están presentes en el modelo y los que no; Los estadísticos \\(AIC\\) (Akaike Information Criteria) y \\(BIC\\) (Bayesian Information Criteria); Una vez seleccionado el “mejor” modelo según el criterio elegido, habremos de proseguir la confirmación del mismo realizando la diagnosis y la validación del modelo, que puede fallar en algún paso, lo que nos conduciría de nuevo a la reformulación del modelo (y todos los pasos que le siguen), optando por aquellas correcciones y/o transformaciones de variables sugeridas en el diagnóstico. La consecución del mejor modelo será pues, un procedimiento iterativo, basado en selección y valoración de la calidad del ajuste, diagnóstico y validación. En muchas situaciones prácticas nos conformaremos con encontrar el modelo que tenga un funcionamiento más adecuado aunque no sea prefecto. 7.4.1 Significatividad de los predictores Este procedimiento se basa en la comparación de modelos basada en las sumas de cuadrados y el test \\(F\\) resultante de compararlas. Supongamos que tenemos ajustado un modelo definido por \\(p\\) coeficientes. Si queremos valorar la contribución que hacen al ajuste de los datos un subconjunto de \\(q\\) variables predictoras adicionales, debemos plantear el contraste \\[\\begin{equation} H_0: y=X_p \\beta_p + \\epsilon, \\ \\ vs. \\ \\ H_1:y=X_{p+q} \\beta_{p+q} + \\epsilon. \\tag{7.11} \\end{equation}\\] Para resolver el contraste (7.11) se utiliza una versión del test \\(F\\) de regresión de la tabla ANOVA. Para resolverlo basta con ajustar los modelos con \\(p\\) y \\(p+q\\) predictoras, para obtener las sumas de cuadrados del error respectivas, \\(SSE(p)\\) y \\(SSE(p+q)\\). Su diferencia representa la reducción del error debida a la inclusión de los \\(q\\) regresores adicionales, y bajo \\(H_0\\) tienen una distribución chi-cuadrado, independiente de \\(SSE(p)\\). Se puede definir entonces un estadístico \\(F\\) para realizar la comparación de modelos y resolver el contraste (7.11), dado por: \\[\\begin{equation} F_q=\\frac{(SSE(p)-SSE(p+q))/q}{SSE(p)/(n-p)} \\sim F_{q, n-p}. \\tag{7.12} \\end{equation}\\] Las \\(q\\) variables adicionales se consideran relevantes (significativas) en la explicación de la respuesta, si \\(F_q\\) tiene asociado un p-valor significativo. Un criterio para seleccionar el mejor modelo es quedarse con aquel menos complejo (en términos de predictoras presentes en el modelo) y que pueda considerarse con la misma capacidad predictiva (test \\(F\\) parcial no significativo) que cualquier otro más complejo. 7.4.2 Estadísticos AIC y BIC El criterio de información de Akaike (Akaike, 1973) está basado en la función de verosimilitud e incluye una penalización que aumenta con el número de parámetros estimados en el modelo. Premia pues, los modelos que dan un buen ajuste en términos de verosimilitud y a la vez son parsimoniosos (tienen pocos parámetros). Si \\(\\hat{\\beta}\\) es el estimador máximo-verosímil del modelo de dimensión \\(p\\), y \\(l(\\theta)\\) denota el logaritmo (neperiano) de la verosimilitud asociada con dicho modelo, el estadístico \\(AIC\\) se define por: \\[\\begin{equation} AIC=-2\\, l(\\hat{\\beta})+2p. \\tag{7.13} \\end{equation}\\] Una versión del \\(AIC\\) que tiene en cuenta también el número de datos utilizados en el ajuste, es el Schwarz’s Bayesian criterion (Schwarz, 1978), conocido como \\(BIC\\), y definido por: \\[\\begin{equation} BIC=-2\\, l(\\hat{\\beta})+log(n)\\, p. \\tag{7.14} \\end{equation}\\] Si queremos comparar dos modelos con estos criterios, se debe seleccionar el modelo con un menor valor en estos estadísticos. 7.4.3 Selección automática Los criterios anteriores resultan de utilidad cunado queremos comparar dos modelos diferentes (“modelos en competencia”), pero pueden resultar poco prácticos si el número de modelos en competencia es muy elevado, es decir, tenemos muchas posibles variables predictoras. Por ese motivo se introducen los conocidos como procedimientos secuenciales que permiten la evaluación de muchos modelos en competencia en muy poco tiempo, utilizando cualquiera de los criterios anteriores. La idea básica es partir de un modelo con cierto número de regresores, y secuencialmente moverse hacia modelos mejores (según el criterio elegido) con más o menos regresores de entre todos los observados. Una vez elegido el criterio para la selección, distinguimos básicamente entre los siguientes procedimientos secuenciales, en función de cuál es el punto (modelo) de partida y la forma de ir considerando modelos alternativos: hacia adelante, se parte del modelo más simple y se van incluyendo una a una las variables que satisfacen el criterio de inclusión; hacia atrás, se parte del modelo más complejo y se van excluyendo una a una las variables que satisfacen el criterio de exclusión; paso a paso, se suele partir de un modelo y en cada paso se incluye o excluye la variable que satisface el criterio de inclusión/exclusión. Hay que tener en cuenta que dependiendo del tipo de modelo deberemos utilizar un tipo de procedimiento u otro. En el caso de los MRP no podemos utilizar el procedimiento hacia adelante, ya que se parte siempre del modelo con un mayor grado y se trata de identificar si dicho grado puede ser eliminado, dado que siempre tratamos de obtener el modelo más parsimonioso. En el caso de los modelos RLM no hay una preferencia con respecto al procedimiento secuencial. Los procedimientos hacia adelante y hacia atrás los hemos de llevar a cabo en R de forma manual y generalmente se utiliza el test F asociado a cada paso para resolver si una variable o efecto debe entrar o salir del modelo. Para ello utilizaremos las funciones drop1() y add1(). El procedimiento paso a paso es automático y se realiza con la función step(). 7.4.4 Funciones en R En la librería olsrr dedicada exclusivamente al análisis de modelos de regresión (simple, múltiple y polinómica) se presentan diferentes funciones para los procesos de selección automática de variables utilizando el test \\(F\\) parcial y el criterio AIC. Presentamos sólo aquellas funciones que utilizan como punto de partida el modelo saturado. Dichas funciones son: ols_step_backward_p(model): selección desde el modelo saturado mediante el test \\(F\\). Fijamos el parámetro prem igual a 0.05 para marcar el nivel de significatividad del contraste. ols_step_backward_aic(model): selección desde el modelo saturado mediante AIC. Aunque estas funciones pueden mostrar todo el desarrollo de selección (al igual que la función step()), la ventaja principal es que puede mostrar un resumen del proceso final para estudiar el modelo final obtenido. En los ejemplos mostraremos el uso de estas funciones. 7.4.5 Ejemplos A continuación, se muestra como utilizar los criterios de selección de variables y los procedimientos secuenciales de selección en los bancos de datos que venimos trabajando en esta unidad. 7.4.5.1 Datos de Bosque Veamos como seleccionar el mejor modelo para los datos de bosque. En puntos anteriores ya hemos obtenido el modelo saturado y pudimos ver como la variable dbh parecía no resultar relevante para explicar el comportamiento del volumen obtenido. Proponemos un nuevo modelo sin dicha variable y comparamos ambos modelos utilizando los criterios de comparación. Para la comparación de modelos anidados siempre deberemos empezar desde el modelo más sencillo al más complejo. Los modelos que deseamos comparar son: \\[\\begin{array}{ll} M_2: &amp; vol \\sim d16 + ht\\\\ M_1: &amp; vol \\sim dbh + d16 + ht \\end{array}\\] # Modelo saturado M1 &lt;- lm(vol ~ dbh + d16 + ht, data = bosque) # Construimos modelo sin dbh M2 &lt;- lm(vol ~ d16 + ht, data = bosque) # Comparación mediante test F anova(M2, M1) Tabla 7.5: Res.DfRSSDfSum of SqFPr(&gt;F) 17177&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16153124.12.510.133 El test \\(F\\) parcial resulta no significativo (p-valor = 0.1326) al comparar los modelos \\(M_1\\) y \\(M_2\\), lo que implica que ambos modelos pueden ser considerados iguales. Comparamos el proceso inferencial en cada modelo, dado que al considerar el modelo más simple estamos admitiendo que dbh no es relevante para explicar el comportamiento del volumen. # Comparativa de modelos tab_model(M1, M2, show.ci = FALSE)   vol vol Predictors Estimates p Estimates p (Intercept) -108.58 &lt;0.001 -105.90 &lt;0.001 dbh 1.63 0.133 d16 5.67 &lt;0.001 7.41 &lt;0.001 ht 0.69 0.001 0.68 0.001 Observations 20 20 R2 / R2 adjusted 0.959 / 0.951 0.953 / 0.947 Se puede ver que el \\(R^2\\) ajustado para ambos modelos es prácticamente idéntico reflejando que poseen la misma capacidad explicativa. Los modelos obtenidos muestran estimaciones de los coeficientes muy parecidos para ambos modelos. Eliminar la variable dbh no afecta a la capacidad explicativa del modelo, y no altera la contribución de cada predictora a la explicación de la respuesta. El modelo resultante viene dado por: \\[ \\widehat{\\text{vol}} = -105.90 + 7.41*\\text{d16} + 0.68*\\text{ht} \\] Utilzamos ahora los criterios \\(AIC\\) y \\(BIC\\) para comparar ambos modelos: g2 &lt;- glance(M2) g1 &lt;- glance(M1) kable(rbind(g1, g2), digits = 2) r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC deviance df.residual nobs 0.96 0.95 3.10 124.93 0 3 -48.75 107.49 112.47 153.30 16 20 0.95 0.95 3.23 170.95 0 2 -50.20 108.41 112.39 177.36 17 20 Si utilizamos el \\(AIC\\) podemos concluir que el modelo preferido es \\(M_2\\) dado que obtenemos un valor más pequeño, mientras que si usamos el \\(BIC\\) el preferido es \\(M1\\). Sin embargo, dado que en ambos casos las diferencias entre ambos modelos son excesivamente pequeñas concluir que uno es mejor que otro resulta complicado y utilizamos el criterio de simplicidad. Ante modelos parecidos elegimos el menos complejo que en este caso sería el que tiene menos predictoras (modelo \\(M2\\)). Por último, veremos como utilizar el procedimiento secuencial automático por pasos para obtener el mejor modelo para este conjunto de datos. En este caso partimos del modelo saturado. stats::step(fit.bosque) ## Start: AIC=48.73 ## vol ~ dbh + d16 + ht ## ## Df Sum of Sq RSS AIC ## &lt;none&gt; 153.30 48.733 ## - dbh 1 24.06 177.36 49.649 ## - ht 1 173.42 326.72 61.867 ## - d16 1 213.21 366.51 64.166 ## ## Call: ## lm(formula = vol ~ dbh + d16 + ht, data = bosque) ## ## Coefficients: ## (Intercept) dbh d16 ht ## -108.5758 1.6258 5.6714 0.6938 El proceso de selección comienza a partir del moldeo saturado y determina para cada predictora cual sería el cambio en el \\(AIC\\) (columna AIC) si dicha variable fuera eliminada del modelo. El modelo saturado tiene un \\(AIC\\) de 48.733 (fila &lt;none&gt;), mientras que el modelo donde se elimina la variable dbh (fila - dbh) tiene un \\(AIC\\) de 49.649. Atendiendo al criterio establecido de quedarnos con el modelo con un menor \\(AIC\\) el modelo preferido sería el saturado. Esto contradice los resultados obtenidos con el test \\(F\\) parcial pero es posible cuando tenemos pocos datos o los valores de \\(AIC\\) están muy próximos. Repetimos el análisis de selección automática con las funciones de la libreria olsrr. ols_step_backward_p(fit.bosque, prem = 0.05) ## ## ## Elimination Summary ## ------------------------------------------------------------------------ ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## ------------------------------------------------------------------------ ## 1 dbh 0.9526 0.9471 4.5111 108.4066 3.2300 ## ------------------------------------------------------------------------ ols_step_backward_aic(fit.bosque) ## [1] &quot;No variables have been removed from the model.&quot; Como se puede ver la solución es la misma que la obtenida con la función step()pero la forma de mostrar los resultados es mucho más simple. En casos con muchas posibles predictoras puede resultar más útil compara solo los mejores modelos que podríamos obtener con todas las posibles combinaciones de predictoras. Para realizar esta tarea podemos utilizar la función ols_step_best_subset(). Veamos su funcionamiento con este ejemplo a pesar de que el número de predictoras es pequeño, y el número de posibles modelos es reducido. ols_step_best_subset(fit.bosque) Tabla 7.6: mindexnpredictorsrsquareadjrpredrsqcpaicsbicsbcmsepfpeapchsp 11d160.9080.9030.88419.8&nbsp;12060.712338121&nbsp;&nbsp;0.112&nbsp;1.12&nbsp; 22d16 ht0.9530.9470.9334.5110852.111221012&nbsp;&nbsp;0.06410.652 33dbh d16 ht0.9590.9510.9244&nbsp;&nbsp;&nbsp;10752.611219311.50.06140.639 Se presentan diferentes criterios para valorar el mejor modelo de entre todas las combinaciones posibles. En este caso el analista debe decidir cual de los propuestos es más adecuado. El único criterio que no se encuentra disponible es el test \\(F\\) parcial. Dado que la capacidad explicativa los dos modelos propuestos es muy similar será preferible el menos complejo. En la fase de diagnóstico ya comprobaremos si ese modelo más simple debe ser modificado o si por el contrario es adecuado para proceder con la fase de predicción. Almacenamos el nuevo modelo: # Modelo seleccionado fit.bosque &lt;- lm(vol ~ d16 + ht, data = bosque) 7.4.5.2 Datos de Concentración Veamos como seleccionar el mejor modelo para los datos de concentración. En puntos anteriores ya hemos podido ver que el peso del hígado resultaba poco relevante, con lo que podríamos plantear un contraste para saber si podemos prescindir de dicha variable. Sin embargo, la forma habitual de proceder sería utilizar en primer lugar un procedimiento automático para seleccionar las predictoras y chequear posteriormente mediante un test \\(F\\) parcial si el modelo obtenido posee la misma capacidad explicativa que el modelo saturado. Planteamos el proceso secuencial: stats::step(fit.concen) ## Start: AIC=-93.78 ## concen ~ p.cuerpo + p.higado + dosis ## ## Df Sum of Sq RSS AIC ## - p.higado 1 0.004120 0.093729 -94.924 ## &lt;none&gt; 0.089609 -93.778 ## - p.cuerpo 1 0.042408 0.132017 -88.416 ## - dosis 1 0.044982 0.134591 -88.049 ## ## Step: AIC=-94.92 ## concen ~ p.cuerpo + dosis ## ## Df Sum of Sq RSS AIC ## &lt;none&gt; 0.093729 -94.924 ## - p.cuerpo 1 0.039851 0.133580 -90.192 ## - dosis 1 0.043929 0.137658 -89.621 ## ## Call: ## lm(formula = concen ~ p.cuerpo + dosis, data = concentracion) ## ## Coefficients: ## (Intercept) p.cuerpo dosis ## 0.28552 -0.02044 4.12533 En la primera iteración el \\(AIC\\) del modelo saturado es igual a -93.78 mientras que el del modelo que prescinde de p.higado es de -94.92. Por tanto, dicha variable se elimina del modelo que pasa a tener un \\(AIC\\) de -94.92. En la segunda iteración la variable candidata a salir es p.cuerpo, pero su \\(AIC\\) asociado es superior al del modelo actual y no se descarta. Verificamos mediante el test \\(F\\) parcial: # Modelo saturado M1 &lt;- lm(concen ~ p.higado + p.cuerpo + dosis, data = concentracion) # Construimos modelo sin dbh M2 &lt;- lm(concen ~ p.cuerpo + dosis, data = concentracion) # Comparación mediante test F anova(M2, M1) Tabla 7.7: Res.DfRSSDfSum of SqFPr(&gt;F) 160.0937&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 150.089610.004120.690.419 EL test \\(F\\) resulta no significativo indicando que el modelo más simple tiene la misma capacidad explicativa que el más complejo. Estudiamos dicho modelo comparándolo con el saturado. # Comparativa de modelos tab_model(M1, M2, show.ci = FALSE)   concen concen Predictors Estimates p Estimates p (Intercept) 0.27 0.192 0.29 0.155 p higado 0.01 0.419 p cuerpo -0.02 0.018 -0.02 0.019 dosis 4.18 0.015 4.13 0.015 Observations 19 19 R2 / R2 adjusted 0.364 / 0.237 0.335 / 0.251 Podemos ver coo el \\(R^2\\) ajustado mejora al eliminar p.higado y los coeficientes son prácticamente idénticos: \\[ \\widehat{\\text{concen}} = 0.29 - 0.02*\\text{p.cuerpo} + 4.13*\\text{dosis} \\] Utilizamos ahora las funciones específicas: ols_step_backward_p(fit.concen, prem = 0.05) ## ## ## Elimination Summary ## ------------------------------------------------------------------------ ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## ------------------------------------------------------------------------ ## 1 p.higado 0.3347 0.2515 2.6897 -39.0043 0.0765 ## ------------------------------------------------------------------------ ols_step_backward_aic(fit.concen) ## ## ## Backward Elimination Summary ## ---------------------------------------------------------------- ## Variable AIC RSS Sum Sq R-Sq Adj. R-Sq ## ---------------------------------------------------------------- ## Full Model -37.858 0.090 0.051 0.36390 0.23668 ## p.higado -39.004 0.094 0.047 0.33466 0.25149 ## ---------------------------------------------------------------- Almacenamos el modelo resultante para la fase de diagnóstico: fit.concen &lt;- lm(concen ~ p.cuerpo + dosis, data = concentracion) 7.4.5.3 Datos de Papel Para el bando de datos de Papel se ha propuesto como modelo uno del tipo polinómico de grado 2. El proceso de selección en este caso se basa en comparar el modelo cuadrático frente al lineal para saber si es posible prescindir del grado 2, o si por el contrario es necesario para explicar la tensión del papel. Los modelos que deseamos comparar son: \\[\\begin{array}{ll} M_2: &amp; tension \\sim madera\\\\ M_1: &amp; tension \\sim madera + I(madera^2) \\end{array}\\] # Modelo saturado M1 &lt;- lm(tension ~ madera + I(madera^2), data = papel) # Construimos modelo sin dbh M2 &lt;- lm(tension ~ madera, data = papel) # Comparación mediante test F anova(M2, M1) Tabla 7.8: Res.DfRSSDfSum of SqFPr(&gt;F) 172.37e+03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16313&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.06e+031051.89e-08 El test \\(F\\) parcial resulta significativo indicando que los modelos considerados tienen capacidades explicativas estadísticamente distintas. No podemos rechazar el modelo cuadrático frente al modelo lineal. Veamos la tabla de estimación de ambos modelos: # Comparativa de modelos tab_model(M1, M2, show.ci = FALSE)   tension tension Predictors Estimates p Estimates p (Intercept) -6.67 0.067 21.32 0.001 madera 11.76 &lt;0.001 1.77 0.014 madera^2 -0.63 &lt;0.001 Observations 19 19 R2 / R2 adjusted 0.909 / 0.897 0.305 / 0.265 El \\(R^2\\) ajustado pasa del 26.5% en el modelo lineal al 89.7% en el modelo cuadrático indicando una gran mejora en la capacidad explicativa, y por tanto eligiendo este último como el modelo que debe pasar a la fase de diagnóstico. Utilizamos las funciones resumen Utilizamos ahora las funciones específicas: ols_step_backward_p(fit.papel, prem = 0.05) ## [1] &quot;No variables have been removed from the model.&quot; ols_step_backward_aic(fit.papel) ## [1] &quot;No variables have been removed from the model.&quot; 7.5 Multicolinealidad La multicolinealidad es un problema relativamente frecuente en regresión lineal múltiple, y en general en análisis con varias variables explicativas, entre cuyas soluciones se halla la selección de variables. Cuando los regresores no están relacionados linealmente entre sí, se dice que son ortogonales. Que exista multicolinealidad significa que las columnas de \\(X\\) no son linealmente independientes. Si existiera una dependencia lineal total entre algunas de las columnas, tendríamos que el rango de la matriz \\(X&#39;X\\) sería menor a \\(p\\) y \\((X&#39;X)^{-1}\\) no existiría. El hecho de que haya multicolinealidad, esto es, una relación casi lineal entre algunos regresores, afecta a la estimación e interpretación de los coeficientes del modelo. La multicolinealidad no es un problema de violación de hipótesis; simplemente es una situación que puede ocasionar problemas en las inferencias con el modelo de regresión. Nos ocupamos a continuación de examinar las causas de la multicolinealidad, algunos de los efectos que tiene en las inferencias, los métodos básicos para detectar el problema y algunas formas de tratarlo. 7.5.1 Causas Montgomery y Peck (1992) comentan que la colinealidad puede surgir por el método de recogida de datos, restricciones en el modelo o en la población, especificación y sobreformulación del modelo (consideración de más variables de las necesarias); en modelos polinómicos, por ejemplo, se pueden presentar problemas serios de multicolinealidad en la matriz de diseño \\(X\\) cuando el rango de variación de los predictores es muy pequeño. Obviamente, modelos con más covariables son más propicios a padecer problemas de multicolinealidad. 7.5.2 Efectos Los principales efectos de la multicolinealidad son los siguientes: Una multicolinealidad fuerte produce varianzas y covarianzas grandes para los estimadores de mínimos cuadrados. Así, muestras con pequeñas diferencias podrían dar lugar a estimaciones muy diferentes de los coeficientes del modelo. Es decir, las estimaciones de los coeficientes resultan poco fiables cuando hay un problema de multicolinealidad. De hecho, dichos coeficientes vienen a explicar cómo varía la respuesta cuando varía la variable independiente en cuestión y todas las demás quedan fijas; si las variables predictoras están relacionadas entre sí, es inviable que al variar una no lo vayan a hacer las demás y en consecuencia puedan quedar fijas. La multicolinealidad reduce la efectividad del ajuste lineal si su propósito es determinar los efectos de las variables independientes. A consecuencia de la gran magnitud de los errores estándar de las estimaciones, muchas de éstas no resultarían significativamente distintas de cero: los intervalos de confianza serán ‘grandes’ y por tanto, con frecuencia contendrán al cero. La multicolinealidad tiende a producir estimaciones de mínimos cuadrados \\(\\hat{\\beta}_j\\) muy grandes en valor absoluto. Los coeficientes del ajuste con todos los predictores difieren bastante de los que se obtendrían con una regresión simple entre la respuesta y cada variable explicativa. La multicolinealidad no afecta al ajuste global del modelo (medidas como la \\(R^2\\), etc.) y por lo tanto no afecta a la habilidad del modelo para estimar puntualmente la respuesta o la varianza residual. Sin embargo, al aumentar los errores estándar de las estimaciones de los coeficientes del modelo, también lo hacen los errores estándar de las estimaciones de la respuesta media y de la predicción de nuevas observaciones, lo que afecta a la estimación en intervalo. 7.5.3 Diagnósticos Existen diversos diagnósticos propuestos para detectar problemas de multicolinealidad. Consideramos los más relevantes, que son: Los gráficos entre variables explicativas son útiles para estudiar la relación entre las variables explicativas y su disposición en el espacio, y con ello detectar correlaciones o identificar observaciones muy alejadas del resto de datos y que pueden influenciar notablemente la estimación. Consisten en gráficos de dispersión entre un par de covariables continuas o un par de factores (a través de sus códigos), y gráficos de cajas cuando se trata de investigar la relación entre un factor y una covariable. Una medida simple de multicolinealidad consiste en la inspección de los elementos fuera de la diagonal de la matriz \\(X&#39;X\\), es decir, las correlaciones simples \\(r_{ij}\\) entre todos los regresores. Si dos regresores \\(x_i\\) y \\(x_j\\) son casi linealmente dependientes, entonces \\(|r_{ij}| \\approx 1\\). Sin embargo, cuando la multicolinealidad involucra a varias variables, no hay garantías de detectarla a través de las correlaciones bivariadas. Puesto que uno de los efectos principales de la multicolinealidad es la inflación de la varianza y covarianza de las estimaciones, es posible calcular unos factores de inflación de la varianza, FIV, que permiten apreciar tal efecto. En concreto, la varianza de \\(\\hat{\\beta}_j\\) viene estimada por \\(Var(\\hat{\\beta}_j)=s^2 \\, C_{jj}\\), donde \\(C_{jj}^X\\) son los elementos de la diagonal de la matriz \\((X&#39;X)^{-1}\\), es decir, \\[ C_{jj}^X=\\frac{1}{(1-R_j^2) \\, S_{x_j x_j}}, \\ \\ j=1, 2, \\ldots, p, \\] con \\(R_j^2\\) el coeficiente de determinación múltiple para la regresión de \\(x_j\\) sobre las restantes \\(p-1\\) covariables. Si hay una correlación muy alta entre \\(x_j\\) y los restantes regresores, entonces \\(R_j^2 \\approx 1\\). En particular, puesto que \\(s^2\\) no varía ante un problema de multicolinealidad, si ésta existe, la varianza de \\(\\hat{\\beta}_j\\) aumenta por un factor igual a \\(1/(1-R_j^2)\\), que se define como el FIV para \\(x_j\\): \\[ FIV_j=1/(1-R_j^2). \\] Generalmente, valores de un FIV superiores a 10 dan indicios de un problema de multicolinealidad, si bien su magnitud depende del modelo ajustado. Lo ideal es compararlo con su equivalente en el modelo ajustado, esto es, \\(1/(1-R^2)\\), donde \\(R^2\\) es el coeficiente de determinación del modelo. Los valores FIV mayores que esta cantidad implican que la relación entre las variables independientes es mayor que la que existe entre la respuesta y los predictores, y por tanto dan indicios de multicolinealidad. Dado que la multicolinealidad afecta a la singularidad (rango menor que \\(p\\)) de la matriz \\(X&#39;X\\), sus valores propios \\(\\lambda_1, \\lambda_2, \\ldots, \\lambda_p\\) pueden revelar multicolinealidad en los datos. De hecho, si hay una o más dependencias casi lineales en los datos, entonces uno o más de los valores propios será pequeño. En lugar de buscar valores propios pequeños, se puede optar por calcular el número de condición de \\(X&#39;X\\), definido por: \\[ \\kappa = \\lambda_{max}/\\lambda_{min}, \\] que es una medida de dispersión en el espectro de valores propios de \\(X&#39;X\\). Generalmente, si el número de condición es menor que 100, no hay problemas de multicolinealidad. Números de condición entre 100 y 1000 implican multicolinealidad moderada, y mayores que 1000 implican multicolinealidad severa. Los índices de condición de la matriz \\(X&#39;X\\) también son útiles para el diagnóstico de multicolinealidad y se definen por: \\[ \\kappa_j = \\lambda_{max}/\\lambda_j, \\ \\ \\ j=1, \\ldots, p. \\] El número de índices de condición que son grandes (por ejemplo, \\(\\geq 1000\\)) es una medida útil del número de dependencias casi lineales en \\(X&#39;X\\). Otra posibilidad de diagnóstico es a través de un análisis de componentes principales. Este tipo de análisis multivariante se plantea sobre conjuntos de variables relacionadas linealmente entre sí y tiene como finalidad la de definir un conjunto menor de nuevas variables obtenidas como combinación lineal de las originales, y que a la vez resultan ortogonales entre sí. Si el análisis de componentes principales resulta significativo, estamos reconociendo multicolinealidad. 7.5.4 Soluciones Una vez detectado un problema de multicolinealidad, es recomendable intentar aliviarlo (por sus efectos). Para ello disponemos de diversos recursos, y en función del objetivo del análisis, será más aconsejable uno u otro. Básicamente podemos distinguir como objetivos esenciales: Estimar bien la respuesta media en función de un conjunto de variables explicativas, sin importar demasiado la contribución individual de cada una de esas variables. Hacer un análisis de estructura, esto es, describir el efecto de las variables explicativas en la predicción de la respuesta. Las magnitudes y significatividades de los coeficientes son entonces de interés. Así, en un análisis de estructura es importante conseguir un buen modelo de ajuste para cuantificar bien la información que aportan las variables explicativas sobre la respuesta. Hay tres aproximaciones básicas como remedio a la multicolinealidad: Selección de variables (ver Sección XX). Respecto a la selección de variables, lo ideal ante un problema de multicolinealidad es seleccionar aquellas variables predictoras que son más significativas y contienen la mayor parte de la información sobre la respuesta. Sin embargo, hay que actuar con precaución, pues los métodos automáticos de selección de variables son bastante sensibles cuando existe relación entre los regresores y no está garantizado que el modelo resultante tenga menor multicolinealidad. Por otro lado, la capacidad predictiva del modelo puede verse seriamente menguada al reducir el número de covariables consideradas, de modo que este remedio iría más indicado cuando el objetivo del análisis es el 2. Redefinición de variables. Otra alternativa es transformar las covariables. Para ello es importante identificar entre qué covariables hay relación, con el fin de utilizar transformaciones apropiadas. Si varias variables están relacionadas linealmente, a veces funciona considerar la más completa de ellas tal y como es, y transformaciones de las otras con cocientes o diferencias respecto de la más completa. Es decir, si \\(x_i\\) y \\(x_j\\) están relacionadas y \\(x_i\\) da una información más completa que \\(x_j\\), se puede considerar un nuevo ajuste que involucre a las variables \\(x_i\\) y \\(x_j/x_i\\), o bien a \\(x_i\\) y \\(x_j-x_i\\). Cuando la intuición o el conocimiento de las variables no sugiere ninguna transformación concreta, una opción es llevar a cabo un análisis de componentes principales con el fin de obtener nuevas variables, expresables como combinación lineal de las originales, ortogonales entre sí y que contengan toda la información disponible en las primeras. En ocasiones, las componentes que resultan tienen un significado intuitivo por la forma de asimilar la información de las variables originales, y en ocasiones no, en cuyo caso se puede proceder a la realización de un análisis factorial y a la búsqueda de alguna rotación geométrica que permita llegar a variables “interpretables.” Una vez obtenidas las componentes \\(Z\\), se pueden seguir dos alternativas: i) plantear una regresión de la respuesta explicada por todas las componentes principales obtenidas, o ii) ajustar un modelo de regresión sólo con las componentes más relevantes como variables predictoras (componentes principales incompletas). En el primer caso, a partir del modelo ajustado \\(y=Z\\gamma+\\epsilon\\), es posible recuperar el efecto de las variables originales sobre la respuesta sin más que deshacer el cambio. Esto no es posible para la segunda alternativa, pues las estimaciones que se consiguen están sesgadas; sin embargo, esta opción reduce la varianza de las estimaciones respecto del modelo original. Estimación sesgada. Si uno de los efectos de la multicolinealidad es que aumenta el error estándar de las estimaciones por mínimos cuadrados de los coeficientes del modelo, cabe la posibilidad de utilizar estimadores que, aun sesgados, produzcan estimaciones con menor error estándar y un error cuadrático medio inferior al de los estimadores de mínimos cuadrados (que son, de los insesgados, los de mínima varianza). Hay varios procedimientos de estimación sesgada. Las componentes principales incompletas es uno de ellos. La regresión Ridge es otro método interesante. La regresión Ridge consiste en utilizar como estimador de \\(\\beta\\), el siguiente: \\[ \\hat{\\beta}_k=(X&#39;X+kI)^{-1} X&#39;y, \\] donde \\(k\\) es una constante pequeña arbitraria. Cuando todos los predictores están estandarizados, tenemos que \\(X&#39;X\\) es la matriz de correlaciones, con unos en la diagonal. Así, la correlación “efectiva” que se consigue ahora entre \\(x_i\\) y \\(x_j\\) es \\(r_{ij}/(1+k)\\). Es decir, todas las correlaciones se reducen artificialmente en un factor \\(1/(1+k)\\), reduciendo entonces la multicolinealidad. Valores grandes de \\(k\\) reducen la multicolinealidad pero, como contraprestación, aumentan el sesgo de las estimaciones. Para determinar el valor de \\(k\\) a utilizar, se suelen considerar gráficos en los que se representa \\(k\\) versus las estimaciones del modelo (ridge plots). Para valores pequeños de \\(k\\), las estimaciones de los coeficientes cambian mucho, mientras que a medida que \\(k\\) aumenta, las estimaciones parecen estabilizarse. Se dice que se consigue un valor óptimo para \\(k\\) cuando se da dicha estabilización en las estimaciones. Este procedimiento resulta pues, algo subjetivo, pero sin embargo ha resultado efectivo en la práctica. Hay otros procedimientos sesgados de estimación propuestos en la literatura que alivian el problema de la multicolinealidad. 7.5.5 Ejemplos A continuación, realizamos el estudio de multicolinealidad para los diferentes bancos de datos que hemos venido trabajando. Para el calculo de los factores de inflacción de la varianza y los números de condición utilizamos la función ols_coll_diag() de la librería olsrr. Con ella obtenemos el VIF asociado con cada variable, el índice de condición asociado con cada valor propio, y la matriz de correlaciones asociada al modelo ajustado. En caso de detectar multicolinealidad trataremos de corregirla con los procedimientos presentados. 7.5.5.1 Datos de bosque Para el análisis de multicolinealidad tomamos el modelo obtenido después del proceso de selección de variables de la sección anterior. # Modelos fit.bosque&lt;- lm(vol ~ d16 + ht, data = bosque) # Análisis de multicolinealidad ols_coll_diag(fit.bosque) ## Tolerance and Variance Inflation Factor ## --------------------------------------- ## Variables Tolerance VIF ## 1 d16 0.813726 1.228915 ## 2 ht 0.813726 1.228915 ## ## ## Eigenvalue and Condition Index ## ------------------------------ ## Eigenvalue Condition Index intercept d16 ht ## 1 2.991530311 1.00000 0.000270918 0.001143249 0.0002206333 ## 2 0.007330472 20.20137 0.077611612 0.924370594 0.0288009800 ## 3 0.001139217 51.24405 0.922117470 0.074486157 0.9709783867 Del análisis realizado no parece detectarse multicolinealidad a través de \\(VIF\\), ni a través de los índices de condición. El valor de \\(1/(1-R^2)\\) para dicho modelo es 21.28 que es superior a los valore de \\(VIF\\) observados. Por tanto, no parece haber un problema de multicolinealidad con el modelo obtenido. 7.5.5.2 Datos de concentración En este caso analizamos el modelo saturado en primer lugar. # Modelos fit.concen&lt;- lm(concen ~ p.cuerpo + p.higado + dosis, data = concentracion) # Análisis de multicolinealidad ols_coll_diag(fit.concen) ## Tolerance and Variance Inflation Factor ## --------------------------------------- ## Variables Tolerance VIF ## 1 p.cuerpo 0.01919315 52.101917 ## 2 p.higado 0.74868308 1.335679 ## 3 dosis 0.01944498 51.427154 ## ## ## Eigenvalue and Condition Index ## ------------------------------ ## Eigenvalue Condition Index intercept p.cuerpo p.higado ## 1 3.980955e+00 1.00000 0.0005211255 1.049346e-05 0.001061756 ## 2 1.307262e-02 17.45068 0.0912614776 7.180392e-04 0.963765107 ## 3 5.885352e-03 26.00803 0.8549633200 4.879743e-03 0.028213823 ## 4 8.720917e-05 213.65475 0.0532540769 9.943917e-01 0.006959314 ## dosis ## 1 1.138353e-05 ## 2 8.095775e-04 ## 3 6.508870e-03 ## 4 9.926702e-01 Hay dos \\(VIF\\) que indican multicolinealidad y un número de condición por encima de 100. Probamos con el modelo obtenido en el proceso de selección de variables: # Modelos fit.concen&lt;- lm(concen ~ p.cuerpo + dosis, data = concentracion) # Análisis de multicolinealidad ols_coll_diag(fit.concen) ## Tolerance and Variance Inflation Factor ## --------------------------------------- ## Variables Tolerance VIF ## 1 p.cuerpo 0.01947892 51.33755 ## 2 dosis 0.01947892 51.33755 ## ## ## Eigenvalue and Condition Index ## ------------------------------ ## Eigenvalue Condition Index intercept p.cuerpo dosis ## 1 2.993933e+00 1.00000 0.0009364888 1.884523e-05 2.017998e-05 ## 2 5.978794e-03 22.37764 0.9398136118 4.217372e-03 5.578232e-03 ## 3 8.781609e-05 184.64349 0.0592498994 9.957638e-01 9.944016e-01 Se siguen presentando problemas de multicolinealidad. Sin embargo, aunque esto puede parecer un problema muy grave no lo es dada la situación experimental dada. Es de esperar que la dosis suministrada este claramente asociada con el peso del sujeto, y por tanto dichas variables tienen que estar relacionadas. Aunque la multicolinealidad afecta a la precisión del modelo (en este caso es poco relevante porque nuestro ajuste es bastante malo) no es un problema con el diagnóstico del modelo. En la sección siguiente determinaremos si el modelo debe ser modificado o si por el contrario nos quedamos con el modelo obtenido tras la selección de variables. 7.5.5.3 Datos de papel Para este conjunto de datos es de esperar que los indicadores de multicolinealidad proporcionen resultados altos, ya que al tratarse de un MP la variable predictora es la misma. # Análisis de multicolinealidad ols_coll_diag(fit.papel) ## Tolerance and Variance Inflation Factor ## --------------------------------------- ## Variables Tolerance VIF ## 1 madera 0.05840859 17.12077 ## 2 I(madera^2) 0.05840859 17.12077 ## ## ## Eigenvalue and Condition Index ## ------------------------------ ## Eigenvalue Condition Index intercept madera I(madera^2) ## 1 2.7005883 1.000000 0.01001057 0.001973208 0.003447858 ## 2 0.2904492 3.049257 0.18853949 0.001001403 0.035409847 ## 3 0.0089625 17.358596 0.80144993 0.997025390 0.961142295 El resultado del \\(VIF\\) muestra multicolinealidad pero como es el comportamiento natural para este tipo de modelos se decide no actuar. 7.6 Diagnóstico Estudiamos en este punto el proceso de diagnóstico de un modelo RLM o MP de los que hemos venido estudiando hasta ahora. El diagnóstico del modelo es realmente valioso por cuanto nos permite corroborar que se cumplen (o no) cada una de las hipótesis asumidas para el ajuste del modelo y que dan credibilidad a las conclusiones que obtenemos. Este diagnóstico suele sugerir con frecuencia alguna modificación correctora del modelo propuesto y nos obliga a repetir la dinámica de análisis (modelo alternativo y selección de variables) hasta dar con una solución satisfactoria. La herramienta básica para el diagnóstico del modelo es el análisis de los residuos, tanto a través de gráficos, como de tests que verifican la validez de las hipótesis asumidas en el ajuste del modelo lineal: \\(E(\\epsilon_i)=0 , \\ \\forall i=1, \\ldots, n \\ \\rightsquigarrow\\) bondad del ajuste o linealidad. \\(Var(\\epsilon_i)=\\sigma^2, \\ \\forall i \\ \\rightsquigarrow\\) Varianza constante (homocedasticidad). \\(\\epsilon \\sim N(0, \\sigma^2I) \\ \\rightsquigarrow\\) Normalidad de los errores. \\(Cov(\\epsilon_i, \\epsilon_j)=0, \\forall \\ i\\neq j \\ \\rightsquigarrow\\) Independencia de los errores. Si encontramos indicios de violación de alguna de ellas, en ocasiones podremos resolverlas a través de las soluciones que proponemos a continuación. Tanto las herramientas de diagnóstico como las soluciones propuestas para cuando encontramos problemas, son una ampliación del análisis de residuos que ya estudiamos para el modelo de regresión lineal simple. Aunque se pueden definir diferentes tipos de residuos, aquí nos concentramos en los que son de uso habitual en el diagnóstico de modelos lineales. 7.6.1 Tipos de Residuos Presentamos diversos tipos de residuos, útiles tanto para la diagnosis del modelo como para el análisis de influencia (detección de observaciones influyentes y/o raras o anómalas). Generalmente, los procedimientos de diagnóstico del modelo basados en residuos son gráficos, si bien en ocasiones disponemos de algunos tests basados en ellos. 7.6.1.1 Residuos comunes Los residuos comunes del modelo lineal \\(y=X\\beta+\\epsilon\\) consisten simplemente en las desviaciones entre los datos observados \\(y_i\\) y los predichos \\(\\hat{y}_i\\), esto es, los obtenidos de: \\[ \\textbf{e}=\\textbf{y}-\\hat{\\textbf{y}}=y-X\\hat{\\beta}=\\textbf{y}-X\\hat{\\beta}=(I-X(X&#39;X)^{-1}X&#39;)\\textbf{y} \\] cuando \\(X&#39;X\\) es no singular. Surge así una matriz básica en la definición de los residuos, denominada matriz gorro y definida por: \\[ H=X(X&#39;X)^{-1}X&#39;, \\] que tiene su importancia en la interpretación y redefinición de nuevos tipos de residuos, como veremos. A sus elementos nos referiremos como \\(h_{ij}\\). Esta matriz \\(H\\) es simétrica (\\(H&#39;=H\\)) e idempotente (\\(HH=H\\)), de dimensión \\(n \\times n\\) y de rango \\(p=rang(X)\\). En términos de \\(H\\), los residuos \\(\\textbf{e}\\) se pueden escribir como: \\[ \\textbf{e} = \\textbf{y}-\\hat{\\textbf{y}} = (I-H) \\textbf{y}, \\] esto es, \\[ e_i=(1-\\sum_{j=1}^n h_{ij}) \\, y_i=y_i-\\hat{y}_i, \\ \\ \\ i=1, \\ldots, n. \\] De esta forma se puede demostrar que la varianza de cada residuo viene dada por: \\[ Var(e_i)=(1-h_{ii})\\sigma^2, \\ \\ i=1, \\ldots, n, \\] y la correlación entre los residuos \\(e_i\\) y \\(e_j\\): \\[ Cor(e_i, e_j)=\\frac{-h_{ij}}{\\sqrt{(1-h_{ii})(1-h_{jj})}}. \\] 7.6.1.2 Residuos estandarizados. Son residuos de media cero y varianza aproximadamente unidad, definidos por: \\[ r_i=\\frac{e_i}{\\sqrt{s^2}}, \\qquad i=1, \\ldots, n, \\] donde \\(s^2\\) es la estimación habitual de \\(\\sigma^2\\) que da el cuadrado medio residual. Una modificación de estos ´residuos son los denominados residuos estudentizados que se interpretan de forma similar a estos. En los ejemplos introduciremos los procedimientos gráficos que podemos utilizar con este tipo de residuos para el estudio de la linealidad y homocedasticidad. Dado que la verificación de hipótesis se basa en los residuos del modelo, los procedimientos que utilizamos para verificarlas son los mismos a los descritos para el modelo RLS en la unidad anterior. La única diferencia es la existencia de más de una predictora. 7.6.2 Linealidad Si hay alguna variable explicativa que no ha sido incluida en el ajuste del modelo, representarla versus los residuos ayuda a identificar algún tipo de tendencia que dicha variable pueda explicar. Si no se detecta ninguna tendencia en el gráfico de dispersión en principio no tenemos ninguna evidencia que nos sugiera incorporar dicha variable al modelo para predecir mejor la respuesta. Estos gráficos son útiles también para detectar outliers y heterocedasticidad. 7.6.3 Homocedasticidad La heterocedasticidad, que es como se denomina el problema de varianza no constante, aparece generalmente cuando el modelo está mal especificado, bien en la relación de la respuesta con los predictores, bien en la distribución de la respuesta, bien en ambas cuestiones. La violación de la hipótesis de varianza constante, \\(Var(\\epsilon)=\\sigma^2 I\\), se detecta usualmente a través del análisis gráfico de los residuos: Gráficos de residuos versus valores ajustados \\(\\hat{y}_i\\).- Cuando aparece alguna tendencia como una forma de embudo o un abombamiento, etc., entonces decimos que podemos tener algún problema con la violación de la hipótesis de varianza constante para los errores. Gráficos de residuos versus predictores \\(\\textbf{x}_j\\).- Básicamente se interpretan como los gráficos de residuos versus valores ajustados \\(\\hat{y}_i\\). Es deseable que los residuos aparezcan representados en una banda horizontal sin tendencias alrededor del cero. Hay numerosos tests en la literatura para reconocer heterocedasticidad. Unos están basados en considerar la variabilidad de los residuos que consiguen explicar las variables explicativas sospechosas de inducir heterocedasticidad. Otros tests están basados en diferenciar las observaciones en grupos de varianza constante y comparar los ajustes obtenidos respecto a la hipótesis de tener una misma varianza común: El test de Breusch-Pagan. El test de Bartlett o el test de Levene. 7.6.4 Normalidad La hipótesis de normalidad de los errores \\(\\epsilon_i\\) en el modelo lineal justifica la utilización de los tests \\(F\\) y \\(t\\) para realizar los contrastes habituales y obtener conclusiones confiables a cierto nivel de confianza \\(1-\\alpha\\) dado. En muestras pequeñas, la no normalidad de los errores es muy difícil de diagnosticar a través del análisis de los residuos, pues éstos pueden diferir notablemente de los errores aleatorios \\(\\epsilon_i\\). En muestras grandes no se esperan demasiadas diferencias entre residuos y errores, y por lo tanto hacer un diagnóstico de normalidad sobre los residuos equivale prácticamente a hacerlo sobre los errores mismos. La forma habitual de diagnosticar no normalidad es a través de los gráficos qq de normalidad y de tests como el de Shapiro-Wilks, específico para normalidad, o el de bondad de ajuste de Kolmogorov-Smirnov. 7.6.5 Incorrelación Para los modelos RLM y MP asumimos que los errores observacionales están incorrelados dos a dos. Si esta hipótesis no es cierta, cabe esperar que un gráfico secuencial de los residuos manifieste alguna tendencia. Sin embargo, hay muchas formas en que los errores pueden estar correlados. De hecho, la independencia entre observaciones es una cuestión justificada básicamente por el muestreo realizado. Un gráfico de los residuos en función de la secuencia temporal en que se observaron los datos puede ayudar a apreciar un problema de correlación de los residuos. Los gráficos de autocorrelación ayudan a detectar correlación serial, es decir, que un residuo de pende de los residuos anteriores. Dichos gráficos consisten en representar cada residuo (excepto el primero) versus el residuo anterior en la secuencia temporal sospechosa de inducir la correlación. Un test habitual para detectar cierto tipo de correlación serial es el test de Durbin-Watson. 7.6.6 Soluciones a problemas detectados en el diagnóstico del modelo Las soluciones a los posibles problemas detectados en el diagnóstico son similares a las utilizadas para los modelos RLS: Propuesta de otros modelos adecuados a la distribución de la respuesta y su relación con los predictores (Modelos Lineales Generalizados que trataremos más adelante). Transformar la variable respuesta (Transformaciones de Box-Cox). Transformar las predictoras (Modelos de suavizado). Algunas de las soluciones, como las de transformar las predictoras mediante modelos de suavizado, tendrán una unidad especial de tratamiento ya que se tratan de modelos más generalistas que permiten ajustar muchos tipos de tendencias entre respuesta y predictoras. 7.6.7 Análisis de influencia En ocasiones hay algún subconjunto de los datos que influencia desproporcionadamente el ajuste del modelo propuesto, con lo cual las estimaciones y predicciones dependen mucho de él. Es interesante siempre, localizar este tipo de datos, si existen, y evaluar su impacto en el modelo. Si estos datos influyentes son “malos” (provienen de errores en la medición, o de condiciones de experimentación diferentes, etc.) habrían de ser excluidos del ajuste; si son “buenos,” esto es, efectivamente proceden de buenas mediciones aunque raras, contendrán información sobre ciertas características relevantes a considerar en el ajuste. En todo caso, es importante localizarlos, y para ello existen una serie de procedimientos basados en diversos estadísticos que presentamos a continuación. Hay diversos criterios para valorar la influencia de las observaciones en el ajuste, y en base a los cuales se proponen diversos estadísticos. Vamos a considerar tres de ellos: i) contribución a la estimación de los coeficientes; ii) influencia en la predicción y iii) influencia sobre la precisión de las estimaciones. 7.6.7.1 Sobre los coeficientes del modelo Se han construido diversas medidas para valorar la influencia de las observaciones en la estimación de los coeficientes del modelo. Entre ellas, las más habituales son: Distancia de Cook. Medida de influencia para una observación \\(y_i\\), basada en la distancia entre la estimación de mínimos cuadrados obtenida con las \\(n\\) observaciones, \\(\\hat{\\textbf{y}}=X \\hat{\\beta}\\), y la obtenida eliminando dicha observación, \\(\\hat{\\textbf{y}}^{(i)}\\). Una formulación habitual del estadístico de Cook es: \\[ D_i=\\frac{(\\hat{\\textbf{y}}-\\hat{\\textbf{y}}^{(i)})&#39;(\\hat{\\textbf{y}}-\\hat{\\textbf{y}}^{(i)})}{p s^2}=\\frac{(\\hat{\\beta}^{(i)}-\\hat{\\beta})&#39; X&#39;X (\\hat{\\beta}^{(i)}-\\hat{\\beta})}{p s^2}, \\ \\ i=1, \\ldots, n, \\] donde \\(\\hat{\\beta}^{(i)}\\) es el vector de parámetros estimados en la regresión \\(\\hat{\\textbf{y}}^{(i)}\\). Los puntos con un valor grande del estadístico \\(D_i\\) identifican observaciones tales que el hecho de incluirlas o no en el ajuste dan lugar a diferencias considerables en las estimaciones de los coeficientes. Generalmente se consideran como influyentes aquellas observaciones con un valor del estadístico \\(D_i&gt;1\\), pero se identifican como potencialemnte influyentes todas aquellas con \\(D_i&gt;4/n\\), con \\(n\\) el tamaño de la muestra. DFBETAS. Estadístico que indica cuánto cambia el coeficiente estimado \\(\\hat{\\beta}_j\\) en desviaciones estándar para un modelo dado cuando se excluye la \\(i\\)-ésima observación: \\[ DFBETAS_{j, i}=\\frac{\\hat{\\beta}_j-\\hat{\\beta}^{(i)}_j}{s^2_{(i)} C_{jj}^X}, \\quad j=0, 1, \\ldots, p; \\ i=1, \\ldots, n \\] donde \\(\\hat{\\beta}^{(i)}_j\\) es la j-ésima componente del vector \\(\\hat{\\beta}_{(i)}\\), y \\(C_{jj}^X\\) es el elemento \\(j\\) de la diagonal de \\((X&#39;X)^{-1}\\). De forma habitual se considera como potencialmente influyente una observación si \\(|DFBETAS_{j, i}|&gt;2/\\sqrt{n}\\), con \\(n\\) el tamaño muestral. 7.6.7.2 Influencia sobre las predicciones Para investigar la influencia de la \\(i\\)-ésima observación sobre los valores predichos por el modelo utilizamos el estadístico DFFITS. Se define el estadístico DFFITS para la observación i-ésima como: \\[ DFFITS_i = \\frac{\\hat{y}_i-\\hat{y}^{(i)}_i}{\\sqrt{s^2_{(i)} h_{ii}}}, \\ \\ i=1, \\ldots, n, \\] donde \\(\\hat{y}^{(i)}_i\\) es el valor predicho para \\(y_i\\) por el modelo sin utilizar en la estimación la observación \\(i\\). Así, \\(DFFITS_i\\) se puede interpretar como el número de desviaciones estándar que cambia la predicción de la \\(i\\)-ésima respuesta cuando dicha observación es excluida del ajuste. Generalmente, una observación para la que \\(|DFFITS_i|&gt;2 \\sqrt{p/n}\\) merece ser tratada con atención. 7.6.7.3 Influencia sobre la precisión de las estimaciones Los diagnósticos vistos hasta ahora cuantifican de algún modo el efecto de las observaciones en las estimaciones. Sin embargo, no proporcionan información alguna sobre la precisión conjunta del ajuste. La precisión de la estimación de \\(\\hat{\\beta}\\) se puede medir en función del estadístico \\(\\textsf{COVRATIO}\\). Si \\(COVRATIO_i&lt;1\\), excluir la \\(i\\)-ésima observación proporciona un ajuste más preciso; si \\(COVRATIO_i&gt;1\\), la \\(i\\)-ésima observación mejora la precisión de la estimación. En este manual no utilizaremos este criterio y nos centraremos en los puntos anteriores 7.6.8 Funciones para diagnóstico e influencia EN la unidad anterior mostramos como realizar los gráficos y test de diagnóstico para un modelo RLS. Esos gráficos se pueden utilizar también en los modelos tratados en esta unidad, pero además se muestran las funciones de la librería olsrr que pueden ser utilizadas para esta tarea. Concretamente: ols_plot_resid_stand(): gráfico secuencial de residuos estandarizados. ols_plot_resid_stud(): gráfico secuencial de residuos estudentizados. ols_plot_resid_stud_fit(): residuos estudentizados vs valores ajustados. ols_plot_resid_qq(): gráfico qq de normalidad. ols_test_normality(): tests de normalidad. ols_test_breusch_pagan(): Test de Bresuch-Pagan. Aunque la función por excelencia para obtener las medidas de influencia es influence.measures(), la librería olsrr presenta diversas funciones para este análisis con la ventaja de proporcionar herramientas gráficas y valores de detección, que permiten visualizar de forma rápida las posibles observaciones influyentes. Dichas funciones son: ols_plot_cooksd_chart(): proporciona la distancia de Cook. ols_plot_dfbetas(): proporciona los \\(DFBETAS\\). ols_plot_dffits(): proporciona \\(DFFITS\\). 7.6.9 Ejemplos Realizamos el diagnóstico y análisis de influencia de los modelos ajustados, tras el proceso de selección de variables. 7.6.9.1 Datos de Bosque En primer lugar, ajustamos el modelo correspondiente y obtenemos los valores de diagnóstico. # Modelos fit.bosque &lt;- lm(vol ~ d16 + ht, data = bosque) # Valores de diagnóstico diag.bosque &lt;- fortify(fit.bosque) Estudiamos los gráficos de diagnóstico para detectar residuos grandes (gráfico secuencial de residuos), linealidad y homocedasticidad (gráfico de residuos estandarizados versus valores ajustados), y normalidad (gráfico qq). ols_plot_resid_stand(fit.bosque) ggplot(diag.bosque, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ols_plot_resid_qq(fit.bosque) acf(diag.bosque$.stdresid) El gráfico de secuencia de los residuos indica que la observación 18 es potencialemente una observación anómala. Cuando realizamos el análisis de influencia deberemos verificar esta situación para considerar la posible eliminación de esta observación. El gráfico de residuos versus valores ajustados no muestra ningún tipo de tendencia (linealidad) ni comportamientos extraños que permitan pensar que se incumple la hipótesis de varianza constante. El gráfico de normalidad también muestra un comportamiento adecuado teniendo en cuenta que el tamaño muestral es muy pequeño. El gráfico de autocorelación no muestra dependencia entre los residuos, indicando que se cumple la hipótesis de independencia. Dado que no se ha detectado falta de linealidad entre residuos y valores ajustados no es necesario realizar el gráfico de residuos versus predictoras. Sin embargo, los mostramos aquí para ver el código necesario. ggplot(diag.bosque, aes(x = ht, y = .stdresid)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ggplot(diag.bosque, aes(x = d16, y = .stdresid)) + geom_point()+ geom_smooth(method = &quot;lm&quot;, se = FALSE) Como era de esperar los gráficos no muestran ningún tipo de tendencia. Realizamos ahora los tests necesarios para verificar las hipótesis de normalidad, homocedasticidad, e independencia. ols_test_normality(fit.bosque) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9281 0.1420 ## Kolmogorov-Smirnov 0.1544 0.6712 ## Cramer-von Mises 1.6812 0.0000 ## Anderson-Darling 0.5362 0.1485 ## ----------------------------------------------- ols_test_breusch_pagan(fit.bosque) ## ## Breusch Pagan Test for Heteroskedasticity ## ----------------------------------------- ## Ho: the variance is constant ## Ha: the variance is not constant ## ## Data ## ------------------------------- ## Response : vol ## Variables: fitted values of vol ## ## Test Summary ## ---------------------------- ## DF = 1 ## Chi2 = 0.8615473 ## Prob &gt; Chi2 = 0.353306 car::durbinWatsonTest(fit.bosque) ## lag Autocorrelation D-W Statistic p-value ## 1 0.1645488 1.487166 0.174 ## Alternative hypothesis: rho != 0 Todos los tests resultan no significativos indicando que se cumplen las hipótesis del modelo. Para la hipótesis de normalidad nos debemos fijar en los resultados de Kolmogorov-Smirnov que tiene un mejor comportamiento, desde el punto de vista estadístico, que Shapiro-Wilk. En caso de discrepancias entre ellos nos debemos quedar con Kolmmogorov-Smirnov. A pesar de que se cumplen las hipótesis del modelo, obtenemos las medidas de influencia asociadas con el modelo ajustado: ols_plot_cooksd_chart(fit.bosque) ols_plot_dfbetas(fit.bosque) ols_plot_dffits(fit.bosque) La distancia de Cook muestra dos observaciones (1 y 20) como potencialmente influyentes utilizando el punto de corte más restrictivo. Si utilizamos el punto de corte estándar que determina como influyente a los que tienen una distancia de Cook mayor que 1, ninguna de ellas sería clasificada como influyente. EL resto de medidas de influencia siguen mostrando a las observaciones 1 y 20 como potencialmente influyentes, pero dado que se cumplen las hipótesis del modelo no nos planteamos la eliminación de dichas observaciones. Además, con tamaños de muestras tan pequeños sólo nos planteamos su eliminación si es la única solución para que se cumplan las hipótesis del modelo. 7.6.9.2 Datos de Concentración Ajustamos el modelo y obtenemos los valores de diagnóstico. # Modelos fit.concen &lt;- lm(concen ~ p.cuerpo + dosis, data = concentracion) # Valores de diagnóstico diag.concen &lt;- fortify(fit.concen) Estudiamos los gráficos de diagnóstico para detectar residuos grandes (gráfico secuencial de residuos), linealidad y homocedasticidad (gráfico de residuos estandarizados versus valores ajustados), y normalidad (gráfico qq). ols_plot_resid_stand(fit.concen) ggplot(diag.concen, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ols_plot_resid_qq(fit.concen) acf(diag.concen$.stdresid) Aunque todos los gráficos parecen mostrar comportamientos adecuados, el gráfico de residuos versus ajustados muestra un punto alejado (valor ajustado alto) del resto lo que podría indicar que debemos tratar ese valor como anómalo y considerar su eliminación del banco de datos. Antes de tomar una decisión revisamos toda la batería de gráficos y tests de diagnóstico e influencia. ggplot(diag.concen, aes(x = p.cuerpo, y = .stdresid)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ggplot(diag.concen, aes(x = dosis, y = .stdresid)) + geom_point()+ geom_smooth(method = &quot;lm&quot;, se = FALSE) En los gráficos de residuos versus predictoras no se observan comportamientos anómalos. Realizamos ahora los tests necesarios para verificar las hipótesis de normalidad, homocedasticidad, e independencia. ols_test_normality(fit.concen) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9544 0.4672 ## Kolmogorov-Smirnov 0.1414 0.7919 ## Cramer-von Mises 5.4464 0.0000 ## Anderson-Darling 0.3769 0.3742 ## ----------------------------------------------- ols_test_breusch_pagan(fit.concen) ## ## Breusch Pagan Test for Heteroskedasticity ## ----------------------------------------- ## Ho: the variance is constant ## Ha: the variance is not constant ## ## Data ## ---------------------------------- ## Response : concen ## Variables: fitted values of concen ## ## Test Summary ## ----------------------------- ## DF = 1 ## Chi2 = 0.05255342 ## Prob &gt; Chi2 = 0.8186782 car::durbinWatsonTest(fit.concen) ## lag Autocorrelation D-W Statistic p-value ## 1 -0.0227244 1.762427 0.528 ## Alternative hypothesis: rho != 0 Todos los tests resultan no significativos indicando que se cumplen las hipótesis del modelo. En último lugar realizamos el análisis de influencia: ols_plot_cooksd_chart(fit.concen) ols_plot_dfbetas(fit.concen) ols_plot_dffits(fit.concen) La distancia de Cook muestra que la observación en la posición 3 es claramente influyente. De hecho, también es influyente en los coeficientes del modelo, y en el valor ajustado. Pasamos a eliminar dicha observación y a ajustar un nuevo modelo. Comenzaremos con el modelo saturado e iremos completando todo el análisis. Creamos el nuevo banco de datos y ajustamos el nuevo modelo: # Datos sin observación 3 concentracion &lt;- concentracion[-3, ] # Ajuste del modelo fit.concen &lt;- lm(concen ~ p.cuerpo + dosis, data = concentracion) # Modelo ajustado tab_model(fit.concen)   concen Predictors Estimates CI p (Intercept) 0.33 -0.08 – 0.75 0.110 p cuerpo -0.00 -0.04 – 0.03 0.797 dosis 0.88 -6.37 – 8.12 0.800 Observations 18 R2 / R2 adjusted 0.005 / -0.128 # Bondad del ajuste glance(fit.concen) Tabla 7.9: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.00483-0.1280.07620.03640.964222.4-36.9-33.30.08711518 EL test \\(F\\) de la regresión nos indica que la variables predictoras no están relacionadas con la respuesta (p-valor &gt; 0.05), con lo que no tendría sentido seguir trabajando con este modelo y la conclusión obtenida es que no hemos podido obtener una relación entre concentración y peso cuerpo, peso del hígado, y dosis. El efecto de eliminar una observación (a pesar de que se cumplen las hipótesis del modelo), es que la débil relación que habíamos establecido entre concentración frente a peso del cuerpo y dosis resulta inexistente. En este caso debe ser el investigador el que decida entre las dos opciones: Quedarse con un modelo malo (sin quitar la observación influyente) que verifica las hipótesis. Concluir que no existe relación entre respuesta y predictoras, desechando el experimento realizado. 7.6.9.3 Datos de Papel Ajustamos el modelo y obtenemos los valores de diagnóstico. # Modelos fit.papel &lt;- lm(tension ~ madera + I(madera^2), data = papel) # Valores de diagnóstico diag.papel &lt;- fortify(fit.papel) Estudiamos los gráficos de diagnóstico para detectar residuos grandes (gráfico secuencial de residuos), linealidad y homocedasticidad (gráfico de residuos estandarizados versus valores ajustados), y normalidad (gráfico qq). ols_plot_resid_stand(fit.papel) ggplot(diag.papel, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) ols_plot_resid_qq(fit.papel) acf(diag.papel$.stdresid) No se observan residuos excesivamente grandes, ni comportamientos anómalos pero si cierta autocorrelación en los residuos debido a la propia estructura del modelo polinómico considerado. Realizamos los tests de diagnóstico: ols_test_normality(fit.papel) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9113 0.0783 ## Kolmogorov-Smirnov 0.198 0.3942 ## Cramer-von Mises 1.5965 1e-04 ## Anderson-Darling 0.6399 0.0806 ## ----------------------------------------------- ols_test_breusch_pagan(fit.papel) ## ## Breusch Pagan Test for Heteroskedasticity ## ----------------------------------------- ## Ho: the variance is constant ## Ha: the variance is not constant ## ## Data ## ----------------------------------- ## Response : tension ## Variables: fitted values of tension ## ## Test Summary ## ---------------------------- ## DF = 1 ## Chi2 = 0.2755593 ## Prob &gt; Chi2 = 0.5996267 car::durbinWatsonTest(fit.papel) ## lag Autocorrelation D-W Statistic p-value ## 1 0.6040252 0.6974667 0 ## Alternative hypothesis: rho != 0 Se verifican las hipótesis de homocedasticidad y normalidad, y como era de espera no se cumple la hipótesis de incorrrelación. Dado que este incumplimiento se debe a la propia estructura del modelo no tendremos en cuenta este resultado par concluir sobre este modelo. En último lugar realizamos el análisis de influencia: ols_plot_cooksd_chart(fit.papel) ols_plot_dfbetas(fit.papel) ols_plot_dffits(fit.papel) Tenemos dos observaciones (18 y 19) que se detectan como potencialmente influyentes (distancia de Cook) y que podrían ser consideradas para su eliminación. Como el modelo tiene un buen ajuste y cumple con las hipótesis consideramos el modelo como válido. 7.7 Predicción El proceso de predicción en este tipo de modelos es similar al de los modelos de regresión lineal simple. Si \\(X_0 \\in \\mathbb{R}^p\\) representa un vector fijo de valores de las variables explicativas contenidas en la matriz de diseño \\(X\\), podemos predecir la respuesta \\(y\\) en \\(X_0\\) a través del modelo ajustado con \\[ \\hat{y}=X_0 \\hat{\\beta}, \\] pero el error asociado a la estimación depende de la situación que estemos prediciendo: 7.7.1 Estimación de la respuesta media. La varianza asociada a dicha estimación viene dada por: \\[ Var[\\hat{E}(y|X_0)]=\\sigma^2 X_0(X&#39;X)^{-1}X_0&#39;. \\] Un intervalo de confianza a nivel \\(1-\\alpha\\) está basado en la distribución \\(t-Student\\): \\[ \\hat{y}_{X_0} \\pm t_{(n-p, 1-\\alpha/2)} \\ \\sqrt{s^2 X_0(X&#39;X)^{-1}X_0&#39;}, \\] siendo \\(t_{(n-p, 1-\\alpha/2)}\\) el cuantil \\(1-\\alpha/2\\) de una distribución \\(t-Student\\) con \\(n-p\\) grados de libertad, con \\(p\\) el número de coeficientes en el modelo y \\(n\\) el número de datos. 7.7.2 Predicción de nuevas observaciones. La predicción de la respuesta \\(y\\) para un determinado valor \\(X_0\\) de las variables explicativas involucra más incertidumbre que la estimación de un promedio. En este caso, la varianza asociada a la predicción es: \\[ Var(\\hat{y}|X_0)=\\sigma^2 (1+ X_0(X&#39;X)^{-1}X_0&#39;). \\] Un intervalo de confianza a nivel \\(1-\\alpha\\) para dicha predicción viene dado por: \\[ \\hat{y}_{X_0} \\pm t_{(n-p, 1-\\alpha/2)} \\ \\sqrt{s^2 \\ (1+X_0&#39;(X&#39;X)^{-1}X_0)}. \\] 7.7.3 Ejemplos Obtenemos únicamente la predicción de la respuesta media para ciertos valores de las predictoras y los gráficos de predicción marginales. 7.7.3.1 Datos de bosque Estamos interesados en conocer el volumen de madera que podemos obtener para las combinaciones de d16 y ht dadas por (10, 90), (12, 95), (14, 100) y (16, 105). # cargamos datos de predicción newpred &lt;- data.frame(d16 = c(10, 12, 14, 16), ht = c(90, 95, 100, 105)) # Predicción para la media de la respuesta # Opción interval = &quot;confidence&quot; newdata &lt;- data.frame(newpred, predict(fit.bosque, newpred, interval = &quot;confidence&quot;)) round(newdata, 2) Tabla 7.10: d16htfitlwrupr 109029.125&nbsp;&nbsp;33.2 129547.344.849.8 1410065.563.467.7 1610583.780.287.2 Veamos ahora las predicciones marginales de cada variable: # Gráfico del ajuste plot_model(fit.bosque, &quot;pred&quot;, ci.lvl = 0.95, show.data = TRUE, title = &quot; &quot;) ## $d16 ## ## $ht 7.7.3.2 Datos de papel Estamos interesados en conocer la tensión del papel para los contenidos de madera dados por 4, 8, y 12. # cargamos datos de predicción newpred &lt;- data.frame(madera = c(4, 8, 12)) # Predicción para la media de la respuesta # Opción interval = &quot;confidence&quot; newdata &lt;- data.frame(newpred, predict(fit.papel, newpred, interval = &quot;confidence&quot;)) round(newdata, 2) Tabla 7.11: maderafitlwrupr 430.227.533&nbsp;&nbsp; 846.843.650&nbsp;&nbsp; 1243.139.946.4 Veamos ahora las predicciones marginales de cada variable: # Gráfico del ajuste plot_model(fit.papel, &quot;pred&quot;, ci.lvl = 0.95, show.data = TRUE, axis.title = c(&quot;Contenido madera&quot;, &quot;Tensión&quot;), title = &quot; &quot;) ## $madera 7.8 Ejercicios A continuación, se presenta una colección de ejercicios referidos a los modelos de regresión. Los pasos a seguir para la obtención del modelo son los que hemos ido desarrollando: representación gráfica y propuesta de modelo, ajuste, bondad de ajuste, diagnóstico y predicción. En caso de encontrar problemas con el diagnóstico se deberá proponer un nuevo modelo alternativo. Ejercicio 1. Se propone a una empresa que fabrica vasos de cristal un nuevo proceso de control de calidad. Hasta ahora la empresa seleccionaba una caja de vasos al final de la fabricación y observaba si había alguno roto. Esto provocaba un gran gasto ya que en caso de encontrar algún defecto la caja se desembala y los vasos vuelven a la cadena de embalaje. Ahora se propone seleccionar vasos antes de embalar y determinar así el porcentaje de defectos. Se desea saber si ambos porcentajes están relacionados. Los datos aparecen a continuación: # carga de datos cajas &lt;- c(3.0, 3.1, 3.0, 3.6, 3.8, 2.7, 3.1, 2.7, 2.7, 3.3, 3.2, 2.1, 3.0, 2.6) vasos &lt;- c(3.1, 3.9, 3.4, 4.0, 3.6, 3.6, 3.1, 3.6, 2.9, 3.6, 4.1, 2.6, 3.1, 2.8) ejer01 &lt;- data.frame(cajas, vasos) Ejercicio 2. En 1929 Edwin Hubble investiga la relación entre la distancia (en megaparsecs. 1 parsec=3.26 años luz) de una galaxia a la tierra y la velocidad (en Km/sg) con la cual parece retroceder. Observo que las galaxias aparecen alejarse de nosotros no importa cual sea la dirección en que miremos. Se piensa de hecho que esto es el resultado del ”Big Bang”. Hubble esperaba aportar conocimiento sobre la formación del universo y sobre cual podría ser su evolución en el futuro. Los datos que recogió incluyen las distancias de la tierra a 24 galaxias, así como sus correspondientes velocidades de retroceso. El objetivo principal del estudio que Hubble llevo a cabo era determinar la edad del universo, y para ello establece lo que se conoce hasta ahora como la ley de Hubble: \\[V = H_0*D\\] donde \\(V\\) es la velocidad, \\(D\\) es la distancia, y \\(H_0\\) es la constante de Hubble. distancia &lt;- c(.032, .034, .214, .263, .275, .275, .45, .5, .5, .63, .8, .9, .9, .9, .9, 1.0, 1.1, 1.1, 1.4, 1.7, 2.0, 2.0, 2.0, 2.0) velocidad &lt;- c(170, 290, -130, -70, -185, -220, 200, 290, 270, 200, 300, -30, 650, 150, 500, 920, 450, 500, 500, 960, 500, 850, 800, 1090) ejer02 &lt;- data.frame(distancia, velocidad) (HINT: En primer lugar debes transformar el modelo teórico propuesto para expresarlo en términos de un modelo RLS. Recuerda almacenar las transformaciones en tu banco de datos para proceder con el ajuste del modelo.) Ejercicio 3. Un grupo de ingenieros agrónomos esta estudiando la evolución de un proceso infeccioso sobre un conjunto de plantas. En concreto durante un período de días se calcula de forma aproximada la fracción de infección de dichas plantas. Por este motivo, dos días consecutivos pueden tener fracciones de infección inferiores. Para evitar esto se proponen dos modelos teóricos: \\[(I) \\text{ } y = \\beta_0 x^{\\beta_1}\\] \\[(II) \\text{ } y = \\beta_0 + \\beta_1 log(x)\\] donde y es el grado de infección y x el número de días transcurridos dia &lt;- 1:200 infecc &lt;- c(0.02063762, 0.05637206, 0.11889346, 0.11376972, 0.13772089, 0.19055130, 0.18509772, 0.16887353, 0.19753055, 0.21835949, 0.26677238, 0.26360653, 0.27772497, 0.28447172, 0.28300082, 0.34108177, 0.32594214, 0.28675461, 0.34971616, 0.33537176, 0.33217888, 0.35748261, 0.34925483, 0.36278067, 0.37211460, 0.35783240, 0.41498583, 0.40769174, 0.38800213, 0.44174297, 0.43087261, 0.42190606, 0.45097338, 0.45570700, 0.45946960, 0.46153400, 0.46340109, 0.45549254, 0.45487365, 0.45750686, 0.45521341, 0.46881463, 0.45141048, 0.52372846, 0.50803021, 0.46482596, 0.48254773, 0.48449405, 0.51255671, 0.49833262, 0.50802495, 0.50526564, 0.50777983, 0.53873568, 0.50950327, 0.54693458, 0.48815063, 0.53327501, 0.52645577, 0.53063462, 0.53618898, 0.52077545, 0.52633078, 0.51474555, 0.51575426, 0.54528626, 0.55015967, 0.54419107, 0.56346905, 0.58787669, 0.53886562, 0.50427534, 0.57230842, 0.53970820, 0.54179538, 0.57769618, 0.55308538, 0.53593047, 0.56550374, 0.56060245, 0.56496884, 0.57400395, 0.56030226, 0.58199322, 0.56606007, 0.57844415, 0.59505931, 0.58311616, 0.56916054, 0.59989923, 0.59801493, 0.59031303, 0.58529898, 0.56912505, 0.61003513, 0.57193641, 0.62878888, 0.61677661, 0.58247460, 0.56770688, 0.57505675, 0.59541545, 0.58634056, 0.58530427, 0.57418797, 0.59326985, 0.57940758, 0.56266765, 0.58932866, 0.61620602, 0.58719856, 0.61173102, 0.56806743, 0.60015458, 0.61248238, 0.60893367, 0.60582869, 0.59169408, 0.58829584, 0.58557803, 0.60917339, 0.58862023, 0.59849746, 0.60391548, 0.64663334, 0.59742612, 0.61587231, 0.61341390, 0.59329848, 0.61178139, 0.64276168, 0.62355522, 0.61599580, 0.60735889, 0.57537341, 0.63968664, 0.58846078, 0.63307852, 0.65706008, 0.59059116, 0.63408846, 0.61538542, 0.58975607, 0.59146830, 0.59028687, 0.61224876, 0.59417456, 0.63770437, 0.66647829, 0.59925939, 0.64127259, 0.64141050, 0.63317968, 0.60686830, 0.62514131, 0.62241142, 0.63976259, 0.62153212, 0.64899315, 0.62242964, 0.65143794, 0.60985758, 0.60609047, 0.69656194, 0.62384676, 0.63858650, 0.64578674, 0.62380855, 0.64424572, 0.64170765, 0.63043627, 0.63646096, 0.63488074, 0.67853395, 0.62153691, 0.61483840, 0.63790480, 0.64374543, 0.64664922, 0.62913057, 0.61740673, 0.66430865, 0.63241999, 0.62246721, 0.63541282, 0.63655235, 0.66304830, 0.64289529, 0.65662894, 0.63190605, 0.64652159, 0.63607656, 0.64479640, 0.62532881, 0.61734833, 0.68383389, 0.65622608, 0.61950582, 0.63262438, 0.62145169) ejer03 &lt;- data.frame(dia, infecc) Los modelos teóricos anteriores se pueden transformar a modelos de regresión lineal simple sin muchos problemas. Para el modelo (I) consideramos la transformación logarítmica: \\[log(y) = log(\\beta_0) + \\beta_1 log(x) \\longrightarrow y&#39; = \\beta_0 + \\beta_1 x&#39;\\] donde el \\(&#39;\\) indica la nueva variable o parámetro. Podemos estudiar el comportamiento lineal obteniendo dichas variables, y volver al modelo original utilizando las transformaciones. Para el modelo (II) ya viene expresado como un modelo lineal donde únicamente tenemos que obtener la variable predictora transformada mediante la función logaritmo. Ejercicio 4. Se trata de determinar la pérdida de color sufrida por cierto compuesto cuando es sometido a altas temperaturas. Los datos recogidos son los siguientes: temperatura &lt;- c(460, 450, 440, 430, 420, 410, 450, 440, 430, 420, 410, 400, 420, 410, 400) perdida &lt;- c(0.3, 0.3, 0.4, 0.4, 0.6, 0.5, 0.5, 0.6, 0.6, 0.6, 0.7, 0.6, 0.6, 0.6, 0.6) ejer04 &lt;- data.frame(temperatura, perdida) Ejercicio 5. Karl Pearson recogió información sobre 1100 familias en Inglaterra en el periodo de 1893 a 1898. En particular este banco de datos contiene las alturas de las madres y las hijas de dichas familias. En concreto se registran las alturas de las hijas mayores de 18 años y las madres de menos de 65 años. Originalmente se estaba interesado en estudiar una posible asociación entre la altura de las madres y las hijas ¿Que podríamos concluir a la vista de los datos? las variables recogidas son: “Mheight” (altura de la madre) y “Dheight” (altura de la hija) data(&quot;heights&quot;) ejer05 &lt;-heights Ejercicio 6. Se realiza un estudio de campo para conocer el desarrollo de cierta especie de pez del lago lakemary en EEUU. Para medir el desarrollo se establece la edad de cada pez capturado mediante un procedimiento proporcionado por los biólogos. Además se mide la longitud del pez para tratar de establecer el estado de maduración de cada ejemplar. La investigación trata de relacionar la longitud del pez con su edad para determinar el número de capturas permitidas. Las variables recogidas son: “Age” (edad del pez), y “Length” (longitud del pez en mm). data(&quot;lakemary&quot;) ejer06 &lt;-lakemary Ejercicio 7. Se realiza un estudio para determinar el tiempo de erupción del geyser (Old Faithful Geyser, dentro del parque nacional de Yellowstone) a partir del tiempo de espera entre dos erupciones consecutivas. Se trata de analizar la información para determinar el periodo de visitas. Para ellos se recogieron datos durante un periodo determinado que se considera estándar para establecer la distribución de erupciones. Las variables consideradas son: “Duration” (duración de la erupción en segundos) y “Interval” (tiempo de espera entres dos erupciones consecutivas). data(&quot;geyser&quot;) ejer07 &lt;-geyser Ejercicio 8. Los datos muestran el porcentaje de calorías totales obtenidas de carbohidratos complejos, para veinte diabéticos dependientes de insulina que habían seguido una dieta alta en carbohidratos durante seis meses. Se consideró que el cumplimiento del régimen estaba relacionado con la edad (en años), age, el peso corporal (relativo al peso “ideal” para la altura), weight, y otros componentes de la dieta como el porcentaje de proteínas ingeridas. Los datos corresponden con la tabla 6.3 de Dobson (2002). ejer08 &lt;- read_csv(&quot;https://goo.gl/Grm8xM&quot;, col_types = &quot;dddd&quot;) Ejercicio 9. Es bien sabido que la concentración de colesterol en el suero sanguíneo aumenta con la edad, pero es menos claro si el nivel de colesterol también está asociado con el peso corporal. Los datos muestran para una treinta de mujeres el colesterol sérico (milimoles por litro), la edad (años) y el índice de masa corporal (peso dividido por la altura al cuadrado, donde el peso se midió en kilogramos y la altura en metros). Los datos corresponden con la tabla 6.17 de Dobson (2002). ejer09 &lt;- read_csv(&quot;https://goo.gl/EKXWRc&quot;, col_types = &quot;ddd&quot;) Ejercicio 10. En un estudio sobre las diferentes clases de queso cheddar que se fabrican en LaTrobe Valley de Victoria, Australia, se analizaron muestras de queso por su composición química: concentración de ácido acético (escala logarítmica); concentración de sulfuro de hidrógeno (escala logarítmica); y la concentración de ácido láctico. Por otro lado, se paso una muestra de cada uno de ellos a un conjunto de catadores y se registro la puntuación obtenida por cada uno de ellos. Estamos interesados en relacionar la puntuación final de los catadores con los resultados del análisis químico. ejer10 &lt;- read_csv(&quot;https://goo.gl/V4lDNs&quot;, col_types = &quot;dddd&quot;) Ejercicio 11. Los datos correspondientes a esta base de datos muestran la producción, Q, en toneladas, la mano de obra, L, en horas, y el capital, K, en horas máquina, de 14 empresas de un sector industrial. Se desea ajustar los datos a la función de producción Cobb-Douglas dada por: \\[Q = A L^l K^k e^{\\epsilon}\\] Identifica el objetivo u objetivos del problema propuesto. Describe el tipo de variables involucradas para el modelo propuesto. Escribe los modelos, identifica el tipo, e indica el número de parámetros involucrados. Ajusta los modelos mediante el proceso de selección de variables que consideres más adecuado. Describe los modelos obtenidos (ecuación del modelo) interpretando en términos económicos los coeficientes estimados de dicho modelo, y las medidas de bondad de ajuste de cada uno de ellos. Realiza el diagnóstico del modelo ajustado indicando los gráficos utilizados y las conclusiones obtenidas. Si el modelo debe ser mejorados indica como lo haces, y describe los resultados del nuevo modelo obtenido. ¿Cuál es la predicción de la producción media para una empresa con 1900 horas de trabajo y 475 de capital? ¿Cuál consideras que es la combinación óptima para determinar las empresas más eficientes en términos de productividad?. ejer11 &lt;- read_csv(&quot;https://bit.ly/2UIq9F9&quot;, col_types = &quot;dddd&quot;) ejer11 &lt;- ejer11 %&gt;% mutate_if(sapply(ejer11, is.character), as.factor) Ejercicio 12. La producción de cereales viene determinada principalmente por las condiciones climáticas previas a la recolección. En concreto se recogen las condiciones climáticas en diferentes años. Las características medidas son: anyo = año de la medición. preinv = precipitación de invierno. tempmay = temperatura de mayo. prejun = precipitación de junio. tempjun = temperatura de junio. prejul = precipitación de julio. tempjul = temperatura de julio. preago = precipitación de agosto. tempago = temperatura de agosto. produccion = producción de cereales. Para el banco de datos correspondiente Propón el tipo de modelo a utilizar. Selecciona el mejor modelo basado en el AIC. Expresa el modelo obtenido y extrae todas las conclusiones que se deriven de él. ¿Crees que un procedimiento de selección basado en el test F proporcionaría el mismo modelo? Las variables no incluidas en dicho modelo puede considerarse que no contribuyen a explicar la producción de cereales. ¿Qué haces para comprobar esto? ¿Las variables incluidas contribuyen de forma significativa a explicar la producción de cereales? Realiza un análisis de influencia y comenta los resultados obtenidos. ¿Crees necesario plantear un nuevo modelo? Comprueba las hipótesis sobre el modelo ajustado y comenta los resultados. Si resulta necesario propón un modelo alternativo y analízalo de forma completa. lectura &lt;- read.table(&quot;https://goo.gl/Yi5g6S&quot;, header = TRUE) ejer12 &lt;- as_tibble(lectura) Ejercicio 13. En un estudio medio ambiental sobre la diversidad de especies de tortuga en las islas Galápagos se recogió información sobre el número de especies endémicas (Endemics), así como el área de la isla (área), la altura del pico más alto de a isla (Elevation), la distancia a la isla más cercana (Nearest), la distancia a la isla de Santa Cruz (Scruz), y el área de la isla más próxima (Adjacent). El estudio está interesado las condiciones que pueden afectar a un mayor número de especies endémicas de tortuga sin tener en cuenta el número total de especies presentes. Identifica la variable respuesta, las predictoras, y el tipo de cada una de ellas. Realiza e interpreta los gráficos individuales descriptivos entre la respuesta y cada predictora de forma individual. Para tratar de linealizar las relaciones entre respuesta y predictora se transforman tomas las variables con la función logaritmo neperiano. ¿Cómo se interpretan los gráficos individuales descriptivos entre las variables transformadas? ¿Qué tipo de modelo parece el más adecuado para esta situación experimental? Escribe la forma reducida de dicho modelo. Partiendo del modelo más complejo y utilizando el AIC como criterio de selección, escribe la ecuación del modelo resultante del proceso de selección. ¿Qué podemos decir de la bondad del ajuste del modelo obtenido? ¿Cómo interpretamos los gráficos y test de diagnóstico asociados con el modelo obtenido? Realiza un análisis de influencia y si lo consideras necesario ajusta un nuevo modelo y analízalo. En función del modelo obtenido, construye diferentes escenarios para predecir el número de especies en una isla en función de las variables predictoras presentes en él. ¿Cuáles son las condiciones óptimas para la determinación de especies endémicas? Endemics &lt;- c(23, 21, 3, 9, 1, 11, 0, 7, 4, 2, 26, 35, 17, 4, 19, 89, 23, 2, 37, 33, 9, 30, 65, 81, 95, 28, 73, 16, 8, 12) Area &lt;- c(25.09, 1.24, 0.21, 0.1, 0.05, 0.34, 0.08, 2.33, 0.03, 0.18, 58.27, 634.49, 0.57, 0.78, 17.35, 4669.32, 129.49, 0.01, 59.56, 17.95, 0.23, 4.89, 551.62, 572.33, 903.82, 24.08, 170.92, 1.84, 1.24, 2.85) Elevation &lt;- c(346, 109, 114, 46, 77, 119, 93, 168, 71, 112, 198, 1494, 49, 227, 76, 1707, 343, 25, 777, 458, 94, 367, 716, 906, 864, 259, 640, 147, 186, 253) Nearest &lt;- c(0.6, 0.6, 2.8, 1.9, 1.9, 8, 6, 34.1, 0.4, 2.6, 1.1, 4.3, 1.1, 4.6, 47.4, 0.7, 29.1, 3.3, 29.1, 10.7, 0.5, 4.4, 45.2, 0.2, 0.6, 16.5, 2.6, 0.6, 6.8, 34.1) Scruz &lt;- c(0.6, 26.3, 58.7, 47.4, 1.9, 8, 12, 290.2, 0.4, 50.2, 88.3, 95.3, 93.1, 62.2, 92.2, 28.1, 85.9, 45.9, 119.6, 10.7, 0.6, 24.4, 66.6, 19.8, 0, 16.5, 49.2, 9.6, 50.9, 254.7) Adjacent &lt;- c(1.84, 572.33, 0.78, 0.18, 903.82, 1.84, 0.34, 2.85, 17.95, 0.1, 0.57, 4669.32, 58.27, 0.21, 129.49, 634.49, 59.56, 0.1, 129.49, 0.03, 25.09, 572.33, 0.57, 4.89, 0.52, 0.52, 0.1, 25.09, 17.95, 2.33) ejer13 &lt;- data.frame(Endemics, Area, Elevation, Nearest, Scruz, Adjacent) "],["anova.html", "Unidad 8 Modelos ANOVA 8.1 Bancos de datos 8.2 Modelos ANOVA 1 vía 8.3 Modelos ANOVA dos vías 8.4 Estimación y bondad de ajuste del modelo 8.5 Comparación y selección de modelos 8.6 Diagnóstico 8.7 Predicción 8.8 Ejercicios", " Unidad 8 Modelos ANOVA Los modelos ANOVA surgen cuando la variable o variables predictoras son de tipo categórico, es decir, factores con diferentes niveles de clasificación, de forma que cada sujeto es medido (respecto de la respuesta) para una combinación específica de los factores considerados. La variable respuesta sigue siendo de tipo numérico y el objetivo principal es el estudio de la media para los diferentes niveles del factor o combinaciones de los factores. No solo se está interesado en comparar los diferentes grupos, sino además en cuantificar numéricamente esas diferencias. La principal diferencia con los modelos de regresión es que en este caso no modelizamos toda la respuesta observada sino la media observada del conjunto de observaciones para cada nivel del factor. Además, veremos como estos modelos pueden ser descritos en términos de un modelo lineal de regresión lo que nos permite utilizar parte de los procesos de descripción, análisis y diagnóstico utilizamos en los capítulos anteriores. En cada punto de este capítulo estudiaremos las similitudes y diferencias con los modelos de regresión. 8.1 Bancos de datos Si las variables explicativas son de tipo factor, el análisis preliminar se realiza mediante gráficos de cajas. Estos gráficos sirven para visualizar relaciones entre una variable continua y un factor. En estos casos, hablar de relación / asociación equivale a hablar de diferencias en la variable continua respecto de los niveles (categorías) del factor. Tales diferencias se detectan cuando los diagramas de cajas no muestran solapamientos en la escala de la variable respuesta. En los modelos de dos vías podremos realizar además un gráfico de interacción, que es un gráfico de líneas donde se representan las medias de las diferentes combinaciones de niveles del factor, y que nos permite establecer una primera conclusión sobre el comportamiento conjunto de ambos factores. Veamos los diferentes bancos de datos que iremos analizando a lo largo de la unidad. Ejemplo 1. Datos de Insecticidas. Este ejemplo contiene los datos de un experimento agronómico para conocer el efecto de diferentes insecticidas (spray) sobre el número de insectos vivos (count) tras un periodo de tratamiento. Cargamos los datos y realizamos el gráfico descriptivo: data(InsectSprays) insecticidas &lt;- InsectSprays ggplot(insecticidas,aes(x = spray, y = count)) + geom_boxplot() Se aprecia como el número de insectos vivos es superior cuando usamos los sprays A, B, y F (con medias muy similares). El resto de sprays muestran (medias) una supervivencia inferior. Se observan como dos grupos de sprays, uno con medias altas y otro con medias bajas. Ejemplo 2. Datos de Envasado. Se desea estudiar la fabricación de cuatro tipos de máquinas automáticas (maquina) en el cortado de piezas de embutido para envasado. Para ello se toman datos del número de envases sin defecto (produccion) que produce cada máquina durante periodos de una hora. Cargamos los datos y realizamos el gráfico descriptivo: maquina &lt;- c(rep(&quot;M1&quot;, 4),rep(&quot;M2&quot;, 4),rep(&quot;M3&quot;, 4),rep(&quot;M4&quot;, 4)) produccion &lt;- c(103, 115, 101, 105, 109, 106, 116, 124, 104, 98, 117, 99, 128, 117, 121, 130) envasado &lt;- data.frame(maquina, produccion) ggplot(envasado,aes(x = maquina, y = produccion)) + geom_boxplot() Cada máquina muestra un nivel de envases sin defecto diferente. La máquina M4 es la que muestra mejores resultados y la M3 los peores. Ejemplo 3. Datos de venenos. Se ha realizado un experimento para comprobar la efectividad de diferentes antídotos (AA, AB, AC y AD) frente a diferentes venenos (VA, VB y VC). Para ello se recoge el tiempo de reacción (tiempo) que cada antídoto tarda en hacer efecto para cada veneno. Cargamos los datos y realizamos el gráfico descriptivo: tiempo &lt;- c(0.31, 0.45, 0.46, 0.43, 0.36, 0.29, 0.4, 0.23, 0.22, 0.21, 0.18, 0.23, 0.82, 1.1, 0.88, 0.72, 0.92, 0.61, 0.49, 1.24, 0.3, 0.37, 0.38, 0.29, 0.43, 0.45, 0.63, 0.76, 0.44, 0.35, 0.31, 0.4, 0.23, 0.25, 0.24, 0.22, 0.45, 0.71, 0.66, 0.62, 0.56, 1.02, 0.71, 0.38, 0.3, 0.35, 0.31, 0.33) antidoto &lt;- factor(c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4), labels=c(&quot;AA&quot;, &quot;AB&quot;, &quot;AC&quot;, &quot;AD&quot;)) veneno &lt;- factor(c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3), labels=c(&quot;VA&quot;, &quot;VB&quot;, &quot;VC&quot;)) venenos &lt;- data.frame(tiempo, antidoto, veneno) # Diagrama de cajas ggplot(venenos,aes(x = antidoto, y = tiempo, color = veneno)) + geom_boxplot() # Gráfico de interacción de medias ggplot(venenos, aes(x = antidoto, y = tiempo, group = veneno, color = veneno)) + stat_summary(fun = mean, geom = &quot;point&quot;) + stat_summary(fun = mean, geom = &quot;line&quot;) En el gráfico de interacción se puede apreciar que antídoto es más efectivo para cada tipo de veneno. demás se puede ver que las curvas del tiempo de reacción (líneas de colores) no tiene el mismo comportamiento lo que indica habitualmente que hay cierto efecto de interacción entre los factores considerados, es decir, existe dos combinaciones antídoto - veneno que presentan resultados significativos (medias distintas). 8.2 Modelos ANOVA 1 vía El modelo ANOVA de una vía se plantea cuando tenemos una única variable predictora de tipo categórico y una respuesta de tipo numérico. Dicho modelo se puede describir de forma general, para una muestra de tamaño \\(n\\), como: Una variable respuesta, \\(Y\\), de tipo numérico con observaciones \\(y_1, \\ldots ,y_n\\). Una variable predictora, \\(F\\), de tipo categórico con \\(I\\) grupos o niveles distintos de tamaños muestrales \\(n_1, n_2, \\ldots , n_I\\), de forma que \\(n = n_1 + n_2 + \\ldots + n_I\\), y el vector de observaciones de la respuesta se puede escribir como: \\[ y_{11},\\ldots,y_{1n_1},y_{21},\\ldots,y_{2n_2},\\ldots,y_{I1},\\ldots,y_{In_I} \\] donde el primer subíndice indica el nivel del factor y el segundo la posición dentro del conjunto de datos de dicho nivel del factor. Conjunto \\(\\mu_i\\) de medias de todas las observaciones de la respuesta asociadas con el nivel \\(i\\) del factor, es decir: \\[ \\mu_i = \\frac{\\sum_{j = 1}^{n_j} y_{ij}}{n_i}; \\text{ i = 1, 2,..., I} \\] Media global de la respuesta, \\(\\mu\\), que se puede obtener como: \\[ \\mu = \\frac{\\sum_{j = 1}^{I} \\mu_{j}}{I} \\] Incrementos, \\(\\alpha_i\\), de cada una de las medias de cada grupo con respecto a la media global, es decir: \\[ \\alpha_i= \\mu - \\mu_i; \\text{ i = 1, 2,..., I} \\] El objetivo básico en este tipo de modelos es la comparación de las medias \\(\\mu_i\\) para detectar posibles diferencias entre os niveles del factor, es decir, plateamos el contraste de comparación de medias: \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\mu_1 = \\mu_2 = \\ldots = \\mu_I\\\\ H_a: &amp; \\mbox{Existen dos grupos al menos con medias distintas} \\end{array} \\right. \\] Este contraste es equivalente al que se puede escribir en términos de los incrementos de las medias: \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\alpha_1 = \\alpha_2 = \\ldots = \\alpha_I = 0\\\\ H_a: &amp; \\mbox{Al menos hay un incremento distinto de cero} \\end{array} \\right. \\] que tiene una estructura similar al test \\(F\\) de la regresión, donde queremos contrastar si existe algún coeficiente distinto de cero. Esto implica que el modelo ANOVA se puede escribir en términos de un modelo lineal sin más que considerar un conjunto de variables ficticias \\(X_1,...,X_{I}\\) que toman los valores siguientes: \\[ X_i= \\left\\{ \\begin{array}{ll} 1 &amp; \\mbox{si la respuesta pertenece al grupo i}\\\\ 0 &amp; \\mbox{en otro caso} \\end{array} \\right. \\] y un efecto común para todos los niveles del factor que viene dado por \\(\\mu\\) que denotamos por \\(\\alpha_0\\). La única diferencia entre ambas estructuras de comparación es que la referida a las medias \\(\\mu_i\\) tiene \\(I\\) parámetros, mientras que la de los incrementos tiene \\(I+1\\) parámetros. Para hacer equivalentes ambas estructuras añadimos la conocida como restricción de identificabilidad que establece de partida que uno de los incrementos debe ser igual a cero, es decir, que una media de un grupo coincide con la media global. Este es el nivel de referencia que utilizamos como base de comparación con el resto de niveles o grupos del factor. En esta situación si consideramos \\(Y_i = \\{y_{i1},...,y_{in_i}\\}\\), \\(1_{n_i} = \\{1,...,1\\}\\) un vector de \\(n_i\\) unos, \\(0_{n_i} = \\{0,...,0\\}\\) un vector de \\(n_i\\) ceros, para cada uno de los niveles \\(i\\) del factor, \\(\\mu = \\alpha_0\\), y la restricción de identificabilidad \\(\\alpha_I = 0\\) (podríamos elegir cualquier otro \\(\\alpha_j =0\\) y obtendríamos el mismo modelo), podemos escribir el modelo ANOVA como: \\[ Y = \\left( \\begin{array}{c} Y_1 \\\\ Y_2 \\\\ \\ldots \\\\ Y_I \\\\ \\end{array} \\right) = \\left( \\begin{array}{ccccc} 1_{n_1} &amp; 1_{n_1} &amp; 0_{n_1} &amp; \\ldots &amp; 0_{n_1} \\\\ 1_{n_2} &amp; 0_{n_2} &amp; 1_{n_2} &amp; \\ldots &amp; 0_{n_2} \\\\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\\\ 1_{n_I} &amp; 0_{n_I} &amp; 0_{n_I} &amp;\\ldots &amp; 1_{n_I} \\\\ \\end{array} \\right) \\left( \\begin{array}{c} \\alpha_0 \\\\ \\alpha_1 \\\\ \\alpha_2 \\\\ \\ldots \\\\ \\alpha_{I_1} \\\\ \\end{array} \\right) + \\left( \\begin{array}{c} e_1 \\\\ e_2 \\\\ \\ldots \\\\ e_n \\\\ \\end{array} \\right) = X\\beta + \\epsilon \\] o equivalentemente en términos de las medias como: \\[\\begin{equation} \\mu_i = \\alpha_0 + \\alpha_i + \\epsilon_i, \\text{ para } i = 1, 2,...,k, \\text{ con } \\alpha_k = 0 \\tag{8.1} \\end{equation}\\] Las hipótesis de este modelo es que los errores se distribuyen de forma independiente mediante una distribución Normal de media cero y varianza constante \\(\\sigma^2\\) para cada uno de los grupos que determina la variable predictora. En esta situación el contraste sobre los incrementos es equivalente al test \\(F\\) de regresión de los modelos RLM. 8.2.1 Especificacion del modelo en R A continuación se presenta la especificación en R de los modelos anteriores y de todos los anidados que pueden surgir a partir de ellos, así como su interpretación en términos de contraste de hipótesis o coeficientes asociados a cada efecto presente en el modelo. La especificación en R del modelo dado en la ecuación @ref{eq:aovonefac} para su estimación se realiza a través de la expresión reducida del modelo dada por: \\[ Y \\sim F \\] En este tipo de modelos se plantean varias situaciones de modelos anidados que deberemos estudiar: Modelo con efecto de \\(F\\): \\[\\begin{equation} Y \\sim F, \\tag{8.2} \\end{equation}\\] Si \\(F\\) resulta significativo, tenemos que se detectan diferencias entre al menos dos medias para los niveles del factor \\(F\\). Modelo sin efectos: \\[\\begin{equation} Y \\sim 1 \\tag{8.3} \\end{equation}\\] En este caso \\(F\\) no resulta significativo y podmeos conluir que las medias de todos los niveles del factor se pueden considerar iguales. En la práctica el ajuste de este tipo de modelos se puede plantear como una comparación entre los modelos (8.2) y (8.3), dado que están anidados, de forma similar al proceso de comparación de modelos planteado en los modelos RLM y MP. 8.3 Modelos ANOVA dos vías El modelo ANOVA de dos vías se presenta cuando consideramos dos variables predictoras de tipo categórico. Si tenemos dos factores \\(F_1\\) y \\(F_2\\) con \\(I\\) y \\(J\\) niveles respectivamente (y utilizando lo visto en el punto anterior), el modelo expresado en términos de las medias de las combinaciones de los diferentes niveles de los factores considerados viene dado por: \\[\\begin{equation} \\mu_{ij} = \\alpha_0 + \\alpha_i + \\beta_j + \\alpha\\beta_{ij} + \\epsilon_{ij}, \\ \\mbox{para} \\ i = 1,\\ldots,I; \\ j = 1,\\ldots,J \\ \\mbox{con} \\ \\alpha_1 = \\beta_1 = \\alpha\\beta_{11} = 0 \\tag{8.4} \\end{equation}\\] donde: \\(\\mu_{ij}\\) es la media de la respuesta para el nivel \\(i\\) de \\(F_1\\) y el nivel \\(j\\) de \\(F_2\\). \\(\\alpha_0\\) es el efecto común a todas las combinaciones de niveles para ambos factores. \\(\\alpha_i\\) son los incrementos asociados a cada uno de los niveles del factor \\(F_1\\). \\(\\beta_j\\) son los incrementos asociados a cada uno de los niveles del factor \\(F_2\\). \\(\\alpha\\beta_{ij}\\) son los incrementos asociados a la combinación de los niveles \\(i\\) de \\(F_1\\) y \\(j\\) de \\(F_2\\). Es lo que se denomina efecto de interacción que valora los cambios en las combinaciones de las medias para ambos factores. Si este efecto no es significativo, la media para una combinación de niveles de los factores se construye sumando los incrementos de cada nivel de forma independiente. Dado que tenemos dos factores se hace necesario añadir más restricciones de identificabildiad. Añadimos una por cada factor y la que aparece de forma inmediata en la interacción de los dos efectos que estamos tomando como cero. En este caso no escribimos la matriz de diseño del modelo pero se puede escribir considerado la matriz de coeficientes de dimensiones \\(IJ \\times IJ\\) que surge para el modelo (8.4). Bastará con sustituir los unos y ceros por vectores de unos y ceros de dimensiones adecuadas en función de los tamaños de cada uno de los niveles de los dos factores considerados. Dicha matriz de coeficientes se puede extraer a partir de las ecuaciones completas del modelo (8.4) (teniendo en cuenta las restricciones de identificabilidad) dadas por: \\[\\begin{array}{lll} \\mu_{11} &amp; = \\alpha_0 + \\alpha_{1} + \\beta_{1} + \\alpha\\beta_{11} + \\epsilon_{11}&amp; = \\alpha_0 + \\epsilon_{11}\\\\ \\mu_{12} &amp; = \\alpha_0 + \\alpha_{1} + \\beta_{2} + \\alpha\\beta_{12} + \\epsilon_{12}&amp; = \\alpha_0 + \\beta_{2} + \\alpha\\beta_{12} + \\epsilon_{12}\\\\ \\ldots &amp; \\ldots &amp;\\ldots\\\\ \\mu_{1J} &amp; = \\alpha_0 + \\alpha_{1} + \\beta_{J} + \\alpha\\beta_{1J} + \\epsilon_{1J}&amp; = \\alpha_0 + \\beta_{J} + \\alpha\\beta_{1J} + \\epsilon_{1J}\\\\ \\mu_{21} &amp; = \\alpha_0 + \\alpha_{2} + \\beta_{1} + \\alpha\\beta_{21} + \\epsilon_{21}&amp; = \\alpha_0 + \\alpha_{2} + \\alpha\\beta_{21} +\\epsilon_{11}\\\\ \\mu_{22} &amp; = \\alpha_0 + \\alpha_{2} + \\beta_{2} + \\alpha\\beta_{22} + \\epsilon_{22}&amp; = \\alpha_0 + \\alpha_{2} + \\beta_{2} + \\alpha\\beta_{22} + \\epsilon_{22}\\\\ \\ldots &amp; \\ldots &amp;\\ldots\\\\ \\mu_{2J} &amp; = \\alpha_0 + \\alpha_{2} + \\beta_{J} + \\alpha\\beta_{2J} + \\epsilon_{2J}&amp; = \\alpha_0 + \\alpha_{2} + \\beta_{J} + \\alpha\\beta_{2J} + \\epsilon_{2J}\\\\ \\ldots &amp; \\ldots &amp;\\ldots\\\\ \\ldots &amp; \\ldots &amp;\\ldots\\\\ \\ldots &amp; \\ldots &amp;\\ldots\\\\ \\mu_{I1} &amp; = \\alpha_0 + \\alpha_{I} + \\beta_{1} + \\alpha\\beta_{I1} + \\epsilon_{I1}&amp; = \\alpha_0 + \\alpha_{I} + \\alpha\\beta_{I1} + \\epsilon_{I1}\\\\ \\mu_{I2} &amp; = \\alpha_0 + \\alpha_{I} + \\beta_{2} + \\alpha\\beta_{I2} + \\epsilon_{I2}&amp; = \\alpha_0 + \\alpha_{I} + \\beta_{2} + \\alpha\\beta_{I2} + \\epsilon_{I2}\\\\ \\ldots &amp; \\ldots &amp;\\ldots\\\\ \\mu_{IJ} &amp; = \\alpha_0 + \\alpha_{I} + \\beta_{J} + \\alpha\\beta_{IJ} + \\epsilon_{IJ}&amp; = \\alpha_0 + \\alpha_{I} + \\beta_{J} + \\alpha\\beta_{IJ} + \\epsilon_{IJ}\\\\ \\end{array}\\] En este caso el objetivo vuelve a ser la comparación de medias pero el contraste a resolver depende de la especificación del modelo considerado. Hay que tener en cuenta que en este caso no tenemos una única variable predictora, y además hay que valorar la posibilidad de la interacción entre ambos factores. 8.3.1 Especificacion del modelo en R La especificación en R del modelo dado en la ecuación @ref{eq:aovtwofac} para su estimación se realiza a través de la expresión reducida del modelo dada por: \\[\\begin{equation} Y \\sim F_1 + F_2 + F_1 : F_2, \\tag{8.5} \\end{equation}\\] donde \\(F_1 : F_2\\) representa el efecto de interacción, y \\(F_1\\) y \\(F_2\\) son los denominados efectos principales asociados con los factores considerados. En este tipo de modelos se plantean varias situaciones de modelos anidados que deberemos estudiar para establecer cual es el tipo de contraste sobre las medias que estamos resolviendo. Alternativamente ese modelo se puede escribir de forma más reducida como \\(Y \\sim F_1*F_2\\), que es un modelo con los efectos principales de cada factor y con la interacción. Modelo saturado o modelo con todos los factores y la interacción dado por: \\[\\begin{equation} Y \\sim F_1 + F_2 + F_1 : F_2 \\tag{8.6} \\end{equation}\\] Si la interacción está presente en el modelo el contraste planteado es: \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\mbox{No hay diferencias entre las medias conjuntas de ambos niveles del factor}\\\\ H_a: &amp; \\mbox{Al menos hay dos combinaciones de ambos factores con medias distintas} \\end{array} \\right. \\] que nos permite concluir sobre si el efecto de interacción es necesario para explicar el comportamiento de la respuesta. En caso de que dicho contraste resulte no significativo podemos plantear el modelo con ambos efectos principales. Modelo con ambos efectos principales: \\[ Y \\sim F_1 + F_2 \\] donde se parte de que la interacción es no significativa y se plantean dos contrastes (uno por cada factor) \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\mbox{No hay diferencias entre las medias de } F_1\\\\ H_a: &amp; \\mbox{Al menos hay dos medias de } F_1 \\mbox{ distintas} \\end{array} \\right. \\] Si no rechazamos este contraste deberemos considerar que no hay diferencias en las medias de los niveles establecidos en \\(F_1\\) y debemos considerar un modelo con efecto principal de \\(F_2\\). \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\mbox{No hay diferencias entre las medias de } F_2\\\\ H_a: &amp; \\mbox{Al menos hay dos medias de } F_2 \\mbox{ distintas} \\end{array} \\right. \\] Si no rechazamos este contraste deberemos considerar que no hay diferencias en las medias de los niveles establecidos en \\(F_2\\) y debemos considerar un modelo con efecto principal de \\(F_1\\). Estos contrastes nos permiten concluir sobre cada factor de forma independiente (no hay interacción entre ellos). Modelo con efecto principal de \\(F_1\\): \\[ Y \\sim F_1 \\] donde se parte de que la interacción y el efecto principal de \\(F_2\\) son no significativos y se plantea el contraste \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\mbox{No hay diferencias entre las medias de } F_1\\\\ H_a: &amp; \\mbox{Al menos hay dos medias de } F_1 \\mbox{ distintas} \\end{array} \\right. \\] Si no rechazamos este contraste deberemos considerar que no hay diferencias en las medias de los niveles establecidos en \\(F_1\\) y nuestro modelo final no contiene ningún tipo de efecto predictivo. Modelo con efecto principal de \\(F_2\\): \\[ Y \\sim F_2 \\] donde se parte de que la interacción y el efecto principal de \\(F_1\\) son no significativos y se plantea el contraste \\[ \\left\\{ \\begin{array}{ll} H_0: &amp; \\mbox{No hay diferencias entre las medias de } F_2\\\\ H_a: &amp; \\mbox{Al menos hay dos medias de } F_2 \\mbox{ distintas} \\end{array} \\right. \\] Si no rechazamos este contraste deberemos considerar que no hay diferencias en las medias de los niveles establecidos en \\(F_2\\) y nuestro modelo final no contiene ningún tipo de efecto predictivo. Modelo sin efectos: \\[ Y \\sim 1 \\] donde concluimos que todas las medias consideradas son iguales, es decir, los niveles de los factores considerados no tienen efecto sobre la respuesta. Esta combinación de modelos nos da una estructura secuencial de modelización (modelos alternativos) que deberemos estudiar para elegir el modelo con una mayor capacidad predictiva. Dicha estructura viene dada por: \\[\\begin{array}{lll} M1: &amp; Y \\sim F_1 + F_2 + F_1:F_2\\\\ M2: &amp; Y \\sim F_1 + F_2 \\\\ M3.1: &amp; Y \\sim F_1 \\\\ M3.2: &amp; Y \\sim F_2 \\\\ M4: &amp; Y \\sim 1\\\\ \\end{array}\\] Más adelante veremos como llevar a cabo esta comparación secuencial y como interpretarla para determinar los efectos que finalmente están presentes en el modelo y los que no. 8.4 Estimación y bondad de ajuste del modelo Dado que los modelos ANOVA se pueden escribir como modelos lineales de regresión con una matriz de diseño que solo contiene unos y ceros, se pueden utilizar los procedimientos de estimación vistos en el capitulo anterior para estimar los par??metros del modelo. Podemos utilizar las ecuaciones normales para obtener los coeficientes del modelo que en este caso representarán los incrementos de cada nivel con respecto al de referencia (que hemos tomado como cero en la restricción de identificabilidad), que nos permiten obtener las estimaciones de las medias asociadas a cada nivel o niveles del factor o factores. Además, podemos obtener los intervalos de confianza de dichos coeficientes. Sin embargo, en este caso no se pueden interpretar de forma directa las significatividades de cada coeficiente en el modelo, ya que al contrario de los que ocurría en los modelos de regresión, donde cada coeficiente representaba el efecto de una predictora, en los modelos ANOVA el efecto de la predictora va asociado con todos los coeficientes estimados con el factor o interacción de factores. Por eso es necesario proporcionar una medida de bondad de ajuste con dichas estimaciones que en este caso es el test F ANOVA que se obtiene como el test F de la regresión de los modelos de unidades anteriores. Este test nos permite extraer conclusiones directas sobre los efectos presentes en el modelo y no sobre los coeficientes estimados. En el punto siguiente veremos como utilizar el test F ANOVA para obtener el mejor modelo. En este caso no utilizaremos el \\(R^2\\) como medida de bondad de ajusta ya que se encuentra diseñada para modelos de regresión donde las predictoras son de tipo numérico. Para resolver la estimación y la bondad de ajuste en este tipo de modelos utilizaremos las funciones utilizadas en la unidad anterior. En algunos casos modificaremos la sintaxis para adaptarnos a las variables predictoras de tipo factor. 8.4.1 Ejemplos Pasamos a estudiar cada uno de los ejemplos ajustando el modelo saturado, es decir, aquel que contiene todos los efectos posibles en el modelo. Por defecto el programa R utiliza como restricción de identificabilidad que el incremento asociado con la primera categoría (por orden numérico o texto de los niveles del factor) es igual a cero, es decir, que la estimación de dicho incremento corresponde con la interceptación o efecto común del modelo. En las tablas de estimaciones eliminamos el p-valor individual asociado a cada incremento, dado que en este caso esos efectos no deben interpretarse de forma individual. 8.4.1.1 Datos de Insecticidas Obtenemos el ajuste del modelo de ANOVA de un factor para el banco de datos de Insecticidas. La expresión del modelo viene dado por: \\[\\mu_{spray,i}=\\alpha_0+\\alpha_{spray,i}+\\epsilon_{spray,i}, \\text{para }i=A,B,C,D,E ,F\\] donde la restricción de identificabilidad es fijar el incremento del spray A igual a cero, es decir, \\(\\alpha_{spray,A} = 0\\). # Ajuste del modelo fit.insecticidas &lt;- lm(count ~ spray, data = insecticidas) # Inferencia sobre los parámetros del modelo tab_model(fit.insecticidas, show.r2 = FALSE, show.p = FALSE)   count Predictors Estimates CI (Intercept) 14.50 12.24 – 16.76 spray [B] 0.83 -2.36 – 4.03 spray [C] -12.42 -15.61 – -9.22 spray [D] -9.58 -12.78 – -6.39 spray [E] -11.00 -14.20 – -7.80 spray [F] 2.17 -1.03 – 5.36 Observations 72 Las ecuaciones de estimación de las medias del número de insectos vivos se pueden extraer a partir de la tabla de coeficientes estimados. Sin embargo, podemos obtener las estimaciones y representar las medias de todos los sprays haciendo uso de la función update() quitando el término de interceptación del modelo. De esta forma se prescinde de la restricción de identificabilidad y se obtienen las medias directamente. # Modelo sin interceptación m1 &lt;- update(fit.insecticidas, . ~ spray - 1) # Inferencia sin identificabilidad tab_model(m1, show.r2 = FALSE, show.p = FALSE)   count Predictors Estimates CI spray [A] 14.50 12.24 – 16.76 spray [B] 15.33 13.07 – 17.59 spray [C] 2.08 -0.18 – 4.34 spray [D] 4.92 2.66 – 7.18 spray [E] 3.50 1.24 – 5.76 spray [F] 16.67 14.41 – 18.93 Observations 72 En esta tabla podemos ver tanto el valor estimado con el intervalo de confianza al 95% del número de insectos vivos con cada uno de los sprays. De esta forma os sprays A, B, y F son los menos efectivos (medias de insectos vivos más altas), mientras que los otros tres tienen medias significativamente más bajas. El spray C es el que se muestra más efectivo con una media de insectos vivos de 2 (redondeando a entero). Podemos ver gráficamente la solución obtenida mediante: # Gráfico de medias estimadas plot_model(m1, show.values = TRUE, vline.color = &quot;yellow&quot;) En cuanto a las medidas de bondad de ajuste utilizaremos le test F de igual de medias para establecer si los diferentes sprays considerados tienen un comportamiento similar o al menos hay dos de ellos que se comportan de forma distinta. glance(fit.insecticidas) Tabla 8.1: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.7240.7043.9234.73.18e-175-1974094251.02e+036672 Podemos ver que el test F resulta significativo indicando que al menos hay dos medias distintas (algún incremento distinto de cero), lo que implica que al menos hay dos tipos de spray que se comportan de forma diferente con respecto al número de insectos vivos que quedan finalmente. Dado que el factor considerado es significativo resulta necesario conocer que medias son realmente distintas y cuales podemos considerar iguales. Para realizar esta tarea utilizaremos los denominados tests de comparaciones múltiples que nos permiten comparar dos a dos todas las combinaciones del factor para determinar las que son significativamente distintas o no. En R podemos utilizar la función TukeyHSD que realiza el test de comparaciones múltiples de Tukey. La salida proporciona la diferencia estimada entre cada para de niveles del factor considerado, así como el p-valor asociado con dicha comparación. # Test de comparaciones múltiples TukeyHSD(fit.insecticidas) ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## ## Fit: aov(formula = x) ## ## $spray ## diff lwr upr p adj ## B-A 0.8333333 -3.866075 5.532742 0.9951810 ## C-A -12.4166667 -17.116075 -7.717258 0.0000000 ## D-A -9.5833333 -14.282742 -4.883925 0.0000014 ## E-A -11.0000000 -15.699409 -6.300591 0.0000000 ## F-A 2.1666667 -2.532742 6.866075 0.7542147 ## C-B -13.2500000 -17.949409 -8.550591 0.0000000 ## D-B -10.4166667 -15.116075 -5.717258 0.0000002 ## E-B -11.8333333 -16.532742 -7.133925 0.0000000 ## F-B 1.3333333 -3.366075 6.032742 0.9603075 ## D-C 2.8333333 -1.866075 7.532742 0.4920707 ## E-C 1.4166667 -3.282742 6.116075 0.9488669 ## F-C 14.5833333 9.883925 19.282742 0.0000000 ## E-D -1.4166667 -6.116075 3.282742 0.9488669 ## F-D 11.7500000 7.050591 16.449409 0.0000000 ## F-E 13.1666667 8.467258 17.866075 0.0000000 Para interpretar la tabla resultante nos debemos fijar en la columna p adj. Todos aquellos inferiores a 0.05 indican que las medias son distintas. Analizando todos los p-valores podemos establecer dos grupos de sprays, el formado por los tipos A, B y F y el formado por los tipos C, D, y E. Dentro de cada grupo no hay diferencias pero sin entres los sprays de grupos distintos. También podemos representar gráficamente las comparaciones realizadas para que resulte más fácil su interpretación: plot(TukeyHSD(fit.insecticidas), las=1, tcl = -.3) Los intervalos de confianza que contienen al cero muestran aquellos pares de sprays que pueden considerarse iguales. Los intervalos de confianza a la izquierda de cero muestran las combinaciones de sprays donde el primer spray tiene un efecto menor que el segundo (media negativa), mientras que en la parte derecha tenemos las combinaciones donde el primer spray es superior al segundo. Por ejemplo, podemos concluir: los sprays A y B tienen comportamiento similar; los sprays A y C tienen comportamientos distintos con la media del número de supervivientes en A superior que en con el spray C; los sprays F y E tienen comportamientos distintos con la media del número de supervivientes en F superior que en con el spray E. ¿Qué otras conclusiones podemos extraer? 8.4.1.2 Datos de Envasado Ajustamos un modelo ANOVA de una vía para el conjunto de datos de envasado. En este caso la restricción de identificabilidad es fijar el incremento de Máquina M1 igual a cero, es decir, \\(\\alpha_{maquina,M1} = 0\\). \\[\\mu_{maquina,i}=\\alpha_0+\\alpha_{maquina,i}+\\epsilon_{maquina,i}, \\text{para }i=M1, M2, M3, M4\\] donde la restricción de identificabilidad es fijar el incremento de Máquina M1 igual a cero, es decir, \\(\\alpha_{maquina,M1} = 0\\). # Ajuste del modelo fit.envasado &lt;- lm( produccion ~ maquina, data = envasado) # Inferencia sobre los parámetros del modelo tab_model(fit.envasado, show.r2 = FALSE, show.p = FALSE)   produccion Predictors Estimates CI (Intercept) 106.00 98.00 – 114.00 maquina [M2] 7.75 -3.57 – 19.07 maquina [M3] -1.50 -12.82 – 9.82 maquina [M4] 18.00 6.68 – 29.32 Observations 16 A la vista de los coeficientes la máquina el orden de las máquinas (de mejor a peor, es decir, de mayor número de envases sin defecto a menor) es \\(M4 &gt; M2 &gt; M1 &gt; M3\\), con media estimadas dadas por: # Modelo sin interceptación m1 &lt;- update(fit.envasado, . ~ maquina - 1) # Inferencia sin identificabilidad tab_model(m1, show.r2 = FALSE, show.p = FALSE)   produccion Predictors Estimates CI maquina [M1] 106.00 98.00 – 114.00 maquina [M2] 113.75 105.75 – 121.75 maquina [M3] 104.50 96.50 – 112.50 maquina [M4] 124.00 116.00 – 132.00 Observations 16 Vemos la solución gráfica donde se aprecian comportamientos muy diferenciados entre las diferentes máquinas. plot_model(m1, show.values = TRUE, vline.color = &quot;yellow&quot;) Con respecto a la bondad del ajuste podemos ver que el test \\(F\\) resulta significativo indicando que al menos alguna de las medias es distinta del resto (algún incremento distinto de cero). Por tanto, existe un efecto del tipo de máquina en el número de envases sin defecto. glance(fit.envasado) Tabla 8.2: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.5960.4967.355.910.01023-52.31151186481216 Realizamos las comparaciones múltiples para comparar todas las máquinas dos a dos. TukeyHSD(fit.envasado) ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## ## Fit: aov(formula = x) ## ## $maquina ## diff lwr upr p adj ## M2-M1 7.75 -7.673887 23.173887 0.4716327 ## M3-M1 -1.50 -16.923887 13.923887 0.9911761 ## M4-M1 18.00 2.576113 33.423887 0.0210561 ## M3-M2 -9.25 -24.673887 6.173887 0.3283778 ## M4-M2 10.25 -5.173887 25.673887 0.2508228 ## M4-M3 19.50 4.076113 34.923887 0.0126965 Tan sólo las combinaciones M4-M1 y M4-M3 muestran resultados significativos indicando que la máquina M4 es comparable con la M2, es decir, la media de envases sin defecto es igual para dichas máquinas, pero distintas de la M1 y M3 que también puede considerarse iguales. Veamos los resultados gráficamente: plot(TukeyHSD(fit.envasado), las=1, tcl = -.3) 8.4.1.3 Datos de Venenos Ajustamos un modelo ANOVA de dos vías con interacción entre veneno y antídoto para el conjunto de datos de venenos cuya expresión viene dada por (el índice i hace referencia al antídoto, y el j a los venenos): \\[\\mu_{Antidoto:i,Veneno:j} = \\alpha_0 + \\alpha_{Antidoto:i} +\\alpha_{Veneno:j} + \\alpha\\beta_{Antidoto:i,Veneno:j} + \\epsilon_{Antidoto:i,Veneno:j}\\] para \\(i=AA,AB,AC,AD\\), \\(j=VA,VB,VC\\) con las restricciones de identificabilidad: \\(\\alpha_{antidoto,AA} = 0\\), \\(\\beta_{veneno,VA} = 0\\), \\(\\alpha\\beta_{Antidoto,AA; Veneno,VA} = 0\\), de forma que el ajuste para este modelo viene dado por: # Ajuste del modelo fit.venenos &lt;- lm( tiempo ~ antidoto*veneno, data = venenos) # Inferencia sobre los parámetros del modelo tab_model(fit.venenos, show.r2 = FALSE, show.p = FALSE)   tiempo Predictors Estimates CI (Intercept) 0.41 0.26 – 0.56 antidoto [AB] 0.47 0.25 – 0.68 antidoto [AC] 0.15 -0.06 – 0.37 antidoto [AD] 0.20 -0.02 – 0.41 veneno [VB] -0.09 -0.31 – 0.12 veneno [VC] -0.20 -0.42 – 0.01 antidoto [AB] * veneno[VB] 0.03 -0.27 – 0.33 antidoto [AC] * veneno[VB] -0.10 -0.40 – 0.20 antidoto [AD] * veneno[VB] 0.15 -0.15 – 0.45 antidoto [AB] * veneno[VC] -0.34 -0.64 – -0.04 antidoto [AC] * veneno[VC] -0.13 -0.43 – 0.17 antidoto [AD] * veneno[VC] -0.08 -0.39 – 0.22 Observations 48 Desde luego interpretar la tabla de coeficientes en este caso es más complicado, dada la gran cantidad de parámetros involucrados, por lo que resulta más fácil obtener las medias y el gráfico asociado. En este caso no podemos actualizar el modelo eliminando la interceptación dado que tenemos tres restricciones y no una. Modificamos la tabla de estimaciones y el gráfico para obtener todo el conjunto de medias. Además, como no hemos descartado el efecto de interacción, en el gráfico sólo representaremos las medias asociadas con dicho efecto. Para representar el efecto de interacción añadimos el parámetro \"int\" a la función plot_model. # Objeto gráfico p &lt;- plot_model(fit.venenos, &quot;int&quot;, show.stat = TRUE, title =&quot;&quot;) # Tabla de estimaciones p$data Tabla 8.3: xpredictedstd.errorconf.lowconf.highgroupgroup_col 10.4130.07450.266&nbsp;0.559VAVA 10.32&nbsp;0.07450.174&nbsp;0.466VBVB 10.21&nbsp;0.07450.06390.356VCVC 20.88&nbsp;0.07450.734&nbsp;1.03&nbsp;VAVA 20.8150.07450.669&nbsp;0.961VBVB 20.3350.07450.189&nbsp;0.481VCVC 30.5680.07450.421&nbsp;0.714VAVA 30.3750.07450.229&nbsp;0.521VBVB 30.2350.07450.08890.381VCVC 40.61&nbsp;0.07450.464&nbsp;0.756VAVA 40.6670.07450.521&nbsp;0.814VBVB 40.3230.07450.176&nbsp;0.469VCVC # Gráfico de interacción estimado p A la vista de la tabla de estimaciones podemos concluir que: El antídoto AA es el menos tiempo tarda en hacer efecto sobre el veneno VA. El antídoto AA es el menos tiempo tarda en hacer efecto sobre el veneno VB. El antídoto AA es el menos tiempo tarda en hacer efecto sobre el veneno VC. De esta forma parece que el antídoto AA es el mejor funciona con cualquiera de los venenos pero será necesario estudiar la bondad de ajuste y realizar el proceso de selección para determinar que efectos deben aparecer el modelo, para poder concluir más precisamente sobre el comportamiento de los diferentes antídotos. En el gráfico de estimación del efecto de interacción podemos apreciar de forma más sencillo la relación entre ambos factores. Aunque el antídoto AA muestra los tiempos más bajos, también es cierto que los intervalos de confianza no son muy diferentes de los obtenidos para AC y AD. Con respecto a la bondad del ajuste podemos ver que el test \\(F\\) resulta significativo indicando que al menos alguna de las medias es distinta del resto (algún incremento distinto de cero). Por tanto, existe un efecto de interacción entre venenos y antídoto que proporciona un tiempo de reacción distinto. glance(fit.venenos) Tabla 8.4: r.squaredadj.r.squaredsigmastatisticp.valuedflogLikAICBICdeviancedf.residualnobs 0.7340.6530.1499.031.93e-071130.2-34.3-9.980.83648 El p-valor asociado con la interacción resulta no significativo, indicando que dicho efecto puede ser considerado nulo y no se debería considerarse en el modelo. Vemos aquí la diferencia entre la interpretación del test F para el modelo ANOVA de una vía y el ANOVA de dos vías. En este último caso es necesario el estudio de la tabla ANOVA para determinar los efectos significativos y no basta solo con la bondad del ajuste. En el punto siguiente vemos como realizar la selección del mejor modelo en este tipo de situaciones. 8.5 Comparación y selección de modelos La comparación de modelos se basa en determinar la capacidad explicativa de cada uno de los efectos presentes en el modelo. Mientras que en los modelos de regresión esos efectos van asociados con un único coeficiente del modelo (pendiente asociada a la predictora), en los modelos ANOVA el efecto de un factor va asociado con todos los incrementos establecidos. En realidad, tendremos un efecto significativo cuando detectemos diferencias entre al menos dos medias de la respuesta para los diferentes niveles del factor. Dado que el número de modelos que podemos construir en estas situaciones es limitado, podríamos construirlos todos ellos y compararlos de golpe para decidir el mejor modelo. Esto se puede hacer con el test F de comparación de modelos que es una versión del test F para un contraste especifico, o bien utilizar el criterio del AIC o BIC y quedarnos con aquel modelo que de un valor más pequeño. En modelos más complejos optaremos por un procedimiento automático por pasos empezando por el modelo saturado. En los modelos ANOVA de una vía la selección del modelo se basa únicamente en el análisis de bondad de ajuste, ya que el test F que obtenemos es realmente la comparación entre los modelos que contienen el factor y el que no lo contiene, mientras que los modelos de más de una vía es necesario realizar el proceso de selección de efectos para determinar el modelo final. A continuación presentamos las diferentes opciones con el banco de datos de venenos ya que en los otros dos casos ya hemos resulto la selección mediante el análisis de la bondad del ajuste. 8.5.1 Ejemplos Realizamos la selección le mejor modelo par el banco de datos de venenos. En primer lugar procederemos de forma manual considerando todos los posibles modelos con las combinaciones de los factores considerados: \\(tiempo ∼veneno∗antidoto\\): Modelo con interacción, donde hay al menos una combinación de veneno y antídoto con tiempo de reacción medio distinto de otras combinaciones. \\(tiempo∼veneno+antidoto\\): Modelo sin interacción con efectos principales, donde el efecto del veneno y el antídoto tiene un efecto aditivo en e tiempo medio de reacción. \\(tiempo∼veneno\\): Modelo con efecto principal marginal del veneno, donde hay almenos un tipo de veneno con un tiempo medio de reacción distinto pero los antidotos no tienen efecto. \\(tiempo∼antidoto\\): Modelo con efecto principal marginal del antídoto, donde hay al menos un tipo de antídoto con un tiempo medio de reacción distinto pero los venenos no tienen efecto. \\(tiempo∼1\\): Modelo sin efectos, donde el tiempo de reacción no cambia con el antídoto y el tipo de veneno. En este caso la especificación de todos los posibles modelos así como su comparación resulta más costosa ya que están involucrados dos factores de clasificación. Los posibles modelos son: \\(tiempo \\sim veneno * antidoto\\): Modelo con interacción, donde hay al menos una combinación de veneno y antídoto con tiempo de reacción medio distinto de otras combinaciones. \\(tiempo \\sim veneno + antidoto\\): Modelo sin interacción con efectos principales, donde el efecto del veneno y el antídoto tiene un efecto aditivo en e tiempo medio de reacción. \\(tiempo \\sim veneno\\): Modelo con efecto principal marginal del veneno, donde hay almenos un tipo de veneno con un tiempo medio de reacción distinto pero los antidotos no tienen efecto. \\(tiempo \\sim antidoto\\): Modelo con efecto principal marginal del antídoto, donde hay al menos un tipo de antídoto con un tiempo medio de reacción distinto pero los venenos no tienen efecto. \\(tiempo \\sim 1\\): Modelo sin efectos, donde el tiempo de reacción no cambia con el antídoto y el tipo de veneno. Consideramos en primer lugar la comparación entre los modelos con y sin interacción para determinar si dicho efecto es relevante o no para explicar el comportamiento del tiempo medio de reacción. Obtenemos el contraste F parcial mediante: # Ajuste del modelo con interacción fit1 &lt;- lm(tiempo ~ antidoto + veneno + antidoto:veneno, data = venenos) # Ajuste del modelo sin interacción fit2 &lt;- lm(tiempo ~ antidoto + veneno, data = venenos) # Comparación entre modelos anova(fit2, fit1) Tabla 8.5: Res.DfRSSDfSum of SqFPr(&gt;F) 421.05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 360.8&nbsp;60.251.880.112 Dado que el p-valor no es significativo (p-valor &gt; 0.05) podemos concluir que ambos modelos pueden ser considerarse como iguales, es decir, el efecto de interacción no resulta significativo. Vamos a comparar las estimaciones de ambos modelos y representamos gráficamente el modelo sin interacción. En este caso obtendremos un gráfico por cada factor dado que no actúan de forma conjunta sino de forma aditiva. Utilizamos el parámetro “pred” para obtener las estimaciones de las medias asociadas a cada factor. # Estimaciones de ambos modelos tab_model(fit1, fit2, show.r2 = FALSE)   tiempo tiempo Predictors Estimates CI p Estimates CI p (Intercept) 0.41 0.26 – 0.56 &lt;0.001 0.45 0.34 – 0.57 &lt;0.001 antidoto [AB] 0.47 0.25 – 0.68 &lt;0.001 0.36 0.23 – 0.49 &lt;0.001 antidoto [AC] 0.15 -0.06 – 0.37 0.150 0.08 -0.05 – 0.21 0.232 antidoto [AD] 0.20 -0.02 – 0.41 0.069 0.22 0.09 – 0.35 0.002 veneno [VB] -0.09 -0.31 – 0.12 0.386 -0.07 -0.19 – 0.04 0.198 veneno [VC] -0.20 -0.42 – 0.01 0.063 -0.34 -0.45 – -0.23 &lt;0.001 antidoto [AB] * veneno[VB] 0.03 -0.27 – 0.33 0.855 antidoto [AC] * veneno[VB] -0.10 -0.40 – 0.20 0.507 antidoto [AD] * veneno[VB] 0.15 -0.15 – 0.45 0.321 antidoto [AB] * veneno[VC] -0.34 -0.64 – -0.04 0.028 antidoto [AC] * veneno[VC] -0.13 -0.43 – 0.17 0.389 antidoto [AD] * veneno[VC] -0.08 -0.39 – 0.22 0.572 Observations 48 48 # Gráfico del modelo sin interacción plot_model(fit2, &quot;pred&quot;) ## $antidoto ## ## $veneno Como era de esperar, dado que la interacción no es significativa, los coeficientes estimados (incrementos respecto de las medias de referencia dadas por el antídoto AA y el veneno VA) no varían sustancialmente entre ambos modelos. En el gráfico podemos ver que el veneno con un tiempo de reacción más pequeño es el asociado con el veneno VC, mientras que si nos fijamos en el antídoto, el menor tiempo de reacción se da para el AA. Dado que no hay interacción el modelo sugiere que independientemente del veneno utilizado, el antídoto más efectivo es el AA, seguido por el AC, AD, y por último el AB. Se pueden obtener las estimaciones asociadas con el modelo sin interacción para verificar este hecho. Este proceso manual resulta complicado de llevar a cabo cuando tenemos modelos más complejos (con más de dos vías de clasificación), por lo que es necesario utilizar procedimientos secuenciales automáticos para alcanzar el mejor modelo. A continuación se muestra como realizar esta selección: # Selección basada en test F ols_step_backward_p(fit.venenos, prem = 0.05) ## ## ## Elimination Summary ## ------------------------------------------------------------------------------- ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## ------------------------------------------------------------------------------- ## 1 antidoto:veneno 0.6508 0.6092 5.2608 -33.2407 0.1581 ## ------------------------------------------------------------------------------- Como era de esperar el proceso determina que podemos prescindir del efecto de interacción. Para utilizar el criterio AIC utilizamos la función step() porque la función ols_step_backward_aic esta diseñada específicamente para trabajar con preditores numéricos y no con interacciones de factores lo que puede llevar a soluciones erróneas. Por tanto, la única opción pasa por evaluar todos los modelos con la función ols_step_all_possible y elegir el mejor de ellos teniendo en cuenta la construcción del modelo. Sin embargo, esta forma de proceder no será práctica en modelos más complejos. # Selección con función step y AIC stats::step(fit.venenos, direction = &quot;backward&quot;) ## Start: AIC=-172.52 ## tiempo ~ antidoto * veneno ## ## Df Sum of Sq RSS AIC ## &lt;none&gt; 0.8001 -172.52 ## - antidoto:veneno 6 0.25027 1.0504 -171.46 ## ## Call: ## lm(formula = tiempo ~ antidoto * veneno, data = venenos) ## ## Coefficients: ## (Intercept) antidotoAB antidotoAC ## 0.4125 0.4675 0.1550 ## antidotoAD venenoVB venenoVC ## 0.1975 -0.0925 -0.2025 ## antidotoAB:venenoVB antidotoAC:venenoVB antidotoAD:venenoVB ## 0.0275 -0.1000 0.1500 ## antidotoAB:venenoVC antidotoAC:venenoVC antidotoAD:venenoVC ## -0.3425 -0.1300 -0.0850 El proceso indica que no podemos descartar el efecto de interacción contradiciendo los resultados obtenidos con el test F, aunque la diferencia entre los valores de AIC es muy pequeña. Habitualmente para este tipo de modelos se suele utilizar el criterio basado en el test F, dado que ambos pueden llevar a soluciones distintas como ocurre en este caso. 8.6 Diagnóstico Los procedimientos de diagnóstico son los mismos que en los modelos de regresión salvo por el hecho de que la igualdad de varianzas de los residuos se debe cumplir para cada uno de los grupos determinados por los niveles de los factores, es decir, varianzas residuales iguales. Para este tipo de modelos utilizaremos el test de Kolmogorov-Smirnov para el test de normalidad y el de Levene para la homogeneidad de varianzas También se pueden realizar los diagnósticos gráficos de residuos para cada hipótesis pero en estos modelos sólo tiene sentido realizar los diagramas de cajas de residuos versus niveles del factor para valorar linealidad y varianza constante, dado que en este tipo de modelos tenemos un único valor ajustado (media) para todos los sujetos de un mismo nivel del factor, y por tanto un mismo residuo para todos los sujetos de un mismo grupo. En cuanto al estudio de influencia, nos centraremos principalmente en la distancia de Cook dado que no tiene sentido considerar la influencia sobre los coeficientes del modelo ni sobre los valores ajustados dada la estructura agrupada del banco de datos a analizar, es decir, cada coeficiente no representa una variable sino que debemos considerar el conjunto de ellos que representan el efecto de un factor. Para realizar el diagnóstico partiremos del modelo ajustado en el apartado anterior para cada banco de datos. 8.6.1 Ejemplos Para realizar el diagnóstico partiremos del modelo ajustado en el apartado anterior para cada banco de datos. En caso de detectar algún problema con las hipótesis del modelo deberemos ajustar un nuevo modelo y verificar que cumple las hipótesis. 8.6.1.1 Datos de insecticidas Obtenemos los valores de diagnóstico y realizamos los correspondientes tests de hipótesis y análisis de influencia para el banco de datos de insecticidas. En primer lugar realizamos el gráfico cajas de residuos versus niveles del factor para valorar la hipótesis de linealidad y varianza constante. # Valores de diagnóstico diagnostico &lt;- fortify(fit.insecticidas) # Gráfico de residuos vs factor ggplot(diagnostico,aes(x = spray, y = .stdresid)) + geom_boxplot() + geom_hline(yintercept = 0, col = &quot;red&quot;) En el gráfico se observa como la variabilidad dentro de cada nivel del factor parece diferente, aunque los residuos parecen tener un comportamiento lineal alrededor del cero. # Tests de normalidad ols_test_normality(fit.insecticidas) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9601 0.0223 ## Kolmogorov-Smirnov 0.1301 0.1747 ## Cramer-von Mises 6.6076 0.0000 ## Anderson-Darling 1.2015 0.0037 ## ----------------------------------------------- El test de Kolmogorov-Smirnov resulta no significativo indicando el cumplimiento de la hipótesis de Normalidad de los residuos. # Tests de homogeneidad de varianzas leveneTest(.stdresid ~ spray, data = diagnostico) Tabla 8.6: DfF valuePr(&gt;F) 53.820.00422 66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; El test resulta significativo (p-valor inferior a 0.05) indicando que no se verifica la hipótesis de varianza constante, como ya sospechábamos del gráfico de los residuos. Podemos ver si el incumplimiento es debido a algún valor influyente, pero sino es así deberemos plantear alguna transformación de la respuesta para tratar de corregir los problemas de diagnóstico. Se puede verificar que el análisis de la distancia de Cook no presenta ninguna observación influyente, por lo que lo ideal sería plantear la transformación de Box-Cox para encontrar una solución a esta situación pero dado que tenemos valores de cero en la respuesta esto no resulta posible. Sin embargo puesto que la respuesta son datos de conteos podemos utilizar la función logaritmo añadiendo un uno a los valores de la respuesta para evitar problemas en la transformación. # Calculamos la nueva variable insecticidas &lt;- insecticidas %&gt;% mutate(lcount = log(count+1)) ¿qué ajuste tenemos con esa nueva variable? ¿Cómo es la bondad del ajuste?¿se verifican ahora las hipótesis del modelo? 8.6.1.2 Datos de envasado Obtenemos los valores de diagnóstico y realizamos los correspondientes tests de hipótesis y análisis de influencia. # Valores de diagnóstico diagnostico &lt;- fortify(fit.envasado) # Gráfico ggplot(diagnostico,aes(x = maquina, y = .stdresid)) + geom_boxplot() + geom_hline(yintercept = 0, col = &quot;red&quot;) # Tests de hipótesis ols_test_normality(fit.envasado) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9074 0.1058 ## Kolmogorov-Smirnov 0.176 0.6420 ## Cramer-von Mises 1.5833 0.0000 ## Anderson-Darling 0.5552 0.1269 ## ----------------------------------------------- leveneTest(.stdresid ~ maquina, data = diagnostico) Tabla 8.7: DfF valuePr(&gt;F) 30.2090.888 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Análisis de influencia ols_plot_cooksd_chart(fit.envasado) Los tests de hipótesis resultan no significativos indicando que el modelo propuesto verifica dichas hipótesis. No se detectan además observaciones influyentes, con lo que el modelo propuesto y que fue analizado en la sección de estimación es el modelo final para este banco de datos. 8.6.1.3 Datos de venenos Utilizamos el modelo sin interacción que hemos obtenido tras el proceso de selección de efectos tratada en la sección anterior. # Modelo fit.venenos &lt;- lm (tiempo ~ veneno + antidoto, data = venenos) # Valores de diagnóstico diagnostico &lt;- fortify(fit.venenos) # Tests de hipótesis ols_test_normality(fit.venenos) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9221 0.0035 ## Kolmogorov-Smirnov 0.113 0.5353 ## Cramer-von Mises 12.0813 0.0000 ## Anderson-Darling 0.8952 0.0205 ## ----------------------------------------------- El test de Kolmogorov-Smirnov resulta no significativo indicando el cumplimiento de la hipótesis de normalidad. leveneTest(.stdresid ~ veneno*antidoto, data = diagnostico) Tabla 8.8: DfF valuePr(&gt;F) 114.160.000554 36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; El test de Leven resulta significativo indicando que no se cumple la hipótesis de varianza constante. Se plantea utilizar Box-Cox para obtener una posible transformación de la respuesta que permita verificar las hipótesis del modelo. MASS::boxcox(fit.venenos) Se puede ver que el intervalo de confianza para la transformación contiene el valor de -1. Esto nos da indicios de que podríamos utilizar la transformación inversa para corregir los problemas detectados de homogeneidad de varianzas. En ese caso habrá que tener en cuenta que todas nuestras conclusiones se basarán en dicha transformación. Comenzamos de nuevo con la construcción del modelo. # Creamos la variable transformada venenos &lt;- venenos %&gt;% mutate(tiempoinv = 1/tiempo) # Ajustamos el modelo de nuevo fit.venenos.inv &lt;- lm(tiempoinv ~ antidoto*veneno, data = venenos) # Selección utilizando el test F ols_step_backward_p(fit.venenos.inv, prem = 0.05) ## ## ## Elimination Summary ## ------------------------------------------------------------------------------ ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## ------------------------------------------------------------------------------ ## 1 antidoto:veneno 0.8454 0.827 0.4181 75.5483 0.4911 ## ------------------------------------------------------------------------------ El modelo resultante es aquel que no contiene la interacción. Obtenemos los coeficientes de ese modelo, así como las medias estimadas para la combinación de veneno-antídoto. Expresamos las medias con la transformación propuesta. # Modelo sin interacción fit.venenos.inv &lt;- lm(tiempoinv ~ antidoto + veneno, data = venenos) # Estimaciones de ambos modelos tab_model(fit.venenos.inv, show.r2 = FALSE)   tiempoinv Predictors Estimates CI p (Intercept) 2.70 2.35 – 3.05 &lt;0.001 antidoto [AB] -1.66 -2.06 – -1.25 &lt;0.001 antidoto [AC] -0.57 -0.98 – -0.17 0.007 antidoto [AD] -1.35 -1.76 – -0.95 &lt;0.001 veneno [VB] 0.47 0.12 – 0.82 0.010 veneno [VC] 2.00 1.65 – 2.35 &lt;0.001 Observations 48 Las ecuaciones de estimación son: \\[\\begin{array}{lll} 1/\\mu_{AA,VA} &amp; = \\alpha_0 + \\alpha_{AA} + \\beta_{VA} &amp; = 2.70 + 0 + 0 = 2.70\\\\ 1/\\mu_{AA,VB} &amp; = \\alpha_0 + \\alpha_{AA} + \\beta_{VB} &amp; = 2.70 + 0 + 0.47 = 3.17\\\\ 1/\\mu_{AA,VC} &amp; = \\alpha_0 + \\alpha_{AA} + \\beta_{VC} &amp; = 2.70 + 0 + 2.00 = 4.70\\\\ 1/\\mu_{AB,VA} &amp; = \\alpha_0 + \\alpha_{AB} + \\beta_{VA} &amp; = 2.70 - 1.66 + 0 = 1.04\\\\ 1/\\mu_{AB,VB} &amp; = \\alpha_0 + \\alpha_{AB} + \\beta_{VB} &amp; = 2.70 - 1.66 + 0.47 = 1.51\\\\ 1/\\mu_{AB,VC} &amp; = \\alpha_0 + \\alpha_{AB} + \\beta_{VC} &amp; = 2.70 - 1.66 + 2.00 = 3.04\\\\ 1/\\mu_{AC,VA} &amp; = \\alpha_0 + \\alpha_{AC} + \\beta_{VA} &amp; = 2.70 - 0.57 + 0 = 2.13\\\\ 1/\\mu_{AC,VB} &amp; = \\alpha_0 + \\alpha_{AC} + \\beta_{VB} &amp; = 2.70 - 0.57 + 0.47 = 2.60\\\\ 1/\\mu_{AC,VC} &amp; = \\alpha_0 + \\alpha_{AC} + \\beta_{VC} &amp; = 2.70 - 0.57 + 2.00 = 4.13\\\\ 1/\\mu_{AD,VA} &amp; = \\alpha_0 + \\alpha_{AD} + \\beta_{VA} &amp; = 2.70 - 1.35 + 0 = 1.35\\\\ 1/\\mu_{AD,VB} &amp; = \\alpha_0 + \\alpha_{AD} + \\beta_{VB} &amp; = 2.70 - 1.35 + 0.47 = 1.82\\\\ 1/\\mu_{AD,VC} &amp; = \\alpha_0 + \\alpha_{AD} + \\beta_{VC} &amp; = 2.70 - 1.35 + 2.00 = 3.35\\\\ \\end{array}\\] Veamos si se verifican las hipótesis del modelo: # Valores de diagnóstico diagnostico &lt;- fortify(fit.venenos.inv) # Tests de hipótesis ols_test_normality(fit.venenos.inv) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9789 0.5339 ## Kolmogorov-Smirnov 0.1057 0.6192 ## Cramer-von Mises 6.0617 0.0000 ## Anderson-Darling 0.2948 0.5834 ## ----------------------------------------------- leveneTest(.stdresid ~ veneno*antidoto, data = diagnostico) Tabla 8.9: DfF valuePr(&gt;F) 111.170.343 36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Análisis de influencia ols_plot_cooksd_chart(fit.venenos.inv) Se verifican las hipótesis del modelo. La transformación planteada permite obtener un modelo válido para la fase de predicción, y nos permite extraer conclusiones sobre la relación entre veneno y antídoto con el tiempo de reacción. 8.7 Predicción El proceso de predicción en este tipo de modelos es muy simple ya que los posibles valores de las predictoras coincide con las medias de los posibles niveles o combinación de los niveles del factor o factores que aparezcan en el modelo final. En este caso solo tiene sentido predecir los valores de la media ya que nuestro objetivo es el estudio de dichas medias. Veremos además como representar gráficamente los resultados de la predicción. 8.7.1 Ejemplos Obtenemos las tablas de medias estimadas para cada uno de los ejemplos tratados en esta unidad. 8.7.1.1 Datos de insecticidas Estamos interesados en predcir el número de insectos muertos en función del tipo de insecticida utilizado. Podemos obtener la tabla de predicción y el gráfico asociado con el código siguiente: # Objeto gráfico p &lt;- plot_model(fit.insecticidas, &quot;pred&quot;, terms = &quot;spray&quot;, show.stat = TRUE) # Tabla de estimaciones p$data Tabla 8.10: xpredictedstd.errorconf.lowconf.highgroupgroup_col 114.5&nbsp;1.1312.3&nbsp;&nbsp;16.7&nbsp;11 215.3&nbsp;1.1313.1&nbsp;&nbsp;17.6&nbsp;11 32.081.13-0.1364.3&nbsp;11 44.921.132.7&nbsp;&nbsp;7.1411 53.5&nbsp;1.131.28&nbsp;5.7211 616.7&nbsp;1.1314.4&nbsp;&nbsp;18.9&nbsp;11 Para obtener el verdadero valor de la media debemos deshacer la transformación utilizada para el ajuste del modelo. Representamos la media predicha así como un intervalo de predicción para ella. Ordenamos los valores obtenidos de mayor a menor predicción para una mejor visualización. # Secuencia de valores de predicción newdata &lt;- data.frame(spray = unique(insecticidas$spray)) # Predicción para la media de la respuesta newdata &lt;- data.frame(newdata, predict(fit.insecticidas, newdata, interval = &quot;confidence&quot;)) # Deshacemos la transformación newdata &lt;- newdata %&gt;% mutate(prediccion = exp(fit) - 1, lower = exp(lwr) - 1, upper = exp(upr) - 1) # Gráfico ordenado del menor al mayor valor en función del tipo de spray ggplot(newdata, aes(x = fct_reorder(spray, prediccion), y = prediccion)) + geom_errorbar(aes(ymin = lower, ymax = upper), width = .1) + geom_line() + geom_point() + labs(x = &quot;Spray&quot;, y = &quot;Conteo&quot;) + coord_flip() ¿Qué podemos decir del gráfico de predicción de medias obtenido? ¿ Qué insecticida es más efectivo y cual menos? 8.7.1.2 Datos de envasado Podemos obtener la tabla de predicción y el gráfico asociado con el código siguiente: # Objeto gráfico p &lt;- plot_model(fit.envasado, &quot;pred&quot;, terms = &quot;maquina&quot;, show.stat = TRUE, title = &quot; &quot;) # Tabla de estimaciones p$data Tabla 8.11: xpredictedstd.errorconf.lowconf.highgroupgroup_col 11063.6798.811311 21143.67107&nbsp;&nbsp;12111 31043.6797.311211 41243.67117&nbsp;&nbsp;13111 # Gráfico p Podemos ver como la predicción para la máquina 4 es diferente de las predicciones para las máquinas 1 y 3 (sus intervalos de confianza no se solapan). No hay diferencia entre la M4 y la M2, ni entre la M2 y la M1 o M3. La máquina que podemos indicar como más efectiva es la M4 ya que es la que produce un mayor número de envases sin defectos. 8.7.1.3 Datos de venenos Comenzaremos obteniendo la predicción para el modelo estimado y posteriormente lo haremos para la variable respuesta en la escala original. # Objeto gráfico p &lt;- plot_model(fit.venenos.inv, &quot;pred&quot;, terms = c(&quot;veneno&quot;,&quot;antidoto&quot;), show.stat = TRUE, title =&quot;&quot;) # Tabla de estimaciones en términos de la inversa p$data Tabla 8.12: xpredictedstd.errorconf.lowconf.highgroupgroup_col 12.7&nbsp;0.1742.36&nbsp;3.04AAAA 11.040.1740.6981.38ABAB 12.120.1741.78&nbsp;2.46ACAC 11.340.1741&nbsp;&nbsp;&nbsp;&nbsp;1.68ADAD 23.160.1742.82&nbsp;3.5&nbsp;AAAA 21.510.1741.17&nbsp;1.85ABAB 22.590.1742.25&nbsp;2.93ACAC 21.810.1741.47&nbsp;2.15ADAD 34.7&nbsp;0.1744.36&nbsp;5.04AAAA 33.040.1742.7&nbsp;&nbsp;3.38ABAB 34.130.1743.78&nbsp;4.47ACAC 33.350.1743.01&nbsp;3.69ADAD # Gráfico de interacción estimado p Dado que hemos utilizado la transformación inversa para encontrar el antídoto que mejor funciona para cada veneno debemos buscar el valor más alto de valor predicho. El antídoto AA es que le muestra valores predichos más altos para cualquier tipo de venenos por lo que resulta el más efectivo. Podemos ver el resultado gráficamente: # Gráfico de interacción estimado p ¿Cómo podemos interpretar los intervalos de confianza para la predicción que hemos obtenido? ¿Cómo se comportan los antídotos con cada veneno? ¿Este resultado es esperable en función del modelo ajustado? Obtenemos y representamos los valores de predicción en la escala original de la variable respuesta. # Creamos la combinación de grupos con ambos factores f1 &lt;- unique(venenos$antidoto) f2 &lt;- unique(venenos$veneno) # Generamos todas las posibles combinaciones de niveles newdata &lt;- data.frame(expand.grid(f1, f2)) colnames(newdata) &lt;- c(&quot;antidoto&quot;, &quot;veneno&quot;) # Predicción para la media de la respuesta newdata &lt;- data.frame(newdata, predict(fit.venenos.inv, newdata, interval=&quot;confidence&quot;)) # Deshacemos la transformación inversa newdata &lt;- newdata %&gt;% mutate(prediccion = 1/fit, lower = 1/lwr, upper = 1/upr) # Presentamos los datos en la escala transformada y la original newdata Tabla 8.13: antidotovenenofitlwruprprediccionlowerupper AAVA2.7&nbsp;2.35&nbsp;3.050.3710.4260.328 ABVA1.040.6881.390.9631.45&nbsp;0.72&nbsp; ACVA2.121.77&nbsp;2.470.4710.5640.404 ADVA1.340.9941.690.7441.01&nbsp;0.59&nbsp; AAVB3.162.81&nbsp;3.520.3160.3550.284 ABVB1.511.16&nbsp;1.860.6630.8640.538 ACVB2.592.24&nbsp;2.940.3860.4460.34&nbsp; ADVB1.811.46&nbsp;2.160.5520.6840.462 AAVC4.7&nbsp;4.35&nbsp;5.050.2130.23&nbsp;0.198 ABVC3.042.69&nbsp;3.390.3290.3720.295 ACVC4.133.77&nbsp;4.480.2420.2650.223 ADVC3.353&nbsp;&nbsp;&nbsp;&nbsp;3.7&nbsp;0.2990.3340.271 Realizamos el gráfico de predicción en la escala original de la variable respuesta ordenando los intervalos de confianza desde el tiempo de reacción más pequeño al más grande, para así determinar las combinaciones antídoto-veneno más efectivas. # Variable de combinaciones de factores newdata &lt;- newdata %&gt;% mutate(grupo = paste(antidoto,veneno)) # Gráfico ggplot(newdata, aes(x = fct_reorder(grupo,fit), y = fit, colour = veneno)) + geom_errorbar(aes(ymin = lwr, ymax = upr), width=.1) + geom_line() + geom_point() + coord_flip() + labs(y = &quot;Tiempo&quot;, x = &quot;Antidoto-Veneno&quot;) Las conclusiones que podemos extraer son: Para el veneno VA los mejores antídotos son el AA y el AC con tiempos de reacción similares (intervalos de predicción no disjuntos), y distintos de los que proporcionan el antídoto AD y el AB. Para el veneno VB los mejores antídotos son el AA y el AC con tiempos de reacción similares, y distintos de los que proporcionan el antídoto AD y el AB. Para el veneno VC los mejores antídotos son el AA y el AC con tiempos de reacción similares, y distintos de los que proporcionan el antídoto AD y el AB. A la hora de elegir deberíamos hacerlo entre AA y AC para cualquiera de los venenos. Además, podemos ver que el veneno VC es el más resistente a los antídotos ya que tiene mayores tiempos de reacción (sitúa más intervalos de predicción en la zona alta). El menos resistente sería el veneno VA (mayor número de intervalos de predicción en la parte inferior). 8.8 Ejercicios Ejercicio 1. Se realiza una investigación para conocer los niveles de fosfato inorgánico en plasma (mg / dl) una hora después de una prueba de tolerancia a la glucosa estándar para sujetos obesos, con o sin hiperinsulinemia, y controles. Los datos corresponden con la tabla 6.18 de Dobson (2002). # Lectura de datos ejer01 &lt;- read_csv(&quot;https://goo.gl/3L4EtK&quot;, col_types = &quot;cd&quot;) Ejercicio 2. Se lleva a cabo un estudio sobre el contenido promedio de grasa (en porcentaje) en la leche del ganado de cinco razas distintas canadienses. Para ello se consideran veinte ejemplares de pura raza (diez de dos años y diez maduras de más de cuatro años de cada una de cinco razas. # Lectura de datos ejer02 &lt;- read_csv(&quot;https://goo.gl/J2ZKWK&quot;, col_types = &quot;dcc&quot;) Ejercicio 3. Los datos que se presentan a continuación (Dobson 2002) corresponden a un estudio en el que semillas genéticamente iguales son asignadas aleatoriamente, bien a un entorno enriquecido nutricionalmente (tratamiento), bien a condiciones estándar (control). Una vez han crecido todas las plantas, se recolectan, secan y pesan. El interés es investigar el efecto del tratamiento utilizado sobre le peso seco (en gramos) de las plantas en cuestión. peso &lt;- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14, 4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69) entorno &lt;- c(rep(&quot;tratamiento&quot;,10),rep(&quot;control&quot;,10)) ejercicio03 &lt;- data.frame(peso,entorno) Ejercicio 4. Se realiza un estudio experimental para estudiar el rendimiento de un proceso químico en función de la concentración del compuesto base (A, B, C y D), el catalizador usado (C1, C2, y C3), y la temperatura usada en el proceso (T1, T2). Se quiere estudiar como afectan estos factores en el rendimiento del proceso. ejercicio04 &lt;- read_csv(&quot;https://bit.ly/2GhFsl7&quot;, col_types = &quot;dccc&quot;) ejercicio04 &lt;- ejercicio04 %&gt;% mutate_if(sapply(ejercicio04,is.character),as.factor) Ejercicio 5. Se quiere evaluar la eficacia de distintas dosis de un fármaco contra la hipertensión arterial, comparándola con la de una dieta sin sal. Para ello se seleccionan al azar 25 hipertensos y se distribuyen aleatoriamente en 5 grupos. Al primero de ellos no se le suministra ningún tratamiento (T1), al segundo una dieta con un contenido pobre en sal (T2), al tercero una dieta sin sal (T3), al cuarto el fármaco a una dosis determinada (T4) y al quinto el mismo fármaco a otra dosis (T5). Las presiones arteriales (Presion) sistólicas de los 25 sujetos al finalizar los tratamientos son: presion &lt;- c(180, 173, 175, 182, 181, 172, 158, 167, 160, 175, 163, 170, 158, 162, 170, 158, 146, 160, 171, 155, 147, 152, 143, 155, 160) tratamiento &lt;- c(rep(&quot;T1&quot;,5),rep(&quot;T2&quot;,5),rep(&quot;T3&quot;,5), rep(&quot;T4&quot;,5),rep(&quot;T5&quot;,5)) ejercicio05 &lt;- data.frame(presion, tratamiento) Ejercicio 6. La convección es una forma de transferencia de calor por los fluidos debido a sus variaciones de densidad por la temperatura; las partes calientes ascienden y las frías descienden formando las corrientes de convección que hacen uniforme la temperatura del fluido. Se ha realizado un experimento para determinar las modificaciones de la densidad de fluido al elevar la temperatura en una determinada zona. Los resultados obtenidos han sido los siguientes: densidad &lt;- c(21.8, 21.9, 21.7, 21.6, 21.7, 21.7, 21.4, 21.5, 21.4, 21.9, 21.8, 21.8, 21.6, 21.5, 21.9, 22.1, 21.85, 21.9) temperatura &lt;- c(rep(&quot;T100&quot;,5),rep(&quot;T125&quot;,4),rep(&quot;T150&quot;,5), rep(&quot;T175&quot;,4)) ejercicio06 &lt;- data.frame(densidad, temperatura) Ejercicio 7. Un laboratorio de reciclaje controla la calidad de los plásticos utilizados en bolsas. Se desea contrastar si existe variabilidad en la calidad de los plásticos que hay en el mercado. Para ello, se eligen al azar cuatro plásticos y se les somete a una prueba para medir el grado de resistencia a la degradación ambiental. De cada plástico elegido se han seleccionado ocho muestras y los resultados de la variable que mide la resistencia son los de la tabla adjunta. resistencia &lt;- c(135, 175, 97, 169, 213, 171, 115, 143, 275, 170, 154, 133, 219, 187, 220, 185, 169, 239, 184, 222, 253, 179, 280, 193, 115, 105, 93, 85, 120, 74, 87, 63) plastico &lt;- c(rep(&quot;PA&quot;,8),rep(&quot;PB&quot;,8),rep(&quot;PC&quot;,8), rep(&quot;PD&quot;,8)) ejercicio07 &lt;- data.frame(resistencia, plastico) Ejercicio 8. Se realiza un estudio sobre el efecto que produce la descarga de aguas residuales de un planta sobre la ecología del agua natural de un río. En el estudio se utilizaron dos lugares de muestreo. Un lugar está aguas arriba del punto en el que la planta introduce aguas residuales en la corriente; el otro está aguas abajo. Se tomaron muestras durante un periodo de cuatro semanas y se obtuvieron los datos sobre el número de diatomeas halladas. Los datos se muestran en la tabla adjunta: diatomeas &lt;- c(78, 94, 43, 58, 620, 760, 420, 913, 204, 333, 98, 89, 890, 655, 763, 562, 79, 87, 145, 522, 546, 652, 76, 94, 45, 69, 59, 62, 254, 86, 789, 267) semana &lt;- c(rep(&quot;S1&quot;,4), rep(&quot;S2&quot;,4), rep(&quot;S3&quot;,4), rep(&quot;S4&quot;,4), rep(&quot;S1&quot;,4), rep(&quot;S2&quot;,4), rep(&quot;S3&quot;,4), rep(&quot;S4&quot;,4)) lugar &lt;- c(rep(&quot;Aguas arriba&quot;,16), rep(&quot;Aguas abajo&quot;,16)) ejercicio08 &lt;- data.frame(diatomeas, semana, lugar) Ejercicio 9. (Estos datos corresponden a modelos ANOVA) Un fabricante de ropa que suministra uniformes militares debe cortar chaquetas, camisas, pantalones (variable Prenda) y otros complementos (en muchas tallas diferentes), de rollos de tela. La tela es cara, de modo que el desperdicio (Desperdicio) tiene un efecto muy grande en los beneficios. El fabricante tiene que elegir entre tres máquinas (Maquina) cortadoras asistidas por computadora: A, B y C. El fabricante decide experimentar haciendo que cada máquina corte varios lotes de chaquetas, varios más de camisas otros más de pantalones y complementos para determinar que máquina es más eficiente en cada caso, es decir, tratamos de conocer el desperdicio que se producirá para cada prenda y máquina. # Lectura de datos ejer09 &lt;- read_csv(&quot;https://bit.ly/2GcVn3R&quot;, col_types = &quot;ccd&quot;) ejer09 &lt;- ejer09 %&gt;% mutate_if(sapply(ejer09,is.character),as.factor) References "],["ancova.html", "Unidad 9 Modelos ANCOVA 9.1 Bancos de datos 9.2 Modelo ANCOVA básico 9.3 Análisis preliminar 9.4 Ajuste y Selección del modelo 9.5 Diagnóstico del modelo 9.6 Predicción 9.7 Ejercicios modelos ANCOVA", " Unidad 9 Modelos ANCOVA En este tema se presentan los modelos ANCOVA o modelos de análisis de la covarianza. Esto modelos surgen cuando entre las posibles variables predictoras de la respuesta (de tipo numérico) consideramos tanto variables numéricas como factores. El objetivo principal de este tipo de modelos es estudiar si la relación entre las predictoras numéricas y la respuesta viene condicionada por el factor o factores de clasificación considerados, es decir, si debemos construir: un único modelo entre la respuesta y las predictoras de tipo numérico, un único modelo entre la respuesta y las predictoras de tipo categórico (factores), un modelo diferente entre la respuesta y las predictoras numéricas para cada nivel o combinaciones de niveles de los factores. Este tipo de modelos permiten una versatilidad que nos posibilita el estudio de situaciones experimentales más complejas. Sin embargo, no están exentos de dificultades sobre todo en lo que tiene que ver con el cumplimiento de las hipótesis del modelo. En función del modelo final las hipótesis de normalidad y homogeneidad varían en su aplicación. Además, el proceso de selección del mejor modelo requiere de un proceso de análisis más profundo debido a la inclusión de diferentes tipos de variables en el conjunto de posibles predictoras. Para introducir los conceptos básicos de este tipo de modelos y mostrar todas sus posibilidades de análisis comenzaremos con el modelo ANCOVA más sencillo donde únicamente consideramos dos variables predictoras, una de tipo numérico y la otra un factor. La formulación presentada se puede generalizar rápidamente a situaciones más complejas donde el número de predictoras sea mayor. 9.1 Bancos de datos Veamos los diferentes bancos de datos que iremos analizando a lo largo de la unidad. Ejemplo 1. Datos de tiempo de vida. Se desea estudiar el tiempo de vida de una pieza (vida) cortadora de dos tipos, A y B (herramienta), en función de la velocidad del torno (velocidad) en el que está integrada (en revoluciones por segundo). El objetivo del análisis es describir la relación entre el tiempo de vida de la pieza y la velocidad del torno, teniendo en cuenta de qué tipo es la pieza. Cargamos los datos y realizamos el gráfico descriptivo: # Carga de datos velocidad &lt;- c(610, 950, 720, 840, 980, 530, 680, 540, 980, 730, 670, 770, 880, 1000, 760, 590, 910, 650, 810, 500) vida &lt;- c(18.73, 14.52, 17.43, 14.54, 13.44, 25.39, 13.34, 22.71, 12.68, 19.32, 30.16, 27.09, 25.40, 26.05, 33.49, 35.62, 26.07, 36.78, 34.95, 43.67) herramienta &lt;- gl(2, 10, 20, labels=c(&quot;A&quot;, &quot;B&quot;)) tiempovida &lt;- data.frame(velocidad, vida, herramienta) # Gráfico ggplot(tiempovida, aes(x = velocidad, y = vida, color = herramienta)) + geom_point() A la vista de la Figura anterior se puede apreciar que el comportamiento del tiempo de vida con respecto a la velocidad disminuye al aumentar esta última, y además ese descenso es distinto en función de la herramienta utilizada. A la misma velocidad la herramienta A proporciona un tiempo de vida inferior que la herramienta B. Para ambas máquinas se aprecia una tendencia lineal bastante clara que deberá ser objeto de estudio. Esto implicaría que nuestro modelo se desdoblaría en dos rectas de regresión lineal simple en función de la herramienta utilizada. Ejemplo 2. Datos de longevidad. Partridge y Farquhar realizan un experimento para relacionar la vida útil (longevidad) de las moscas de la fruta con su actividad sexual (actividad). La información recogida es la longevidad en días de 125 moscas macho, divididas en cinco grupos bajo diferentes condiciones ambientales para medir su actividad sexual. Asimismo, se recoge la longitud del tórax (thorax) ya que se sospecha que afecta directamente a la longevidad de las moscas. Cargamos los datos y realizamos el gráfico descriptivo: # Carga de datos thorax &lt;- c(0.68, 0.68, 0.72, 0.72, 0.76, 0.76, 0.76, 0.76, 0.76, 0.8, 0.8, 0.8, 0.84, 0.84, 0.84, 0.84, 0.84, 0.84, 0.88, 0.88, 0.92, 0.92, 0.92, 0.94, 0.64, 0.7, 0.72, 0.72, 0.72, 0.76, 0.78, 0.8, 0.84, 0.84, 0.84, 0.84, 0.84, 0.88, 0.88, 0.88, 0.88, 0.88, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.94, 0.64, 0.68, 0.72, 0.76, 0.76, 0.8, 0.8, 0.8, 0.82, 0.82, 0.84, 0.84, 0.84, 0.84, 0.84, 0.84, 0.88, 0.88, 0.88, 0.88, 0.88, 0.88, 0.88, 0.92, 0.92, 0.68, 0.68, 0.72, 0.76, 0.78, 0.8, 0.8, 0.8, 0.84, 0.84, 0.84, 0.84, 0.84, 0.84, 0.88, 0.88, 0.88, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.92, 0.92, 0.64, 0.64, 0.68, 0.72, 0.72, 0.74, 0.76, 0.76, 0.76, 0.78, 0.8, 0.8, 0.82, 0.82, 0.84, 0.84, 0.84, 0.84, 0.88, 0.88, 0.88, 0.88, 0.88, 0.88, 0.92) longevidad &lt;- c(37, 49, 46, 63, 39, 46, 56, 63, 65, 56, 65, 70, 63, 65, 70, 77, 81, 86, 70, 70, 77, 77, 81, 77, 40, 37, 44, 47, 47, 47, 68, 47, 54, 61, 71, 75, 89, 58, 59, 62, 79, 96, 58, 62, 70, 72, 75, 96, 75, 46, 42, 65, 46, 58, 42, 48, 58, 50, 80, 63, 65, 70, 70, 72, 97, 46, 56, 70, 70, 72, 76, 90, 76, 92, 21, 40, 44, 54, 36, 40, 56, 60, 48, 53, 60, 60, 65, 68, 60, 81, 81, 48, 48, 56, 68, 75, 81, 48, 68, 16, 19, 19, 32, 33, 33, 30, 42, 42, 33, 26, 30, 40, 54, 34, 34, 47, 47, 42, 47, 54, 54, 56, 60, 44) actividad &lt;- c(rep(&quot;G1&quot;,24),rep(&quot;G2&quot;,25),rep(&quot;G3&quot;,25),rep(&quot;G4&quot;,25),rep(&quot;G5&quot;,25)) longevidad &lt;- data.frame(thorax,longevidad,actividad) # Gráfico ggplot(longevidad, aes(x = thorax, y = longevidad, color = actividad)) + geom_point() Se puede ver como la longevidad aumenta cuando aumenta la longitud del thorax pero ese crecimiento no parece distinto según actividad, dado que las nubes de puntos están bastante mezcladas. En este caso no parece adecuado un modelo lineal para cada grupo de actividad. 9.2 Modelo ANCOVA básico Consideramos el modelo ANCOVA más sencillo donde consideramos dos variables predictoras: una numérica y otra un factor. Consideramos una muestra de tamaño \\(n\\) donde tenemos: Una variable respuesta, \\(Y\\), de tipo numérico con observaciones \\(y_1,...,y_n\\). Una variable predictora, \\(X\\), de tipo numérico con observaciones \\(x_1,...,x_n\\). Una variable predictora, \\(F\\), de tipo categórico con \\(I\\) grupos o niveles distintos de tamaños muestrales \\(n_1,n_2,...,n_I\\), de forma que \\(n = n_1 + n_2 + ... + n_I\\), de forma que el vector de observaciones de la respuesta y de la predictora numérica se pueden escribir como: \\[(Y_1, Y_2,...,Y_I) = y_{11},\\ldots,y_{1n_1},y_{21},\\ldots,y_{2n_2},\\ldots, y_{I1},\\ldots,y_{In_I}\\] \\[ (X_1, X_2,...,X_I) = x_{11},\\ldots,x_{1n_1},x_{21},\\ldots,x_{2n_2},\\ldots,x_{I1},\\ldots,x_{In_I} \\] donde el primer subíndice indica el nivel del factor y el segundo la posición dentro del conjunto de datos de dicho nivel del factor. * Conjunto \\(\\mu_i\\) de medias de todas las observaciones de la respuesta asociadas con el nivel \\(i\\) del factor, es decir: \\[ \\mu_i = \\frac{\\sum_{j = 1}^{n_j} y_{ij}}{n_i}; \\text{ i = 1, 2,..., I} \\] Media global de la respuesta, \\(\\mu\\), que se puede obtener como: \\[ \\mu = \\frac{\\sum_{j = 1}^{I} \\mu_{j}}{I} \\] Incrementos, \\(\\alpha_i\\), de cada una de las medias de cada grupo con respecto a la media global, es decir: \\[ \\alpha_i= \\mu - \\mu_i; \\text{ i = 1, 2,..., I} \\] Pendiente común, \\(\\beta\\), que representa la posible relación entre las variables de tipo numérico. Pendientes diferentes entre las predictoras numéricas asociadas a cada nivel del factor, \\(\\gamma_i\\) con \\(i = 1,...,I\\). En esta situación el modelo que describe la posible relación entre respuesta y predictoras se puede escribir como: \\[\\begin{equation} y_{ij} = \\alpha_0 + \\alpha_i + \\beta x_{ij} + \\gamma_i x_{ij} + \\epsilon_{ij};\\quad i=1,...,I \\quad \\text{con} \\quad \\alpha_I = 0 \\tag{9.1} \\end{equation}\\] que en forma matricial se puede escribir fácilmente (de forma análoga al ANOVA de un vía) sin más que considerar \\(1_(n_i )={1,...,1}\\) un vector de \\(n_i\\) unos, \\(0_(n_i )={0,...,0}\\) un vector de \\(n_i\\) ceros, para cada uno de los niveles i del factor la matriz de diseño viene dada por: \\[ Y = \\left( \\begin{array}{c} Y_1 \\\\ Y_2 \\\\ \\ldots \\\\ Y_I \\\\ \\end{array} \\right) = \\left( \\begin{array}{ccccccccc} 1_{n_1} &amp; 1_{n_1} &amp; 0_{n_1} &amp; \\ldots &amp; 0_{n_1} &amp; X_1 &amp; X_1 &amp; \\ldots &amp; 0_{n_1}\\\\ 1_{n_2} &amp; 0_{n_2} &amp; 1_{n_2} &amp; \\ldots &amp; 0_{n_2} &amp; X_2 &amp; 0_{n_2} &amp; \\ldots &amp; 0_{n_2}\\\\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots &amp; 0_{n_3}\\\\ 1_{n_I} &amp; 0_{n_I} &amp; 0_{n_I} &amp;\\ldots &amp; 1_{n_I} &amp; X_I &amp; 0_{n_I} &amp; \\ldots &amp; X_I\\\\ \\end{array} \\right) \\left( \\begin{array}{c} \\alpha_0 \\\\ \\alpha_1 \\\\ \\alpha_2 \\\\ \\ldots \\\\ \\alpha_{I_1} \\\\ \\beta \\\\ \\gamma_1\\\\ \\ldots\\\\ \\gamma_I\\\\ \\end{array} \\right) + \\left( \\begin{array}{c} e_1 \\\\ e_2 \\\\ \\ldots \\\\ e_n \\\\ \\end{array} \\right) = X\\beta + \\epsilon \\] donde las primeras \\(I\\) columnas representan el efecto del factor (ANOVA de una vía), la siguiente columna representa el efecto común entre predictoras numéricas (Regresión lineal simple), y las últimas \\(I\\) columnas representan el efecto distinto de la predictora numérica para cada nivel del factor. Estas columnas se obtienen fácilmente multiplicando la columna de \\(X\\) por cada de las columnas desde la \\(2\\) a la \\(I\\). Las posibles modelos anidados que se pueden obtener a partir de la ecuación (9.1), así como sus interpretaciones se presentan a continuación. Además, se ofrece la interpretación de dichos modelos en términos de los coeficientes que resulten significativos. 9.2.1 I rectas de regresión perpendiculares Este modelo es el más general y considera una pendiente distinta para la predictora numérica en función de los niveles del factor, que resulta equivalente a plantear el contraste \\[\\begin{equation} \\left\\{ \\begin{array}{ll} H_0: &amp; \\gamma_1 = \\gamma_2 = \\ldots = \\gamma_I = 0\\\\ H_a: &amp; \\mbox{Al menos hay una pendiente distinto de cero}\\\\ \\end{array} \\right. \\tag{9.2} \\end{equation}\\] Si rechazamos el contraste (9.2) tendremos un modelo de regresión entre la respuesta y la predictora numérica para cada nivel del factor, es decir, I rectas de regresión distintas con ecuaciones: \\[\\begin{equation} \\begin{array}{ll} y_{1j} &amp;= (\\alpha_0 + \\alpha_1) + (\\beta + \\gamma_1) x_{1j} + \\epsilon_{1j}\\\\ y_{2j} &amp;= (\\alpha_0 + \\alpha_2) + (\\beta + \\gamma_2) x_{2j} + \\epsilon_{2j}\\\\ \\ldots &amp;= \\ldots \\\\ y_{Ij} &amp;= (\\alpha_0 + \\alpha_I) + (\\beta + \\gamma_I) x_{Ij} + \\epsilon_{Ij}\\\\ \\end{array} \\tag{9.3} \\end{equation}\\] con interceptaciones \\(\\alpha_0 + \\alpha_i\\) y pendientes \\(\\beta + \\gamma_i\\) para cada uno de los \\(I\\) niveles del factor. Tenemos I modelos de regresión distintos (uno por cada nivel del factor), es decir, tenemos I rectas perpendiculares o que se cortan. Ejemplo. Para el banco de datos de tiempo de vida podemos representar gráficamente el modelo asumiendo dos rectas de regresión perpendiculares de vida versus velocidad del torno en función de la herramienta utilizada. Se puede ver como las rectas tienen interceptaciones distintas y pendientes algo diferentes. Las tendencias no son perpendiculares en el sentido estricto sino que existe algún punto de corte entre ellas. La resolución del contraste nos indicara si el modelo es adecuado o si deberíamos optar por un modelo más sencillo. Ejemplo. Para el banco de datos de longevidad representamos gráficamente el modelo que asume 5 rectas de regresión perpendiculares de longevidad versus longitud del thorax en función del grupo de actividad. Se puede ver como las rectas tienen interceptaciones distintas y pendientes muy similares lo que puede ser un indicativo de que este modelo de rectas perpendiculares no es adecuado. 9.2.2 I rectas de regresión paralelas Si no rechazamos el contraste (9.2) tendremos un único modelo de regresión entre la respuesta y la predictora pero con diferentes interceptaciones (la pendiente es la misma), es decir, I rectas paralelas cuyas ecuaciones vienen dadas por: \\[\\begin{equation} \\begin{array}{ll} y_{1j} &amp;= (\\alpha_0 + \\alpha_1) + \\beta x_{1j} + \\epsilon_{1j}\\\\ y_{2j} &amp;= (\\alpha_0 + \\alpha_2) + \\beta x_{2j} + \\epsilon_{2j}\\\\ \\ldots &amp;= \\ldots \\\\ y_{Ij} &amp;= (\\alpha_0 + \\alpha_I) + \\beta x_{Ij} + \\epsilon_{Ij}\\\\ \\end{array} \\tag{9.4} \\end{equation}\\] Ejemplo. Modelo de rectas paralelas para el banco de datos de tiempo de vida. E ¿Se diferencia mucho este gráfico del de rectas perpendiculares visto antes? Ejemplo. Modelos de rectas paralelas para el banco de datos de longevidad. En este caso el gráfico es prácticamente idéntico indicando que para estos datos el modelo de rectas paralelas tiene la misma capacidad explicativa que el de rectas perpendiculares. En la situación donde el contraste (9.2) es no significativo podemos definir diferentes modelos anidados en función de los incrementos del factor (`s) y la pendiente \\(\\beta\\). Los contrastes son: \\[\\begin{equation} \\left\\{ \\begin{array}{ll} H_0: &amp; \\alpha_1 = \\alpha_2 = \\ldots = \\alpha_I = 0\\\\ H_a: &amp; \\mbox{Al menos hay un incremento distinto de cero}\\\\ \\end{array} \\right. \\tag{9.5} \\end{equation}\\] y \\[\\begin{equation} \\left\\{ \\begin{array}{ll} H_0: &amp; \\beta = 0\\\\ H_a: &amp; \\beta \\neq 0 \\end{array} \\right. \\tag{9.6} \\end{equation}\\] La resolución de estos contrastes nos lleva a nuevos modelos que pasamos a describir. 9.2.3 Una recta de regresión Si no rechazamos la hipótesis nula de (9.5) pero si rechazamos la hipótesis nula de (9.6) diríamos que no hay efecto del factor pero si que podemos establecer un modelo de regresión entre la respuesta y la predictora numérica (Modelo de Regresión Lineal Simple). Ejemplo. Modelo de recta de regresión para el banco de datos de tiempo de vida. ¿Qué podemos decir de este modelo frente a los anteriores? Ejemplo. Modelo de recta de regresión para el banco de datos de longevidad. ¿Podríamos considerar este modelo como válido frente a los considerados antes? Recuerda que siempre buscamos modelos con capacidades explicativas similares pero con menos efectos o variables. 9.2.4 ANOVA de una vía Si rechazamos la hipótesis nula de (9.5) pero no rechazamos la hipótesis nula de (9.6) diríamos que no hay efecto de la predictora numérica pero que si podemos establecer diferencias entre las medias de la respuesta dadas por los diferentes niveles del factor. Nos encontramos ante un modelo ANOVA de una vía. En esta situación asumimos que no existe rectas de regresión que relacionen el comportamiento de la respuesta con la predictora numérica, es decir, ya no tendremos una nube de puntos sino datos agrupados por el factor. Ejemplo. Modelo ANOVA de una vía para el banco de datos de tiempo de vida. Se observa claramente como la herramienta de tipo B produce un tiempo de vida superior al del tipo A. Al menos el efecto del factor parece relevante para explicar el comportamiento del tiempo de vida. Ejemplo. Modelo ANOVA de una vía para el banco de datos de longevidad. El gráfico de cajas asociado con el factor muestra que los primeros cuatro grupos tienen un comportamiento muy similar, y tan sólo el grupo cinco parecer tener una longevidad inferior al resto. 9.2.5 Modelos sin efectos Si no rechazamos la hipótesis nula de (9.5) y no rechazamos la hipótesis nula de (9.6) estaríamos ante un modelo nulo donde el comportamiento de la respuesta no viene explicado por las predictoras consideradas. 9.2.6 Especificación del modelo en R El modelo ANCOVA planteado para un factor \\(F\\) y una variable predictora numérica \\(X\\), se puede escribir en R en su formato reducido como: \\[Y \\sim F + X + F:X\\] donde: \\(F\\) representa el efecto del factor, es decir, comparamos si las medias de la respuesta para cada grupo pueden considerarse iguales. \\(X\\) representa el efecto de regresión asociado con la variable numérica, es decir, la respuesta y X están relacionadas mediante una única pendiente que deberemos estimar. \\(F:X\\) representa el efecto de interacción entre predictoras, es decir, que la respuesta se relaciona con la predictora numérica mediante tantas curvas (generalmente líneas) como niveles tenga el factor \\(F\\). A continuación, se presentan los modelos reducidos para diferentes situaciones experimentales en el número y tipo de variables predictoras: Modelo para dos factores (\\(F_1\\) y \\(F_2\\)) y una numérica (\\(X\\)) \\[Y \\sim F_1 + F_2 + F_1:F_2 + X + F_1:X + F_2:X + F_1:F_2:X\\] o en forma más simplificada \\(Y \\sim F_1*F_2*X\\) Modelo para un factor (\\(F\\)) y dos numéricas (\\(X_1\\) y \\(X_2\\)) \\[Y \\sim F + X_1 + X_2 + F:X_1 + F:X_2\\] o en forma más simplificada \\(Y \\sim F*(X_1 + X_2)\\) Modelo para dos factores (\\(F_1\\) y \\(F_2\\)) y dos numéricas (\\(X_1\\) y \\(X_2\\)) \\[Y \\sim F_1*F_2*(X_1 + X_2)\\] Como se puede ver la complejidad del modelo aumenta sustancialmente con la consideración de más variables predictoras. La forma de expresar el modelo saturado debe contemplar tanto los efectos principales asociados a cada predictora, como los efectos de interacción entre factores y entre factores y numéricas. 9.3 Análisis preliminar En este tipo de modelos el análisis preliminar pasa por una representación de los diferentes modelos que pueden surgir desde el modelo saturado. En este caso se muestra como especificar los diferentes modelos y como obtener los gráficos correspondientes. Ejemplo. (Tiempo de vida). El objetivo del análisis es describir la relación entre el tiempo de vida de la pieza y la velocidad del torno, teniendo en cuenta de qué tipo es la pieza. Tenemos entonces los posibles modelos que involucran a la velocidad: \\[ \\left\\{ \\begin{array}{ll} \\mbox{M0}:&amp; Vida \\sim velocidad\\\\ \\mbox{M1}:&amp; Vida \\sim velocidad + herramienta\\\\ \\mbox{M2}:&amp; Vida \\sim velocidad + herramienta + velocidad:herramienta\\\\ \\end{array} \\right. \\] A continuación se presenta el código para poder representar todos estos modleos en un único gráfico. # Comenzamos con el modelo más sencillo # Modelo con una única recta M0 &lt;- lm(vida ~ velocidad, data = tiempovida) # M1: modelo con rectas paralelas M1 &lt;- lm(vida ~ herramienta + velocidad, data = tiempovida) # M2: modelo con rectas no paralelas M2 &lt;- lm(vida ~ herramienta + velocidad + herramienta:velocidad, data = tiempovida) # grid de valores para construir los modelos grid &lt;- tiempovida %&gt;% data_grid(herramienta, velocidad) %&gt;% gather_predictions(M0, M1, M2) # Gráfico ggplot(tiempovida,aes(velocidad, vida, colour = herramienta)) + geom_point() + geom_line(data = grid, aes(y = pred)) + facet_wrap(~ model) + labs(x = &quot;Velocidad del torno&quot;, y = &quot;Tiempo de vida&quot;) También representamos el modelo donde únicamente tenemos el factor (diagrama de cajas): \\[ \\begin{array}{ll} \\mbox{M}:&amp; Vida \\sim herramienta\\\\ \\end{array} \\] ggplot(tiempovida, aes(x = herramienta, y = vida)) + geom_boxplot() Ejemplo. Planterasmos los diferentes modelos para los datos de longevidad y los representamos gráficamente. \\[ \\left\\{ \\begin{array}{ll} \\mbox{M0}:&amp; longevidad \\sim thorax\\\\ \\mbox{M1}:&amp; longevidad \\sim thorax + actividad\\\\ \\mbox{M2}:&amp; longevidad \\sim thorax + herramienta + thorax:actividad\\\\ \\end{array} \\right. \\] # Comenzamos con el modelo más sencillo # Modelo con una única recta M0 &lt;- lm(longevidad ~ thorax, data = longevidad) # M1: modelo con rectas paralelas M1 &lt;- lm(longevidad ~ actividad + thorax, data = longevidad) # M2: modelo con rectas no paralelas M2 &lt;- lm(longevidad ~ actividad + thorax + actividad:thorax, data = longevidad) # grid de valores para construir los modelos grid &lt;- longevidad %&gt;% data_grid(actividad, thorax) %&gt;% gather_predictions(M0, M1, M2) # Gráfico ggplot(longevidad,aes(thorax, longevidad, colour = actividad)) + geom_point() + geom_line(data = grid, aes(y = pred)) + facet_wrap(~ model) + labs(x = &quot;Longitud del tórax&quot;, y = &quot;Longevidad&quot;) También representamos el modelo donde únicamente tenemos el factor (diagrama de cajas): \\[ \\begin{array}{ll} \\mbox{M}:&amp; longevidad \\sim actividad\\\\ \\end{array} \\] ggplot(longevidad, aes(x = actividad, y = longevidad)) + geom_boxplot() 9.4 Ajuste y Selección del modelo Las hipótesis del modelo ANCOVA son que los errores se distribuyen de forma independiente mediante una distribución Normal de media cero y varianza constante σ^2 para cada uno de los grupos que determina la variable predictora de tipo factor. Estas hipótesis se adaptarán en función del tipo de modelo que finalmente alcancemos en el proceso de selección (I rectas, una recta, o un ANOVA de una vía). Dado que hemos expresado el modelo ANCOVA como un modelo de tipo lineal con una ecuación similar a los modelos de regresión múltiple, la estimación de los parámetros del modelo se puede realizar utilizando las ecuaciones normales. En el proceso de selección del mejor modelo actuaremos como en los modelos ANOVA, es decir partiremos del modelo saturado y veremos que efectos puede ser considerados como irrelevantes, y por tanto deben desaparecer del modelo. Esta selección nos permitirá elegir el modelo final resultante. En este caso más sencillo podemos escribir todos los modelos posibles y elegir el mejor de ellos, bien mediante la comparación con el test F o con el AIC, pero en la práctica se recurre a los procedimientos secuenciales automáticos que son los que presentaremos aquí. Ejemplo. Realizamos la selección del mejor modleo apra el conjunto de datos de tiempo de vida. Para ello construimos el modelo saturado y utilizamos el procedimiento automático basado en el test F parcial. # Modelo saturado fit.vida &lt;- lm(vida ~ velocidad * herramienta, data = tiempovida) # Selección del modelo ols_step_backward_p(fit.vida, prem = 0.05) ## ## ## Elimination Summary ## ------------------------------------------------------------------------------------- ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## ------------------------------------------------------------------------------------- ## 1 velocidad:herramienta 0.8969 0.8847 3.9652 106.6591 3.0919 ## ------------------------------------------------------------------------------------- El proceso de selección identifica el efecto de interacción entre velocidad y herramienta como no significativo, de forma que el modelo final viene dado por: \\[vida \\sim velocidad + herramienta\\] Ajustamos el modelo con rectas paralelas, es decir, la pendiente de la recta entre el tiempo de vida y la velocidad stiene la misma pendiente, variando únicamenyte la interceptación en función del tipo de herramienta utilizada. Tenemos por tanto un modelo con dos rectas paralelas (una por cada tipo de herramienta). # Modelo saturado fit.vida &lt;- lm(vida ~ velocidad + herramienta, data = tiempovida) # Parámetros estimados tab_model(fit.vida, show.r2 = FALSE, show.p = FALSE)   vida Predictors Estimates CI (Intercept) 36.93 29.56 – 44.30 velocidad -0.03 -0.04 – -0.02 herramienta [B] 14.67 11.75 – 17.58 Observations 20 Las ecuaciones de estimación para este modelo vienen dadas por: \\[ \\left\\{ \\begin{array}{lll} \\mbox{Herramienta A}:&amp; \\widehat{Vida_{A}} = 36.93 + 0 - 0.03*velocidad &amp;= 36.93 -0.03*velocidad\\\\ \\mbox{Herramienta B}:&amp; \\widehat{Vida_{B}} = 36.93 + 14.67 - 0.03*velocidad &amp;= 51.60 - 0.03*velocidad \\\\ \\end{array} \\right. \\] Tenemos una interceptación mayor para la herramienta B indicando que la recta asociada con dicha herramienta está por encima de la de la herramienta A, lo que en térinos prácticos nos indica que el tiempo de vida con la herramienta B siempre será superior al del tipo A para cualquier velocidad considerada. Además, la pendiente negativa asociada con la velocidad indica que conforme aumenta esta disminuye el tiempo de vida. Ejemplo. Analizamos ahora los datos de longevidad. Construimos el modelo saturado y seleccionamos mediante el test \\(F\\). # Modelos fit.longevidad &lt;- lm(longevidad ~ thorax * actividad, data = longevidad) # Selección del modelo ols_step_backward_p(fit.longevidad, prem = 0.05) ## ## ## Elimination Summary ## ---------------------------------------------------------------------------------- ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## ---------------------------------------------------------------------------------- ## 1 thorax:actividad 0.6527 0.638 -3.7881 943.8165 10.5394 ## ---------------------------------------------------------------------------------- El proceso de selección identifica el efecto de interacción entre thorax y actividad como no significativo, de forma que el modelo final viene dado por: \\[longevidad \\sim thorax + actividad\\] Ajustamos el modelo y estudiamos los parámetros obtenidos: # Modelos fit.longevidad &lt;- lm(longevidad ~ thorax + actividad, data = longevidad) # Parámetros estimados tab_model(fit.longevidad, show.r2 = FALSE, show.p = FALSE)   longevidad Predictors Estimates CI (Intercept) -44.61 -65.53 – -23.69 thorax 134.34 109.13 – 159.55 actividad [G2] -4.14 -10.13 – 1.86 actividad [G3] -1.50 -7.48 – 4.47 actividad [G4] -11.15 -17.15 – -5.16 actividad [G5] -24.14 -30.12 – -18.17 Observations 124 Todas las rectas tienen la misma pendiente (coeficiente asociado a tórax) pero con distinto punto de origen debido al tratamiento al que son sometidos los sujetos. La pendiente positiva indica que la longevidad aumenta cuando lo hace la longitud del tórax, mientras que podemos ver que el grupo G1 es el de mayor longevidad por tener la interceptación más grande. Las ecuaciones para cada uno de los grupos viene dada por: \\[ \\left\\{ \\begin{array}{ll} \\mbox{G1}:&amp; \\widehat{logevidad_{G1}} = - 44.61 + 134.34*thorax\\\\ \\mbox{G2}:&amp; \\widehat{logevidad_{G2}} = - 48.75 + 134.34*thorax \\\\ \\mbox{G3}:&amp; \\widehat{logevidad_{G3}} = - 46.11 + 134.34*thorax \\\\ \\mbox{G4}:&amp; \\widehat{logevidad_{G4}} = - 55.76 + 134.34*thorax \\\\ \\mbox{G5}:&amp; \\widehat{logevidad_{G5}} = - 68.75 + 134.34*thorax \\\\ \\end{array} \\right. \\] El grupo con mayor longevidad es el G1, ya que tiene la interceptación más grande, mientras que el que tiene menor longevidad es G5. El orden vendría dado por \\(G1 &gt; G3 &gt; G2 &gt; G4 &gt; G5\\). 9.5 Diagnóstico del modelo En este caso el diagnóstico es similar al de los modelos de regresión pero teniendo en cuenta que las hipótesis se deben verificar para los residuos asociados a cada nivel del factor (si este está presente en el modelo). Las hipótesis son linealidad, normalidad y varianza constante. Para verificar la hipótesis de linealidad utilizamos el gráfico de residuos vs ajustados y residuos vs predictora numérica, mientras que usamos los tests de normalidad y homogeneidad para el resto de hipótesis. Utilizamos los mismos ejemplos de los puntos anteriores para mostrar como realizar el diagnóstico en este tipo de modelos. Ejemplo A continuación, se presenta el diagnóstico para el modelo de tiempos de vida. Para realizar el diagnóstico partimos del modelo obtenido en la sección anterior. # Valores de diagnóstico diagnostico &lt;- fortify(fit.vida) # Gráfico ggplot(diagnostico,aes(x = velocidad, y = .stdresid, colour = herramienta)) + geom_point() + geom_hline(yintercept = 0, col = &quot;red&quot;) + facet_wrap(. ~ herramienta) En la figura no se observan problemas con los residuos, aunque sí se puede ver que para el tipo A la variabilidad de los residuos aumenta cuando aumenta el valor ajustado, indicando posibles problemas con la homogeneidad de varianzas. Además, no se observa ningún tipo de tendencia que pueda indicar falta de linealidad. Procedemos con los tests de hipótesis. # Tests de hipótesis ols_test_normality(fit.vida) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9715 0.7858 ## Kolmogorov-Smirnov 0.1232 0.8859 ## Cramer-von Mises 1.4412 2e-04 ## Anderson-Darling 0.2652 0.6555 ## ----------------------------------------------- leveneTest(.stdresid ~ herramienta, data = diagnostico) Tabla 9.1: DfF valuePr(&gt;F) 11.390.254 18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Puesto que ambos tests resultan no significativo se verifican las hipótesis del modelo, por lo que estamos en condiciones de afirmar que el modelo resultante es adecuado para explicar el comportamiento del tiempo de vida en función del tipo de pieza y de la velocidad considerada. # Análisis de influencia ols_plot_cooksd_chart(fit.vida) La distancia de Cook no muestra ninguna observación influyente (valor mayor que 1). Dado que se verifican las hipótesis el modelo obtenido parece adecuado para estudiar el tiempo de vida en función de la velocidad y la herramienta utilizada. Ejemplo. Analizamos ahora el modelo correspondiente a los datos de longevidad. En primer lugar, realizamos el análisis gráfico de los residuos. En este caso no hay interacción presente en el modelo y todos los gráficos deben identificar cada uno de los niveles de actividad. # Valores de diagnóstico diagnostico &lt;- fortify(fit.longevidad) # Gráfico ggplot(diagnostico,aes(x = thorax, y = .stdresid, colour = actividad)) + geom_point() + geom_hline(yintercept = 0, col = &quot;red&quot;)+ facet_wrap(. ~ actividad) En la figura se puede observar que para algún nivel del factor los residuos aumentan o disminuyen en función del valor ajustado, por ejemplo para el grupo G3 (mayor variabilidad en el centro que en los extremos) indicando posibles problemas con la homogeneidad de varianzas. Pasamos a valorar las hipótesis del modelo. # Tests de hipótesis ols_test_normality(fit.longevidad) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9916 0.6607 ## Kolmogorov-Smirnov 0.0538 0.8654 ## Cramer-von Mises 10.2413 0.0000 ## Anderson-Darling 0.3224 0.5241 ## ----------------------------------------------- leveneTest(.stdresid ~ actividad, data = diagnostico) Tabla 9.2: DfF valuePr(&gt;F) 41.290.277 119&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Análisis de influencia ols_plot_cooksd_chart(fit.longevidad) Aunque se verifican las hipótesis del modelo y no se detectan observaciones influyentes, si que es cierto que los gráficos de residuos muestran cierto comportamiento de embudo con variabilidades más pequeñas en valores más pequeños de thorax, y mayor dispersión al aumentar la longitud del thorax. Sería recomendable probar Box-Cox para tratar de obtener una transformación de la respuesta que nos permita obtener gráficos sin esos efectos indeseables. MASS::boxcox(fit.longevidad) La transformación raíz cuadrada parece adecuada en esta situación. Obtenemos la nueva variable y ajustamos de nuevo el modelo. # Transformación longevidad &lt;- longevidad %&gt;% mutate(rlongevidad = sqrt(longevidad)) # Modelo saturado fit.longevidad &lt;- lm(rlongevidad ~ thorax * actividad, data = longevidad) # Selección del modelo ols_step_backward_p(fit.longevidad, prem = 0.05) ## ## ## Elimination Summary ## --------------------------------------------------------------------------------- ## Variable Adj. ## Step Removed R-Square R-Square C(p) AIC RMSE ## --------------------------------------------------------------------------------- ## 1 thorax:actividad 0.6868 0.6736 -3.0694 267.2943 0.6888 ## --------------------------------------------------------------------------------- De nuevo el modelo seleccionado prescinde del efecto de interacción. Ajustamos y estudiamos el nuevo modelo. # Modelos fit.longevidad &lt;- lm(rlongevidad ~ thorax + actividad, data = longevidad) # Parámetros estimados tab_model(fit.longevidad, show.r2 = FALSE, show.p = FALSE)   rlongevidad Predictors Estimates CI (Intercept) 0.34 -1.03 – 1.71 thorax 9.41 7.77 – 11.06 actividad [G2] -0.30 -0.69 – 0.09 actividad [G3] -0.12 -0.51 – 0.27 actividad [G4] -0.76 -1.15 – -0.37 actividad [G5] -1.73 -2.12 – -1.34 Observations 124 ¿Cuáles son las ecuaciones de estimación en este caso? El proceso de diagnóstico para el nuevo modelo permite verificar el cumplimiento de las hipótesis y la leve mejora de los gráficos de residuos. # Valores de diagnóstico diagnostico &lt;- fortify(fit.longevidad) # Gráfico ggplot(diagnostico,aes(x = thorax, y = .stdresid, colour = actividad)) + geom_point() + geom_hline(yintercept = 0, col = &quot;red&quot;)+ facet_wrap(. ~ actividad) # Tests de hipótesis ols_test_normality(fit.longevidad) ## ----------------------------------------------- ## Test Statistic pvalue ## ----------------------------------------------- ## Shapiro-Wilk 0.9951 0.9465 ## Kolmogorov-Smirnov 0.0474 0.9432 ## Cramer-von Mises 10.7431 0.0000 ## Anderson-Darling 0.2137 0.8484 ## ----------------------------------------------- leveneTest(.stdresid ~ actividad, data = diagnostico) Tabla 9.3: DfF valuePr(&gt;F) 40.6860.603 119&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Análisis de influencia ols_plot_cooksd_chart(fit.longevidad) 9.6 Predicción El proceso de predicción en este tipo de modelos es muy simple a partir de las ecuaciones de los modelos obtenidos. De hecho, en las secciones anteriores ya hemos visto gráficamente la predicción para todos estos modelos en los ejemplos que hemos ido trabajando. Básicamente, si queremos obtener una predicción especifica deberemos dar un valor del factor y otro de la predictora numérica para calcular el valor de predicción y su correspondiente intervalo. En este caso nos imitamos a representar las bandas de predicción que podemos obtener para cada modelo. Ejemplo. A continuación, se presentan las rectas de predicción para el modelo ajustado en el banco de datos de tiempo de vida. plot_model(fit.vida, &quot;pred&quot;, terms = c(&quot;velocidad&quot;, &quot;herramienta&quot;), title =&quot;Predicción de la media del tiempo de vida&quot;) En la figura se presentan los resultados obtenidos donde queda patente el comportamiento distinto para tipo de herramienta, mostrando que la de tipo B tiene un tiempo de vida superior, pero que se va reduciendo cuando aumentamos la velocidad. Ejemplo. A continuación, se presentan las rectas de predicción para el modelo ajustado en el banco de datos de longevidad. En la figura se presentan los resultados obtenidos donde queda patente el comportamiento paralelo para cada tipo de actividad, mostrando que el grupo G1 es el que muestra una mayor longevidad que aumenta además con la longitud del tórax. Además, podemos ver como el único grupo que muestra un comportamiento distinto es el del grupo G5, mientras que los otros grupos muestran predicciones muy similares. plot_model(fit.longevidad, &quot;pred&quot;, terms = c(&quot;thorax&quot;, &quot;actividad&quot;), title =&quot;Predicción de la raíz cuadrada de la media de longevidad&quot;) Obtenemos ahora el gráfico de predicción en la escala original. Deshacemos el cambio de raíz cuadrada y representamos de nuevo las bandas de confianza. # Creamos grid de predicción newdata &lt;- data.frame(thorax = rep(seq(min(longevidad$thorax), max(longevidad$thorax), .01), each=5), actividad = factor(c(&quot;G1&quot;, &quot;G2&quot;, &quot;G3&quot;, &quot;G4&quot;, &quot;G5&quot;))) # Obtenemos la predicción para el modelo ajusatdo newdata &lt;- data.frame(newdata, predict(fit.longevidad, newdata, interval=&quot;confidence&quot;)) # Eliminamos la raíz cuadrada de las predicciones newdata$fit &lt;- newdata$fit^2 newdata$lwr &lt;- newdata$lwr^2 newdata$upr &lt;- newdata$upr^2 # Gráfico de la predicción ggplot(newdata, aes(x = thorax, y = fit, color = actividad)) + geom_line() + geom_ribbon(aes(ymax = upr, ymin = lwr, fill = actividad), alpha = 1/5) + labs(x = &quot;Longitud del thorax&quot;, y = &quot;Longevidad&quot;, title = &quot;Bandas de predicción&quot;) En la figura siguiente se presentan los resultados obtenidos donde se aprecia cierta curvatura en las bandas de predicción debida al cambio en la escala de la raíz cuadrada a la escala original de la variable. 9.7 Ejercicios modelos ANCOVA A continuación se presenta la colección de ejercicios de esta unidad. Ejercicio 1. Disponemos de los datos de peso de 24 niños recién nacidos (peso), su sexo (sexo; “H” = Hombres y “M” = Mujeres) y la edad de sus madres (edad). Nos gustaría ser capaces de determinar un modelo que explique el peso de los niños recién nacidos en función de su sexo y de la edad de sus madres. # Lectura de datos edad &lt;- c(40, 38, 40, 35, 36, 37, 41, 40, 37, 38, 40, 38, 40, 36, 40, 38, 42, 39, 40, 37, 36, 38, 39, 40) peso &lt;- c(2968, 2795, 3163, 2925, 2625, 2847, 3292, 3473, 2628, 3176, 3421, 2975, 3317, 2729, 2935, 2754, 3210, 2817, 3126, 2539, 2412, 2991, 2875, 3231) sexo &lt;- gl(2,12, labels=c(&quot;H&quot;, &quot;M&quot;)) ejer01 &lt;- data.frame(edad, peso, sexo) Ejercicio 2. Se lleva a cabo una investigación sobre diversas malformaciones del sistema nervioso central registradas en nacidos vivos en Gales del Sur, Reino Unido. El estudio fue diseñado para determinar el efecto de la dureza del agua sobre la incidencia de tales malformaciones. La información registrada son: NoCNS = recuento de nacimientos sin problema CNS; An = conteo de nacimientos de Anencephalus; Sp = conteo de nacimientos de espina bífida; Otro = recuento de otros nacimientos del SNC; Agua = endurecimiento del agua; Trabajo = un factor con niveles Manual no manual en función del tipo de trabajo realizado por los padres Se está interesado en predecir el número total de malformaciones en función de la calidad del agua y el trabajo realizado por los padres. # Lectura de datos previo &lt;- read_csv(&quot;https://goo.gl/bNOSxt&quot;, col_types = &quot;cdddddc&quot;) # Calculamos el número total de malformaciones ejer02 &lt;- previo %&gt;% mutate(CNS = An + Sp + Other) Ejercicio 3. Se ha realizado un estudio para establecer la calidad de los vinos de la variedad Pino Noir en función de un conjunto de características analizadas. Las características analizadas son claridad, aroma, cuerpo, olor y matiz. Para medir la calidad se organiza una cata ciega a un conjunto de expertos y se calcula la puntuación final de cada vino a partir de la información de todos ellos. Además se registra la región (region) de procedencia del vino por si puede influir en la calidad del vino. # Lectura de datos ejer03 &lt;- read_csv(&quot;https://goo.gl/OX9wgM&quot;, col_types = &quot;ddddddc&quot;) Ejercicio 4. Una empresa recibe cargamentos de material para procesar en sus almacenes. El objetivo básico del estudio es determinar el tiempo de procesado de los cargamentos recibidos como función del tamaño del cargamento y el tipo de almacén. # Carga de datos ejer04 &lt;- read.table(&quot;https://goo.gl/kuMNpD&quot;, header = TRUE) ejer04 &lt;- as_tibble(ejer04) Ejercicio 5. Una empresa dedicada a la fabricación de aislantes térmicos y acústicos establece un experimento que mide la pérdida de calor (Calor) a través de cuatro tipos diferentes de cristal para ventanas (Cristal) utilizando cinco graduaciones diferentes de temperatura exterior (TempExt). Se prueban tres hojas de cristal en cada graduación de temperatura, y se registra la pérdida de calor para cada hoja. # Lectura de datos ejer05 &lt;- read_csv(&quot;https://goo.gl/V6hyVW&quot;, col_types = &quot;ddc&quot;) ejer05 &lt;- ejer05 %&gt;% mutate_if(sapply(ejer05,is.character),as.factor) Ejercicio 6. El grupo de asesores LearnStatistics ha realizado un estudio para comprobar si las empresas destinan parte de los beneficios de sus ventas en la formación de sus empleados para mejorar su competitividad. Para ellos se recoge la información sobre ventas (Ventas) en miles de euros, capital invertido en formación (Capital) en miles de euros, y el nivel de productividad de la empresa establecido por un asesor externo (Productividad). # Lectura de datos ejer06 &lt;- read_csv(&quot;https://bit.ly/2rCATaO&quot;, col_types = &quot;dcd&quot;) ejer06 &lt;- ejer06 %&gt;% mutate_if(sapply(ejer06,is.character),as.factor) "],["smooth.html", "Unidad 10 Modelos aditivos lineales 10.1 Bancos de datos 10.2 Funciones de suavizado 10.3 Bondad del ajuste y selección del modelo 10.4 Diagnóstico 10.5 Predicción 10.6 Ejercicios", " Unidad 10 Modelos aditivos lineales En esta unidad se presentan los modelos aditivos lineales. Esto modelos surgen cuando la relación entre la predictora y la respuesta (en el caso de variables numéricas) no se puede escribir de forma lineal, sino más bien a través de una función desconocida. En unidades anteriores utilizamos los modelos polinómicos para poder capturar comportamientos no lineales entre predictora y respuesta, pero en este caso utilizaremos funciones de suavizado que permiten capturar todo tipo de comportamiento entre ambas. La mayor dificultad en este tipo de modelos es que no tenemos una forma explícita para la función de suavizado, y por tanto es necesario utilizar las funciones específicas de predicción proporcionadas por la librería de ajuste para obtener el modelo resultante. En este tema sólo se pretende dar una versión introductoria de los modelos de suavizado por o que se recomienda la lectura de textos más avanzados para completar lo visto en esta unidad. El modelo aditivo más básico con una variable predictora y una respuesta Normal viene dado por: \\[Y = f(X) + \\epsilon\\] donde \\(f()\\) se denomina función suave o de suavizado para la variable \\(X\\). Las ventajas de este tipo de modelos es que son muy flexibles ya que permiten modelizar, a través de dichas funciones suaves, relaciones de tipo no lineal entre la variable respuesta y las predictoras. Sin embargo, no todo son ventajas ya que el proceso de selección del mejor modelo se complica al añadir la elección de la función de suavizado a utilizar. En situaciones con dos variables predictoras, \\(X_1\\) y \\(X_2\\), de tipo numérico se podrían plantear los modelos saturados siguientes: \\[ \\begin{array}{ll} M0: &amp; Y \\sim X_1 + X_2\\\\ M1: &amp; Y \\sim f(X_1) + X_2\\\\ M2: &amp; Y \\sim f(X_1) + f(X_2)\\\\ \\end{array} \\] También resulta posible plantear este tipo de modelos donde se incluyen variables predictoras de tipo factor. En este caso debemos plantear una ecuación de suavizado para cada uno de los grupos determinados por el factor al igual que ocurría con el efecto de interacción en los modelos ANCOVA. Para modelizar este tipo de datos es necesario instalar y cargar la librería mgcv. 10.1 Bancos de datos Veamos los diferentes ejemplos con los que vamos a trabajar. Muchos de ellos ya los hemos utilizado en modelos anteriores. Ejemplo 1. Datos de calidad del aire. Este diseño experimental contiene la información recogida sobre el estudio de calidad del aire que ya presentamos en la Unidad 2. El objetivo de este estudio era tratar de predecir la calidad del aire, medida en términos del nivel de ozono (Ozone), en función de la radiación solar (Solar.R), velocidad del viento (Wind), y temperatura (Temp). Además, se recogen las variables mes (Month) y día (Day) de la recogida de datos. En base a las variables experimentales recogidas cabría pensar que un modelo de regresión lineal múltiple de la forma \\[Ozone \\sim Solar.R + Wind + Temp\\] A continuación, se presenta el código para la carga de datos y el gráfico de la respuesta versus cada predictora. En la figura se pueden ver los modelos lineales ajustados, y la aparente falta de ajuste de estos. Tan solo la relación entre Ozono y Wind parece de tipo lineal, mientras que en los otros dos parece necesario realizar algún tipo de transformación para linealizar la relación. Podemos intentar encontrar dicha transformación de respuesta o predictoras pero podemos ver que los métodos de suavizado nos proporcionan una solución rápida a esta situación sin necesidad de perder el tiempo buscando transformaciones adecuadas. # Carga de datos data(&quot;airquality&quot;) # Seleccionamos variables de interés datos &lt;- airquality[,c(&quot;Ozone&quot;, &quot;Solar.R&quot;, &quot;Wind&quot;, &quot;Temp&quot;)] datacomp = melt(datos, id.vars=&#39;Ozone&#39;) # Representamos respuesta vs predictoras ggplot(datacomp) + geom_jitter(aes(value,Ozone, colour=variable),) + facet_wrap(~variable, scales=&quot;free_x&quot;) + labs(x = &quot;&quot;, y = &quot;Ozono&quot;) Como veremos más adelante la solución en términos de modelo de suavizado se puede apreciar en el gráfico siguiente: ggplot(datacomp) + geom_jitter(aes(value,Ozone, colour=variable),) + geom_smooth(aes(value,Ozone, colour=variable), method=loess, se=FALSE) + facet_wrap(~variable, scales=&quot;free_x&quot;) + labs(x = &quot;&quot;, y = &quot;Ozono&quot;) donde podemos ver el cambio en la asociación entre las diferentes predictoras y el nivel de ozono. Las tendencias de suavizado obtenidas reflejan el comportamiento a gran escala de la predictora versus cada respuesta. ¿Qué conclusiones podemos extraer de cada uno de los suavizados obtenidos? Ejemplo 2. Datos de producción. Se realiza un ensayo agrícola para estudiar la producción de cierto tipo de planta en dos localidades en función de la densidad de plantas en la parcela de producción. Las variables recogidas en el experimento son la densidad de plantas (Densidad), la producción global obtenida (Produccion), y la localidad donde se encuentra la parcela de producción (Localidad). El banco de datos obtenido se presenta a continuación: Densidad &lt;- c(23.48, 26.22, 27.79, 32.88, 33.27, 36.79, 37.58, 37.58, 41.49, 42.66, 44.23, 44.23, 51.67, 55.58, 55.58, 57.93, 58.71, 59.5, 60.67, 62.63, 67.71, 70.06, 70.45, 73.98, 73.98, 78.67, 95.9, 96.68, 96.68,101.38, 103.72, 104.51, 105.68, 108.03,117.82, 127.21, 134.26, 137.39, 151.87, 163.61, 166.35, 184.75, 18.78, 21.25, 23.23, 27.18, 30.15, 31.63, 32.12, 32.62, 32.62, 33.61, 37.07, 38.55, 39.54, 39.54, 41.02, 42.5, 43.98, 45.47, 49.92, 50.9, 53.87, 57.82, 61.78, 61.78, 63.75, 67.71, 71.66, 77.59, 80.56, 86.49, 88.46, 89.45, 90.93, 92.91, 101.81, 103.78, 115.15, 123.06, 144.31, 155.68, 158.15, 180.39) Produccion &lt;- c(5.41, 5.46, 5.4, 5.4, 5.29, 5.25, 5.35, 5.25, 5.05, 5.12, 5.29, 5.04, 5.03, 4.96, 4.84, 5.12, 4.97, 5.02, 4.87, 4.83, 4.74, 4.76, 4.79, 4.9, 4.74, 4.51, 4.62, 4.58, 4.62, 4.58, 4.47, 4.4, 4.34, 4.47, 4.44, 4.24, 4.17, 4.2, 4.14, 4.02, 4.14, 4, 5.61, 5.46, 5.2, 5.18, 4.95, 5.13, 4.93, 5.15, 4.72, 5.05, 4.92, 5.04, 4.82, 4.99, 4.66, 4.94, 5, 4.7, 4.51, 4.63, 4.68, 4.53, 4.57, 4.55, 4.6, 4.54, 4.5, 4.24, 4.3, 4.32, 4.29, 4.38, 4.37, 4.26, 4.11, 4.31, 3.9, 4.04, 3.87, 3.69, 3.66, 3.37) Localidad &lt;- as.factor(c(rep(&quot;A&quot;, 42), rep(&quot;B&quot;, 42))) plantas &lt;- data.frame(Densidad, Produccion, Localidad) A la vista de la información recogida se podría plantear un modelo ANCOVA, por lo que realizamos un gráfico de dispersión identificando cada punto según la localidad de procedencia. ggplot(plantas, aes(x = Densidad, y = Produccion, colour = Localidad)) + geom_point() + labs(x = &quot;Densidad&quot;, y = &quot;Producción&quot;) Se puede ver como la producción en la localidad A queda por encima de la de la localidad B, con un descenso asociado con el aumento de la densidad de plantas. La única diferencia con los modelos ANCOVA clásicos es que el descenso no parece ajustarse a un modelo lineal, sino más bien a un modelo con una caída curvilínea. Aunque existe la posibilidad de plantear una transformación de la respuesta y/o predictora, o incluso un modelo polinómico, resulta difícil plantear un modelo tan rígido dado que ambas localidades parecen comportarse de forma distinta. Vemos el resultado del modelo de suavizado (asumiendo que cada localidad puede tener un comportamiento distinto) El gráfico muestra las tendencias ajustadas para cada localidad reflejando una curva distinta para cada localidad, lo que permite obtener un modelo muy flexible que se adapta al comportamiento global de la producción versus la densidad de plantas en función de la localidad de procedencia. Más tarde presentaremos todas las posibilidades de modelización para este conjunto de datos. Ejemplo 3. Datos de infiltración. Se conoce como infiltración el proceso por el cual el agua (riego o lluvia) se va introduciendo bajo la superficie de un terreno cultivado. Este proceso es vital para determinar las cantidades de agua de riego necesarias, para mantener el terreno en condiciones óptimas. Un parámetro habitual que sirve para estudiar dicho proceso es la carga hidráulica. Este depende tanto de la profundidad de la infiltración (profundidad) como del procedimiento de riego usado. Se diseña un experimento para estudiar la carga hidráulica (cargahid) de un terreno bajo diferentes condiciones de riego (denominados tratamiento). Los datos recogidos en el experimento se presentan a continuación: tratamiento &lt;- as.factor(c(rep(&quot;A&quot;, 15), rep(&quot;B&quot;, 15), rep(&quot;C&quot;, 15))) profundidad &lt;-c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150) cargahid &lt;- c(-406.90, -345.70, -335.50, -315.10, -304.90, -315.10, -323.26, -335.50, -345.70, -362.02, -374.26, -386.50, -421.18, -435.46, -447.70, -896.50, -737.38, -653.74, -470.14, -406.90, -388.54, -396.70, -396.70, -396.70, -406.90, -419.14, -437.50, -468.10, -466.06, -492.58, -896.50, -855.70, -818.98, -788.38, -678.22, -590.50, -545.62, -515.02, -498.70, -496.66, -517.06, -555.82, -619.06, -623.14, -623.14) infiltracion &lt;- data.frame(tratamiento, profundidad, cargahid) Representamos los datos mediante un gráfico de dispersión identificando cada uno de los tratamientos: ggplot(infiltracion, aes(x = profundidad, y = cargahid, colour = tratamiento)) + geom_point() + labs(x = &quot;Profundidad&quot;, y = &quot;Carga Hidráulica&quot;) En este caso las tendencias observadas son bastante diferentes entre tratamientos y claramente no lineales. Un posible modelo de suavizado para este conjunto de datos vendría dado por: En este caso los ajustes de suavizado se asemejan a modelos polinómicos de grado 3 o 4, de forma que se podrían plantear ambas modelizaciones y compararlas para determinar el modelo que mejor ajusta la tendencia observada en los datos. 10.2 Funciones de suavizado Las funciones de suavizado son los denominados splines que consisten en funciones definidas sobre bases de polinomios. En nuestro caso utilizaremos los denominados splines penalizados o p-splines. Para el ajuste de este tipo de mosdelos utilizaremos la función gam de la libreria mgcv. La función de suavizado tiene la estructura siguiente: \\[s(variable, k = , m = , bs = , by = factor)\\] donde \\(k\\) es el tamaño de la base de polinomios, \\(m\\) es el orden de los polinomios, \\(bs\\) es el tipo de la base de splines utilizados y \\(by\\) identifica un factor para el ajuste de las curvas de suavizado (efecto de interacción). 10.2.1 Splines de regresión Las funciones de suavizado con las que se empieza a trabajar asumen que la función de suavizado \\(f(X)\\) se puede escribir como: \\[ f(X) = \\sum_{i=1}^q \\beta_j b_j(X) \\] siendo \\(\\beta_j\\) parámetros desconocidos y \\(b_1(X),\\ldots,b_q(X)\\) una base de funciones de polinomios de dimensión \\(q\\) (modelo polinómico de orden \\(q\\)), de forma que el modelo lineal para la respuesta \\(Y\\) se podría expresar como: \\[ y_i = \\beta_0 + \\beta_1 x_i + \\beta_2 x_i^2 + \\ldots + \\beta_q x_i^q + \\epsilon_i, \\quad i=1,...,n \\] El problema principal con esta propuesta es que la base de polinomios nos llevaría a modelos donde aparecían problemas de multicolinealidad, y que exigen un grado bastante alto para poder adaptarse a los cambios entre respuesta y predictora. Una generalización de estos modelos son los denominados “splines de regresión” que son curvas definidas a trozos mediante polinomios, es decir, dividimos el rango de \\(X\\) en trozos y sobre cada trozo ajustamos un modelo polinómico con la única restricción que loas funciones obtenidas en cada trozo deben unirse formando una curva suave. La ventaja principal es que podemos ajustar utilizando polinomios de grado bajo en cada trozo, consiguiendo representar curvas con formas complicadas, evitando grandes oscilaciones en la tendencia que aparecen cuando utilizamos polinomios de grados muy altos. La desventaja principal es que debemos elegir el número de trozos o knots y el orden de la base de polinomios que debemos utilizar. 10.2.2 Splines cúbicos Un “spline cúbico” es una curva construida a partir de trozos de polinomios de grado 3 que se ensamblan perfectamente de forma que la curva que forma es continua hasta la segunda derivada. Son los más utilizados dentro de los splines de regresión porque utilizan polinomios muy sencillos que se adaptan perfectamente a cambios en el comportamiento entre respuesta y predictora en los diferentes trozos en que se divide el rango de \\(X\\). 10.2.3 Splines penalizados La elección del grado de suavización de la función que ajusta la tendencia entre respuesta y predictora es un tema muy importante, y está asociado al grado de la base de polinomios utilizada. Las posibilidades que tenemos a la hora de elegir el grado de suavizado pasan por utilizar los denominados “splines penalizados” que son splines de regresión en los que se introduce una penalización al realizar el ajuste del modelo. Dicha penalización viene controlada por el parámetro de suavizado \\(\\lambda\\). Si \\(\\lambda = 0\\) estamos en el caso particular en el que no hay penalización y a medida que \\(\\lambda\\) aumenta, aumentamos la intensidad de la penalización. Cuando\\(\\lambda\\) tiende a 1 el modelo se convierte prácticamente en un modelo de regresión lineal simple. Se recomienda la lectura de la bibliografía recomendada para completar la información sobre el parámetro de suavizado y la penalización utilizada. Para ajustar este tipo de modelos en R utilizaremos la función anterior donde se toman valores: \\(k = 10\\) cuando nuestra muestra es pequeña y \\(k = 20\\) cuando nuestra muestra es grande (aunque se puede variar en función de los datos analizados). \\(m = 2\\) como el orden de los polinomios. Se toma como base de splines los splines penalizados (\\(bs = ps\\)). 10.3 Bondad del ajuste y selección del modelo La bondad del ajuste de este tipo de modelos se basa en los estadísticos AIC y GCV. El segundo de estos es específico de este tipo de modelos ya que se utiliza para estimar la curva de suavizado asociada con la variable predictora. En ambos casos cuanto menor es el valor mejor será el modelo obtenido. En la mayoría de situaciones se utilizan ambos criterios para comparar el modelo lineal con el suavizado y determinar cual es el mejor de los dos. Para este tipo de modelos se puede obtener además la capacidad explicativa del modelo construido a través de la desvianza explicada, que representa el porcentaje de variabilidad de la respuesta que viene explicada por el modelo, de forma similar al \\(R^2\\) en los modelos de regresión. En cuanto a la selección del modelo, la principal diferencia con respecto a los modelos tratados hasta ahora es que no existen procedimientos automáticos, con lo que la construcción y validación de los modelos requiere la construcción de todos los que consideremos que pueden ser adecuados. Las posibilidades más habituales de modelización y comparación consisten en: Comparar diferentes tipos de modelos lineales (RLS, RLM, o MP) con el modelo suavizado. Comparar las componentes del modelo aditivo, es decir, comprobar si podemos eliminar algunos de los efectos presentes en el modelo. En este sentido, cuando tenemos más de dos variables predictoras se pueden trabajar con todos los modelos que presentamos al inicio de esta unidad. Para la selección del mejor modelo se usan como referencia el AIC. El criterio basado en GCV se utiliza para seleccionar la función de suavizado (en cuanto a los parámetros que se usan para su construcción). Pasamos a realizar un análisis completo de los tres ejemplos presentados al inicio de la unidad. En este tipo de modelos utilizaremos la función summary en lugar de tab_model para obtener la información del modelo ajustado. Ejemplo. Estudaimos las diferentes posibilidades de modelización para el banco de datos de calidad del aire. Para construir el mejor modelo para este banco de datos vamos a proceder ajustando individualmente cada posible predictora para proceder posteriormente con modelos más complejos. Para cada modelo individual probaremos un modelo polinómico (MP) de orden 3 (para poder captar los cambios de tendencia) y el correspondiente modelo de suavizado. Los ajustaremos todos y valoraremos la capacidad explicativa de cada uno. Se proponen los modelos siguientes para la asociación entre calidad del aire y la radiación solar: \\[ \\begin{array}{ll} Ozone &amp; \\sim Solar.R + Solar.R^2 + Solar.R^3\\\\ Ozone &amp; \\sim f(Solar.R)\\\\ \\end{array} \\] con \\(f()\\) una función de suavidado basada en p-splines penalizdos con \\(k = 10\\) nodos y polinomios de orden \\(2\\). Realizamos el ajuste de ambos modelos utilizando la función gam(), y comparamos ambos modelos con el estadístico AIC. # M1: modelo polinómico fit1.solarr &lt;- gam(Ozone ~ Solar.R + I(Solar.R^2) + I(Solar.R^3) , data = airquality) # M1: modelo suavizado fit2.solarr &lt;- gam(Ozone ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) Resultados para el modelo polinómico summary(fit1.solarr) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ Solar.R + I(Solar.R^2) + I(Solar.R^3) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.432e+01 1.244e+01 1.151 0.2522 ## Solar.R -1.245e-01 3.265e-01 -0.381 0.7038 ## I(Solar.R^2) 3.594e-03 2.212e-03 1.625 0.1072 ## I(Solar.R^3) -9.661e-06 4.292e-06 -2.251 0.0264 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## R-sq.(adj) = 0.225 Deviance explained = 24.6% ## GCV = 890.23 Scale est. = 858.15 n = 111 La tabla de coeficientes muestra que el grado 3 del polinomio es necesario (p-valor asociado significativo), aunque la capacidad explicativa (Deviance explained) es muy baja (24.6%). En cuanto al modelo suavizado tendríamos: summary(fit2.solarr) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 42.099 2.783 15.13 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Solar.R) 2.943 3.569 9.074 9.74e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.224 Deviance explained = 24.4% ## GCV = 891.28 Scale est. = 859.62 n = 111 La función de suavizado es relevante (p-valor de s(Solar.R) significativo), pero la capacidad explicativa también es muy baja (24.6%), aunque del mismo orden que la obtenida con el modelo polinómico. Realizamos la comparación de ambos modelos mediante AIC: # Bondad de ajuste de cada modelo (AIC) g1 &lt;- glance(fit1.solarr) g2 &lt;- glance(fit2.solarr) as_tibble(rbind(g1, g2)) Tabla 10.1: dflogLikAICBICdeviancedf.residualnobs 4&nbsp;&nbsp;&nbsp;-5301.07e+031.08e+039.18e+04107111 3.94-5301.07e+031.08e+039.2e+04&nbsp;107111 Ambos modelos tienen un AIC del mismo orden por lo que resulta difícil establecer cual de ellos resultaría más conveniente. Veamos gráficamente los ajustes obtenidos donde se aprecia el comportamiento de ambos modelos. ## $Solar.R ## $Solar.R Analizamos ahora el efecto de la velocidad del viento en el nivel de ozono. Se proponen los modelos siguientes: \\[ \\begin{array}{ll} Ozone &amp; \\sim Wind + Wind^2 + Wind^3\\\\ Ozone &amp; \\sim f(Wind)\\\\ \\end{array} \\] Ajustamos ambos modelos # M1: modelo polinómico fit1.wind &lt;- gam(Ozone ~ Wind + I(Wind^2) + I(Wind^3) , data = airquality) # M1: modelo suavizado fit2.wind &lt;- gam(Ozone ~ s(Wind, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) Resultados para el modelo polinómico summary(fit1.wind) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ Wind + I(Wind^2) + I(Wind^3) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 200.28778 27.01403 7.414 2.5e-11 *** ## Wind -32.26471 8.29374 -3.890 0.00017 *** ## I(Wind^2) 1.92084 0.78733 2.440 0.01627 * ## I(Wind^3) -0.03771 0.02305 -1.636 0.10465 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## R-sq.(adj) = 0.484 Deviance explained = 49.8% ## GCV = 581.27 Scale est. = 561.23 n = 116 La tabla de coeficientes muestra que es suficiente con considera el grado 2 en el polinomio. La capacidad explicativa de este modelo se sitúa casi en el 50% (49.8%), indicando que individualmente está variable contribuye más a la explicación del nivel de ozono. En cuanto al modelo de suavizado: summary(fit2.wind) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ s(Wind, k = 10, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 42.129 2.193 19.21 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Wind) 2.889 3.534 30.77 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.487 Deviance explained = 50% ## GCV = 577.41 Scale est. = 558.05 n = 116 La función se suavizado es relevante (p-valor significativo), y la capacidad explicativa también es del 50%. Si comparamos con el AIC podemos ver que ambos modelos son muy similares. En realidad deberíamos ajustar de nuevo el modelo polinómico considerando el grado 2, pero los resultados son muy similares. # Bondad de ajuste de cada modelo (AIC) g1 &lt;- glance(fit1.wind) g2 &lt;- glance(fit2.wind) as_tibble(rbind(g1,g2)) Tabla 10.2: dflogLikAICBICdeviancedf.residualnobs 4&nbsp;&nbsp;&nbsp;-5301.07e+031.08e+036.29e+04112116 3.89-5291.07e+031.08e+036.26e+04112116 En cuanto a los ajustes obtenidos con cada modelo podemos ver lo que se parecen las dos soluciones propuestas. ## $Wind ## $Wind Analizamos ahora el efecto de la tempreratura sobre el nivel de ozono. Proponemos los modelos: \\[ \\begin{array}{ll} Ozone &amp; \\sim Temp + Temp^2 + Temp^3\\\\ Ozone &amp; \\sim f(Temp)\\\\ \\end{array} \\] Ajustamos ambos modelos # M1: modelo polinómico fit1.temp &lt;- gam(Ozone ~ Temp + I(Temp^2) + I(Temp^3) , data = airquality) # M1: modelo suavizado fit2.temp &lt;- gam(Ozone ~ s(Temp, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) Resultados para el modelo polinómico summary(fit1.temp) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ Temp + I(Temp^2) + I(Temp^3) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.0910285 0.0663384 1.372 0.1727 ## Temp 2.2972754 1.6743100 1.372 0.1728 ## I(Temp^2) -0.0732824 0.0430854 -1.701 0.0917 . ## I(Temp^3) 0.0006372 0.0002747 2.319 0.0222 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## ## Rank: 3/4 ## R-sq.(adj) = 0.533 Deviance explained = 54.1% ## GCV = 522.02 Scale est. = 508.52 n = 116 La tabla de coeficientes muestra que es necesario el grado 3 en el polinomio. La capacidad explicativa de este modelo se sitúa casi en 54.1% (la más alta de forma individual). En cuanto al modelo de suavizado: summary(fit2.temp) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ s(Temp, k = 10, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 42.129 2.043 20.62 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Temp) 3.771 4.524 32.04 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.555 Deviance explained = 57% ## GCV = 505.06 Scale est. = 484.29 n = 116 La función se suavizado es relevante (p-valor significativo), y la capacidad explicativa también es algo superior que en el modelo polinómico al alcanzar el 57%. En este caso el AIC para el modelo de suavizado es algo inferior al polinómico pero ambos proporcionan soluciones muy similares. # Bondad de ajuste de cada modelo (AIC) g1 &lt;- glance(fit1.temp) g2 &lt;- glance(fit2.temp) as_tibble(rbind(g1,g2)) Tabla 10.3: dflogLikAICBICdeviancedf.residualnobs 3&nbsp;&nbsp;&nbsp;-5251.06e+031.07e+035.75e+04113116 4.77-5211.05e+031.07e+035.39e+04111116 La solución con cada modelo es: ## $Temp ## $Temp A la vista de los análisis individuales las variables predictoras más relvantes por orden de importancia serían temperatura, velocidad del viento, y por último la radiación solar. En cuanto a la elección de modelos polinómicos o suavizados los resultados son muy similares en los tres casos ya que únicamente se observa cierta preferencia del suavizado con la variable temperatura. Pasamos a analizar los modelos más complejos con dos o tres predictoras. En primer lugar comparamos modelos con estructuras polinómicas frente a modelos de suavizado. Veamos todos los modelos: \\[ \\begin{array}{lll} M1:&amp; Ozone &amp; \\sim Solar.R + Solar.R^2 + Solar.R^3 + Wind + Wind^2\\\\ M2:&amp; Ozone &amp; \\sim Solar.R + Solar.R^2 + Solar.R^3 + Temp + Temp^2 + Temp^3\\\\ M3:&amp; Ozone &amp; \\sim Wind + Wind^2 + Temp + Temp^2 + Temp^3\\\\ M4:&amp; Ozone &amp; \\sim Solar.R + Solar.R^2 + Solar.R^3 + Wind + Wind^2 + Temp + Temp^2 + Temp^3\\\\ M5:&amp; Ozone &amp; \\sim f(Solar.R) + f(Wind)\\\\ M6:&amp; Ozone &amp; \\sim f(Solar.R) + f(Temp)\\\\ M7:&amp; Ozone &amp; \\sim f(Wind) + f(Temp)\\\\ M8:&amp; Ozone &amp; \\sim f(Solar.R) + f(Wind) + f(Temp)\\\\ \\end{array} \\] En primer lugar ajustamos todos los modelos (con el indicador de la tabla anterior): fit.M1 &lt;- gam(Ozone ~ Solar.R + I(Solar.R^2) + I(Solar.R^3) + Wind +I(Wind^2), data = airquality) fit.M2 &lt;- gam(Ozone ~ Solar.R + I(Solar.R^2) + I(Solar.R^3) + Temp +I(Temp^2) + I(Temp^3), data = airquality) fit.M3 &lt;- gam(Ozone ~ Wind +I(Wind^2) + Temp +I(Temp^2) + I(Temp^3), data = airquality) fit.M4 &lt;- gam(Ozone ~ Solar.R + I(Solar.R^2) + I(Solar.R^3) + Wind +I(Wind^2) + Temp +I(Temp^2) + I(Temp^3), data = airquality) fit.M5 &lt;- gam(Ozone ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) + s(Wind, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) fit.M6 &lt;- gam(Ozone ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) fit.M7 &lt;- gam(Ozone ~ s(Wind, k = 10, m = 2, bs = &quot;ps&quot;) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) fit.M8 &lt;- gam(Ozone ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) + s(Wind, k = 10, m = 2, bs = &quot;ps&quot;) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) En lugar de estudiar con detalle todos los modelos propuestos, utilizamos el AIC para ordenarlos (de mejor a peor) y analizamos los dos más relevantes. # Bondad de ajuste de cada modelo (AIC) g1 &lt;- glance(fit.M1) g2 &lt;- glance(fit.M2) g3 &lt;- glance(fit.M3) g4 &lt;- glance(fit.M4) g5 &lt;- glance(fit.M5) g6 &lt;- glance(fit.M6) g7 &lt;- glance(fit.M7) g8 &lt;- glance(fit.M8) as_tibble(rbind(g1, g2, g3, g4, g5, g6, g7, g8)) Tabla 10.4: dflogLikAICBICdeviancedf.residualnobs 5&nbsp;&nbsp;&nbsp;-5231.06e+031.07e+037.99e+04106111 6&nbsp;&nbsp;&nbsp;-4971.01e+031.03e+035.03e+04105111 5&nbsp;&nbsp;&nbsp;-5061.02e+031.04e+034.19e+04111116 8&nbsp;&nbsp;&nbsp;-477971&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;996&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.49e+04103111 6.06-4951e+03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.02e+034.82e+04105111 7.51-4931e+03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.03e+034.67e+04103111 7.69-5011.02e+031.04e+033.8e+04&nbsp;108116 9.97-470963&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;992&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12e+04101111 Los dos mejores modelos (menor valor del AIC) son el M4 y el M8 que corresponden con los modelos que incorporan las tres predictoras. El M4 expresado como modelo polinómico y el M8 como modelo aditivo. De hecho, el modelo aditivo con las tres predictoras es el mejor de todos. Dado que individualmente tanto para la variable Solar.R y Wind el modelo polinómico se comportaba al mismo nivel que el suavizado, se propone una última alternativa de modelización que consiste en asumir polinomios en estas dos variables y suavizado en Temp: \\[ \\begin{array}{lll} M9:&amp; Ozone &amp; \\sim Solar.R + Solar.R^2 + Solar.R^3 + Wind + Wind^2 + f(Temp)\\\\ \\end{array} \\] fit.M9 &lt;- gam(Ozone ~ Solar.R + I(Solar.R^2) + I(Solar.R^3) + Wind +I(Wind^2) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) En lugar de estudiar con detalle todos los modelos propuestos, utilizamos el AIC para ordenarlos (de mejor a peor) y analizamos los dos más relevantes. # Bondad de ajuste de cada modelo (AIC) glance(fit.M9) Tabla 10.5: dflogLikAICBICdeviancedf.residualnobs 8.3-4951.01e+031.03e+034.83e+04103111 El AIC para este modelo es superior al obtenido para los modelos M4 y M8, de forma que el modelo preferido sería el M8. En primer lugar estudiamos el modelo obtenido: summary(fit.M8) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) + s(Wind, k = 10, ## m = 2, bs = &quot;ps&quot;) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 42.099 1.667 25.25 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Solar.R) 2.622 3.209 4.142 0.00672 ** ## s(Wind) 2.747 3.374 14.773 &lt; 2e-16 *** ## s(Temp) 3.600 4.327 12.738 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.721 Deviance explained = 74.4% ## GCV = 339.03 Scale est. = 308.58 n = 111 Los tres suavizados resultan significativos y la capacidad explicativa del modelo alcanza el 74.4%. Como alternativa a este modelo podríamos considerar modelos aditivos donde aumentamos el número de nodos. Probamos este nuevo modelo duplicando el número de nodos (pasamos de 10 a 20). En este caso dado que se trata de comparar diferentes opciones de suavizado utilizaremos el criterio GCV para decidirnos entre los dos. fit.M10 &lt;- gam(Ozone ~ s(Solar.R, k = 20, m = 2, bs = &quot;ps&quot;) + s(Wind, k = 20, m = 2, bs = &quot;ps&quot;) + s(Temp, k = 20, m = 2, bs = &quot;ps&quot;), data = airquality) summary(fit.M10) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Ozone ~ s(Solar.R, k = 20, m = 2, bs = &quot;ps&quot;) + s(Wind, k = 20, ## m = 2, bs = &quot;ps&quot;) + s(Temp, k = 20, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 42.099 1.445 29.13 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Solar.R) 1.068 1.132 10.118 0.00175 ** ## s(Wind) 3.588 4.416 20.900 &lt; 2e-16 *** ## s(Temp) 16.392 17.430 7.082 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.791 Deviance explained = 83.1% ## GCV = 289.38 Scale est. = 231.9 n = 111 El valor de GCV con 10 nodos es 339.03 mientras que con 20 nodos dicho estadístico es 289.38. Por tanto, el modelo con 20 nodos es preferido. De hecho, la capacidad explicada ha crecido hasta el 83.1% (un 10% superior). El valor de AIC para este modelo es 941 mostrando ser mejor que el modelo polinómico. El modelo final es un suavizado independiente para cada una de las predictoras consideradas. Ejemplo. Analizamos ahora el banco de datos de producción. La estructura de este banco de datos nos hace pensar que un modelo ANCOVA podría ser adecuado pero el gráfico descriptivo no deja muy claro si el comportamiento es de tipo lineal o si hay que considerar efectos de interacción entre localidad y densidad de plantas de tipo no lineal. ggplot(plantas, aes(x = Densidad, y = Produccion, colour = Localidad)) + geom_point() + labs(x = &quot;Densidad&quot;, y = &quot;Producción&quot;) El conjunto de modelos que se pueden plantear son: M1: Modelo lineal sin efecto de interacción. M2: Modelo lineal sin efecto de interacción. M3: Modelo polinómico de grado 2 sin interacción. M4: Modelo polinómico de grado 2 con interacción. M5: Modelo suavizado sin interacción. M6: Modelo suavizado con interacción. La representación gráfica de estos modelos se puede obteenr mediante: Veamos el código necesario para ajustar cada uno de los modelos propuestos y valoremos el AIC y el GCV para seleccionar el mejor modelo. fit.plantas.M1 &lt;- gam(Produccion ~ Localidad + Densidad, data = plantas) fit.plantas.M2 &lt;- gam(Produccion ~ Localidad * Densidad, data = plantas) fit.plantas.M3 &lt;- gam(Produccion ~ Localidad + Densidad + I(Densidad^2), data = plantas) fit.plantas.M4 &lt;- gam(Produccion ~ Localidad * (Densidad + I(Densidad^2)), data = plantas) fit.plantas.M5 &lt;- gam(Produccion ~ Localidad + s(Densidad, k = 10, m = 2, bs = &quot;ps&quot;), data = plantas) fit.plantas.M6 &lt;- gam(Produccion ~ Localidad + s(Densidad, k = 10, m = 2, bs = &quot;ps&quot;, by = Localidad), data = plantas) ### Valores de AIC rbind(glance(fit.plantas.M1),glance(fit.plantas.M2),glance(fit.plantas.M3), glance(fit.plantas.M4),glance(fit.plantas.M5),glance(fit.plantas.M6)) Tabla 10.6: dflogLikAICBICdeviancedf.residualnobs 3&nbsp;&nbsp;&nbsp;46.6-85.2-75.41.62&nbsp;81&nbsp;&nbsp;84 4&nbsp;&nbsp;&nbsp;49.5-89&nbsp;&nbsp;-76.91.51&nbsp;80&nbsp;&nbsp;84 4&nbsp;&nbsp;&nbsp;63.7-117&nbsp;&nbsp;-105&nbsp;&nbsp;1.08&nbsp;80&nbsp;&nbsp;84 6&nbsp;&nbsp;&nbsp;66&nbsp;&nbsp;-118&nbsp;&nbsp;-101&nbsp;&nbsp;1.02&nbsp;78&nbsp;&nbsp;84 6.3470.9-127&nbsp;&nbsp;-109&nbsp;&nbsp;0.90977.784 9.0977&nbsp;&nbsp;-134&nbsp;&nbsp;-109&nbsp;&nbsp;0.78674.984 ### Valores de GCV cbind(fit.plantas.M1$gcv.ubre, fit.plantas.M2$gcv.ubre, fit.plantas.M3$gcv.ubre, fit.plantas.M4$gcv.ubre, fit.plantas.M5$gcv.ubre, fit.plantas.M6$gcv.ubre) ## [,1] [,2] [,3] [,4] [,5] [,6] ## GCV.Cp 0.02077199 0.01985587 0.01415785 0.01410118 0.01266822 0.01177339 Con ambos criterios de selección el modelo preferido es el M6, es decir, el modelo de suavizado con interacción con el factor localidad. Estudiamos con más detalle dicho modelo: summary(fit.plantas.M6) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## Produccion ~ Localidad + s(Densidad, k = 10, m = 2, bs = &quot;ps&quot;, ## by = Localidad) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.84394 0.01605 301.88 &lt;2e-16 *** ## LocalidadB -0.32929 0.02272 -14.49 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Densidad):LocalidadA 2.541 3.101 216.4 &lt;2e-16 *** ## s(Densidad):LocalidadB 4.550 5.333 165.3 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.951 Deviance explained = 95.6% ## GCV = 0.011773 Scale est. = 0.010499 n = 84 Todos los efectos del modelo resultan significativos y la capacidad explicativa alcanza el 95%, indicando que el modelo obtenido es muy adecuado para estudiar la producción en las dos localidades. Ejemplo. Análisis de los datos de infoltración. El gráfico descriptivo de este conjunto de datos muestra relaciones no lineales distintas entre carga hidráulica y profundidad en función del tratamiento, por lo que un modelo ANCOVA con interacción podría resultar demasiado rígido. Utilizamos un modelo suavizado para estos datos. fit.cargahid &lt;- gam(cargahid ~ tratamiento + s(profundidad, k = 10, m = 2, bs = &quot;ps&quot;, by = tratamiento), data = infiltracion) summary(fit.cargahid) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## cargahid ~ tratamiento + s(profundidad, k = 10, m = 2, bs = &quot;ps&quot;, ## by = tratamiento) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -363.652 3.238 -112.32 &lt;2e-16 *** ## tratamientoB -131.920 4.579 -28.81 &lt;2e-16 *** ## tratamientoC -277.848 4.579 -60.68 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(profundidad):tratamientoA 4.031 4.797 38.27 &lt;2e-16 *** ## s(profundidad):tratamientoB 7.224 7.928 248.40 &lt;2e-16 *** ## s(profundidad):tratamientoC 6.862 7.584 215.45 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.994 Deviance explained = 99.7% ## GCV = 296.27 Scale est. = 157.24 n = 45 Los suavizados para cada tratamiento resultan significativos y la capacidad explicativa alcanza el 99%, indicando que el modelo a parece capturar adecuadamente la tendencia observada en los datos. 10.4 Diagnóstico Una vez ajustado un modelo el estudio de los residuos nos permite realizar su diagnóstico en las mismas condiciones que los modelos lineales habituales. Las hipótesis de este modelo son las mismas que las del modelo de regresión, y por tanto, el diagnóstico se centra en los mismos procedimientos gráficos. Recordemos que debemos verificar la normalidad y varianza constante de los residuos del modelo. Sin embargo, en este tipo de modelos se añade el diagnóstico sobre el grado de suavizado del modelo considerado para saber si es necesario modificarlo. Para este tipo de modelos resulta posible obtener todos los gráficos de interés con la función gam.check(). Esta función ofrece dos tipos de salidas: Una tabla que permite contrastar los parámetros del suavizado utilizado. Los p-valores obtenidos deben resultar no significativos. gráficos de diagnóstico (qq, residuos versus ajustados, histograma de los residuos, valores observados versus valores ajustados). El gráfico qq y el histograma nos permiten verificar la hipótesis de normalidad, mientras que los residuos versus ajustados nos permite verificar la hipótesis de varianza constante. El último gráfico nos permite conocer lo bueno que es el ajuste realizado, ya que si los punto se distribuyen a lo largo de la diagonal significará que el modelo predice adecuadamente la respuesta. Ejemplo. Realizamos el diagnóstico el modelo ajustado para los datos de calidad del aire. gam.check(fit.M10) ## ## Method: GCV Optimizer: magic ## Smoothing parameter selection converged after 17 iterations. ## The RMS GCV score gradient at convergence was 5.831016e-05 . ## The Hessian was positive definite. ## Model rank = 58 / 58 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(Solar.R) 19.00 1.07 1.06 0.70 ## s(Wind) 19.00 3.59 1.22 0.99 ## s(Temp) 19.00 16.39 1.09 0.82 Los test de suavizado indican que el modelo es adecuado, pero mientras que los gráficos para validar normalidad parecen indicar que no hay problema con dicha hipótesis, si parece haberlo con la de homogeneidad de varianzas. Se aprecia un efecto de embudo (aumenta la variabilidad cuando aumenta el valor ajustado) en el gráfico de residuos versus ajustados. En este caso no podemos utilizar las transformaciones de Box-Cox que están diseñadas para los modelos estudiados en unidades anteriores, pero si podemos probar alguna transformación habitual para ver si corregimos ese defecto observado. Probamos con la raíz cuadrada. Dado que vamos a modificar la escala de la respuesta es necesario reajustar el número de nodos (ya que hemos comprimido la escala). Asumimos 10 nodos y verificamos dicho modelo. # Modelo fit.M11 &lt;- gam(sqrt(Ozone) ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) + s(Wind, k = 10, m = 2, bs = &quot;ps&quot;) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;), data = airquality) # Bondad del ajuste summary(fit.M11) ## ## Family: gaussian ## Link function: identity ## ## Formula: ## sqrt(Ozone) ~ s(Solar.R, k = 10, m = 2, bs = &quot;ps&quot;) + s(Wind, ## k = 10, m = 2, bs = &quot;ps&quot;) + s(Temp, k = 10, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 6.0165 0.1165 51.62 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df F p-value ## s(Solar.R) 2.145 2.655 7.684 0.000295 *** ## s(Wind) 2.461 3.049 12.871 5.32e-07 *** ## s(Temp) 3.862 4.622 15.929 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.747 Deviance explained = 76.6% ## GCV = 1.6482 Scale est. = 1.5076 n = 111 # Diagnóstico gam.check(fit.M11) ## ## Method: GCV Optimizer: magic ## Smoothing parameter selection converged after 7 iterations. ## The RMS GCV score gradient at convergence was 1.329944e-06 . ## The Hessian was positive definite. ## Model rank = 28 / 28 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(Solar.R) 9.00 2.15 0.97 0.34 ## s(Wind) 9.00 2.46 0.98 0.41 ## s(Temp) 9.00 3.86 0.84 0.04 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 El modelo ajustado resulta significativo con una capacidad explicativa del 76.6%. En cuanto a las hipótesis del modelo podemos ver como se ha corregido el efecto de embudo obteniendo un modelo que verifica las hipótesis de partida. Ejemplo. Realizamos el diagnóstico del modelo obtenido para los datos de producción. gam.check(fit.plantas.M6) ## ## Method: GCV Optimizer: magic ## Smoothing parameter selection converged after 5 iterations. ## The RMS GCV score gradient at convergence was 3.261881e-07 . ## The Hessian was positive definite. ## Model rank = 20 / 20 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(Densidad):LocalidadA 9.00 2.54 1.08 0.75 ## s(Densidad):LocalidadB 9.00 4.55 1.08 0.77 No se detecta ningún problema con las hipótesis del modelo y podemos pasar a establecer la predicción para el modelo ajustado. Ejemplo. Realizamos el diagnóstico del modelo para los datos de infiltración. gam.check(fit.cargahid) ## ## Method: GCV Optimizer: magic ## Smoothing parameter selection converged after 7 iterations by steepest ## descent step failure. ## The RMS GCV score gradient at convergence was 1.786612e-05 . ## The Hessian was positive definite. ## Model rank = 30 / 30 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(profundidad):tratamientoA 9.00 4.03 1.1 0.69 ## s(profundidad):tratamientoB 9.00 7.22 1.1 0.71 ## s(profundidad):tratamientoC 9.00 6.86 1.1 0.69 Todos los gráficos de diagnóstico parecen indicar que los residuos cumplen con las hipótesis del modelo (qq-plot, Resids vs linear pred., histogram of residuals, Response vs. ftted values). Por otro lado, el análisis del parámetro de suavizado indica que el ajuste obtenido es adecuado, no encontrando problemas importantes. 10.5 Predicción Una vez analizados y elegido el mejor modelo nos resta la fase de predicción. En este caso al no disponer de una función paramétrica que relaciona la respuesta con las predictoras no podemos obtener las ecauciones de predicción mediante una ecuación específica. Utilizamos las herramientas gráficas para ver los diferentes tipos de predicciones posibles. Ejemplo. Obtenemos la predicción para el modelo de calidad del aire. En primer lugar obtenemos las predicciones marginales asociadas a cada una de las predictoras presentes en el modelo. plot_model(fit.M11, &quot;pred&quot;, title =&quot;Predicción de la media de la raiz cuadarada de ozono&quot;) ## $Solar.R ## ## $Wind ## ## $Temp En estos gráficos podemos ver el efecto de cada predictora con respecto a la respuesta a partir del suavizado estimado. En ellos podemos ver: el nivel de ozono aumenta con la radiación solar (hasta el valor de 250 aproximadamente), y luego empieza a caer lentamente. El nivel de ozon disminuye con el aumento de la velocidad del viento hasta casi hacerse constante. El nivel de ozono se mantiene casi constante hasta una temperatura de 70, momento en el que empieza a crecer hasta la temperatura de 90, caundo comienza a ser casi constante de nuevo. Además, de los gráficos marginales podemos obtener gráficos conjuntos para dos variables sin más que estudiar los efectos combinados de ambas variables. En estos gráficos se crean escenarios con respecto a una de las variables numéricas (valor bajo, valor intermedio, y valor alto) y se representa la evolución de la otra predictora. plot_model(fit.M11, &quot;pred&quot;, terms = c(&quot;Solar.R&quot;, &quot;Wind&quot;), title =&quot;Predicción de la media de la raiz cuadarada de ozono&quot;) plot_model(fit.M11, &quot;pred&quot;, terms = c(&quot;Solar.R&quot;, &quot;Temp&quot;), title =&quot;Predicción de la media de la raiz cuadarada de ozono&quot;) plot_model(fit.M11, &quot;pred&quot;, terms = c(&quot;Wind&quot;, &quot;Temp&quot;), title =&quot;Predicción de la media de la raiz cuadarada de ozono&quot;) Podemos ver cada uno de los escenarios obtenidos lo que nos permite estudiar claramente el comportamiento de la respuesta. En realidad se reproducen los resultados independientes pero para diferentes valores (escenarios) de una de las predictoras numéricas consideradas. ¿Qué información obtenemos de dichos gráficos? Ejemplo. Para los datos de producciónos nos limitamos a representar gráficamente la predicción del modelo ajustado, junto con sus intervalos de confianza. Se puede ver como la producción disminuye conforme aumenta la densidad de plantas, siendo el comportamiento no lineal y distinto en cada localidad. De hecho, la producción siempre es inferior en la localidad B frente a la A en todo el rango de densidades de plantas. Ejemplo. Obtenemos y analizamos las funciones de predicción para los datos de infiltración. Los suavizados obtenidos se comportan adecuadamente al reproducir la tendencia observada. Se pueden ver las diferentes curvas de predicción en función del tratamiento utilizado. 10.6 Ejercicios En todos los ejercicios se debe proponer un modelo alterantivo basado en modelos de suavizado frente al modelo que sería de uso habitual. Se deberan comaparar ambos modelos para establecer si el modelo de suavizado es necesario. Ejercicio 1. Una empresa dedicada a la fabricación de aislantes térmicos y acústicos establece un experimento que mide la pérdida de calor (Calor) a través de cuatro tipos diferentes de cristal para ventanas (Cristal) utilizando cinco graduaciones diferentes de temperatura exterior (TempExt). Se prueban tres hojas de cristal en cada graduación de temperatura, y se registra la pérdida de calor para cada hoja. # Lectura de datos ejer01 &lt;- read_csv(&quot;https://goo.gl/V6hyVW&quot;, col_types = &quot;ddc&quot;) ejer01 &lt;- ejer01 %&gt;% mutate_if(sapply(ejer05,is.character),as.factor) Ejercicio 2. Treinta aleaciones del tipo 90/10 Cu-Ni, cada una con un contenido específico de hierro son estudiadas bajo un proceso de corrosión. Tras un período de 60 días se obtiene la pérdida de peso (en miligramos al cuadrado por decímetro y día) de cada una de las aleaciones debido al proceso de corrosión. El objetivo es estudiar el nivel de corrosión en función del contenido de hierro. A continuación se presenta el banco de datos y se realiza la primera inspección gráfica. hierro &lt;- c(0.01, 0.48, 0.71, 0.95, 1.19, 0.01, 0.48, 1.44, 0.71, 1.96, 0.01, 1.44, 1.96) peso &lt;- c(127.6, 124, 110.8, 103.9, 101.5, 130.1, 122, 92.3, 113.1, 83.7, 128, 91.4, 86.2) ejer02 &lt;- data.frame(hierro,peso) Ejercicio 3. Se ha realizado un experimento para tratar de conocer la viscosidad de cierto compuesto en función de la cantidad de un tipo der aceite que se usa en su fabricación. Se asume una relación de tipo lineal entre la viscosidad y la cantidad de aceite utilizada. aceite &lt;- c(0, 12, 24, 36, 48, 60, 0, 12, 24, 36, 48, 60, 0, 12, 24, 36, 48, 60, 12, 24, 36, 48, 60) viscosidad &lt;- c(26, 38, 50, 76, 108, 157, 17, 26, 37, 53, 83, 124, 13, 20, 27, 37, 57, 87, 15, 22, 27, 41, 63) ejer03 &lt;- data.frame(aceite, viscosidad) Ejercicio 4. Se realiza un estudio de campo para conocer el desarrollo de cierta especie de pez del lago lakemary en EEUU. Para medir el desarrollo se establece la edad de cada pez capturado mediante un procedimiento proporcionado por los biólogos. Además se mide la longitud del pez para tratar de establecer el estado de maduración de cada ejemplar. La investigación trata de relacionar la edad el pez a partir de su longitud para determinar el número de capturas permitidas. Las variables recogidas son: “Age” (edad del pez), y “Length” (longitud del pez en mm). data(&quot;lakemary&quot;) ejer04 &lt;-lakemary Ejercicio 5. Es bien sabido que la concentración de colesterol en el suero sanguíneo aumenta con la edad, pero es menos claro si el nivel de colesterol también está asociado con el peso corporal. Los datos muestran para una treinta de mujeres el colesterol sérico (milimoles por litro), la edad (años) y el índice de masa corporal (peso dividido por la altura al cuadrado, donde el peso se midió en kilogramos y la altura en metros). Se trata de construir un modelo que explique el nivel de colesterol en función de la edad y del índice de masas corporal. Los datos corresponden con la tabla 6.17 de Dobson (2002). ejer05 &lt;- read_csv(&quot;https://goo.gl/EKXWRc&quot;, col_types = &quot;ddd&quot;) Ejercicio 6. Los datos muestran el porcentaje de calorías totales obtenidas de carbohidratos complejos, para veinte diabéticos dependientes de insulina que habían seguido una dieta alta en carbohidratos durante seis meses. Se consideró que el cumplimiento del régimen estaba relacionado con la edad (en años), age, el peso corporal (relativo al peso “ideal” para la altura), weight, y otros componentes de la dieta como el porcentaje de proteínas ingeridas. Los datos corresponden con la tabla 6.3 de Dobson (2002). ejer06 &lt;- read_csv(&quot;https://goo.gl/Grm8xM&quot;, col_types = &quot;dddd&quot;) "],["glm.html", "Unidad 11 Modelos Lineales Generalizados 11.1 Modelo Teórico 11.2 Estimación de los GLM 11.3 Bondad del ajuste 11.4 Comparación de modelos 11.5 Diagnóstico de los GLM 11.6 Predicción de los GLM", " Unidad 11 Modelos Lineales Generalizados Todos los modelos estudiados hasta ahora comparten los mismos supuestos teóricos, dado que el tipo de variable respuesta es siempre de tipo numérico. Aunque este tipo de modelos abarcan un gran conjunto de situaciones experimentales, también es cierto que en algunos casos resulta difícil cumplir las hipótesis establecidas. De hecho, este tipo de modelos se asocian habitualmente con variables respuesta de tipo Normal, pero ¿qué ocurre cuando la variable no puede considerarse Normal? ¿Cómo podemos modelizar situaciones experimentales donde la variable respuesta es de tipo Binomial o Poisson? Son este tipo de situaciones las que motivan la introducción de un nuevo tipo de modelos que como caso particular engloban todos los vistos en los temas anteriores. Concretamente estudiaremos situaciones donde: la variable respuesta es de tipo Binomial, es decir, hemos observado si se cumple o no cierta condición experimental como resultado de un conjunto de variables predictoras que pueden ser de tipo numérico o categórico. la variable respuesta es de tipo Poisson, es decir, hemos observado el número de ocasiones que ha ocurrido un evento en un tiempo o espacio determinado como resultado de un conjunto de variables predictoras que pueden ser de tipo numérico o categórico. la variable respuesta es de tipo Exponencial, es decir, hemos observado el tiempo transcurrido hasta que ocurre un evento de interés como resultado de un conjunto de variables predictoras que pueden ser de tipo numérico o categórico. la variable respuesta es de tipo numérico, pero sólo puede tomar valores positivos de forma asimétrica, es decir, se encuentra concentrada en un conjunto de valores y su frecuencia disminuye cuando aumenta el valor de la respuesta. Este tipo de variable se conoce como Gamma. La característica común a todas estas situaciones es que la respuesta se puede englobar dentro de un conjunto de variables aleatorias cuya función de densidad puede ser escrita a través de una misma expresión. Todo este conjunto de variables se conocen con el nombre de familia exponencial. 11.1 Modelo Teórico Supongamos que hemos observado una situación experimental que involucra \\(n\\) sujetos cuyo conjunto de datos dispone de una variable respuesta \\(Y\\) y \\(p\\) variables predictoras \\(X_1,...,X_p\\). Denotamos por \\(Y_i\\) al valor de la respuesta para el sujeto \\(i\\), y \\(x_{i1},...,x_{ip}\\) al valor de las predictoras para el mismo sujeto. Como ya vimos anteriormente el objetivo de cualquier modelo es estudiar el comportamiento de la respuesta a partir de la información contenida en las variables predictoras, es decir: \\[E(Y_i|x_{i1},...,x_{ip}) = \\mu_i\\] Los supuestos del GLM son: \\(Y_i\\) son observaciones aleatorias e independientes cuya distribución de probabilidad corresponde a la familia exponencial con \\(E(Y_i) = \\mu_i\\). Las variables predictoras proporcionan un conjunto de predictores lineales \\(\\eta_i\\): \\[\\eta_i = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip}\\] Existe una función \\(g()\\) denominada función link (enlace) que establece que \\[g(\\mu_i) = \\eta_i = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip}\\] Es decir, tenemos un modelo lineal donde modelizamos la media de la respuesta sino una función de dicha media. A continuación se muestran las funciones link más habituales para los diferentes tipos de variable respuesta. 11.1.1 Distribución Binomial (logit link) En esta situación el valor esperado de la respuesta viene dado por \\(E(Y_i) = n \\pi_i\\), donde \\(\\pi_i\\) es la probabilidad de éxito, y la función link más habitual es: \\[g(\\mu_i) = log\\left(\\frac{\\mu_i}{n - \\mu_i}\\right)\\] Si sustituimos el valor de \\(\\mu_i\\) y simplificamos tenemos que: \\[g(\\mu_i) = log\\left(\\frac{\\pi_i}{1 - \\pi_i}\\right)\\] donde podemos ver que el objeto de nuestra modelización es una función de la probabilidad de éxito, que en realidad es nuestro parámetro de interés en este tipo de situaciones. 11.1.1.1 Ejemplo En un experimento se sometió a cierto número de cucarachas a cinco horas de exposición a disulfato de carbono gaseoso a varias concentraciones. Se pretendía investigar la relación existente entre la dosis de disulfato administrada y la resistencia de los insectos. La variable respuesta es \\(Y_i\\) = número de escarabajos muertos en un total de ni sometidos a una misma dosis de pesticida \\(x_i\\). La distribución habitual es binomial, \\(Y_i ~ Bi(n_i; \\pi_i)\\) para \\(i = 1,...,n\\), con \\(\\pi_i\\) = probabilidad de muerte a dosis \\(x_i\\). 11.1.2 Distribución Poisson (log link) En esta situación el valor esperado de la respuesta viene dado por \\(E(Y_i) = \\mu_i\\), donde \\(\\mu_i\\) es la tasa de ocurrencia, y la función link más habitual es: \\[g(\\mu_i) = log(\\mu_i)\\] donde podemos ver que el objeto de nuestra modelización es una función de la tasa de ocurrencia, que en realidad es nuestro parámetro de interés en este tipo de situaciones. 11.1.2.1 Ejemplo Se realiza un estudio en pacientes con una forma de cáncer de piel llamado melanoma maligno. En dicho estudio se recogió información sobre la localización del tumor y su tipo histológico. Los datos son el número de pacientes en cada combinación de tipo de tumor y localización. El interés básico del análisis es investigar la relación entre el tipo de tumor y su localización. 11.1.3 Distribución Normal (link identidad) En esta situación el valor esperado de la respuesta viene dado por \\(E(Y_i) = \\mu_i\\), donde \\(\\mu_i\\) es la media de la población, y la función link más habitual es: \\[g(\\mu_i) = \\mu_i\\] que corresponde exactamente con la expresión de los modelos lineales que hemos trabajo en temas anteriores. 11.1.4 Distribución Gamma (link recíproco) En esta situación la función link es: \\[g(\\mu_i) = \\frac{1}{\\mu_i}\\] 11.1.4.1 Ejemplo Se realiza un ensayo clínico donde se registra el tiempo de supervivencia (en semanas) para pacientes de leucemia y su correspondiente conteo inicial de células blancas en la sangre (en escala log10). El interés del análisis es intentar predecir el tiempo de supervivencia \\(Y\\) en función del número inicial de células blancas \\(x_i\\). Una distribución usual en la modelización de tiempos de superveniencia es la exponencial, que es un caso particular de la distribución Gamma. 11.2 Estimación de los GLM Es evidente que debemos modificar los procedimientos de estimación de los parámetros ya que la estructura lineal se asume sobre la transformación de la media de la respuesta y no sobre los valores de la respuesta directamente como ocurría en los modelos lineales. Los métodos de máxima verosimilitud para la estimación de los parámetros se basan en el Método de Scoring o el Método de Newton-Raphson. Se trata de métodos de estimación iterativos, y no directos como en el caso de los modelos lineales, que finalizan cuando se alcanzan las condiciones de convergencia del método. En la mayoría de situaciones experimentales dichos métodos convergen en pocas iteracciones y proporcionan las estimaciones del parámetro del modelo. Haciendo uso del Teorema Central del Límite resulta posible obtener además intervalos de confianza para los parámetros del modelo. Para la estimación de este tipo de modelos utilizamos la función glm() cuya estructura viene dada por: glm(modelo,family = distri(link = tipo),data_set) donde modelo representa la ecuación del modelo en la forma \\(respuesta \\sim predictoras\\), distri representa la distribución de probabilidad asociada con la respuesta, tipo la función link utilizada y data_set el conjunto de dato sobre el que se ajusta el modelo. En temas sucesivos veremos como especificar esta función en cada una de las situaciones experimentales planteadas. Para estudiar en profundidad los procedimientos de estimación se puede leer el capítulo 2 de MayMor01. 11.3 Bondad del ajuste Un aspecto importante en el ajuste de un modelo es determinar si describe adecuadamente o no los datos observados. Cuando ajustamos un modelo lineal generalizado, juzgamos la adecuación del modelo comparando la verosimilitud del modelo ajustado con la verosimilitud del modelo saturado. El modelo saturado es un modelo de forma similar al modelo propuesto que describe de modo perfecto los datos. Por tanto, tiene poca utilidad desde el punto de vista de ajuste de un modelo. Sin embargo, es útil para medir cómo un ajuste concreto se parece a un ajuste “perfecto.” Ejmplo. Considerando \\(Y_1,...,Y_n\\) v.a. normales, con \\(E(Y_i) = \\mu_i\\) y varianza común \\(\\sigma^2\\), se propone un modelo en el que todas las medias \\(\\mu_i\\) son iguales, \\[\\mu_1 = ... = \\mu_n = \\mu.\\] En el modelo saturado se usa la misma distribución (normal), el mismo link (identidad), y hay un parámetro a estimar por cada dato \\((\\mu_i \\to y_i)\\): \\[\\text{Modelo propuesto } E(Y_i) = \\mu, i=1,...,n \\to \\widehat{\\mu}_i = \\bar{y}\\] \\[\\text{Modelo saturado } E(Y_i) = \\mu_i, i=1,...,n \\to \\widehat{\\mu}_i = y_i\\] En los GLM el estadístico utilizado para valorar la bondad del ajuste obtenido se denomina D = Deviance. Dicho estadístico mide como de grande es la desviación del modelo ajustado respecto de los datos (modelo saturado). Si \\(D\\) es grande, el modelo ajustado proporciona un ajuste pobre. Un valor pequeño de \\(D\\) es indicador de un buen ajuste. Para decidir qué se considera “D grande” y qué “D pequeño,” es preciso utilizar la distribución en el muestreo del estadístico. Cuando el modelo propuesto proporciona un buen ajuste de los datos, entonces \\[D \\text{ } \\dot{\\sim} \\text{ } \\chi^2_{n-p}, \\text{ asintóticamente}\\] donde \\(n\\) es el número de datos a ajustar y \\(p\\) el número de parámetros del modelo. En la práctica comparamos el valor de la deviance con el cuantil 0.95 de una \\(Chi^2\\) con \\(n-p\\) grados de libertad. Si \\(D\\) es menor que el cuantil diremos que tenemos un buen ajuste. En la práctica obtendremos el p-valor asociado con dicha deviance y lo comparemos con el valor de referencia 0.05. Si el p-valor obtenido es superior a 0.05 diremos que tenemos un buen ajuste. 11.4 Comparación de modelos Aunque un modelo con más parámetros proporcione un ajuste mejor que otro con menos parámetros, cabe plantearse si en realidad todos los parámetros estimados son necesarios. Esta cuestión se puede resolver con tests basados en la deviance y en el estadístico de Wald, siempre y cuando se trate de modelos anidados. Otros estadísticos como el AIC permiten la comparación más general de modelos no necesariamente anidados. Dos modelos en competencia pueden ser comparados mediante la deviance cuando tienen la misma distribución y función link y sólo difieren en el número de parámetros, es decir, cuando se trata de modelos anidados. Supongamos dos modelos \\(M1\\) con \\(p_1\\) parámetros y \\(M2\\) con \\(p_2\\) parámetros, de forma que el primero está anidado en el segundo, es decir, \\(p_1 &lt; p_2\\). En esta situación el estadístico para valorar si ambos modelos pueden considerarse iguales, es decir, debemos elegir \\(M1\\) ya que es más simple, sigue una distribución \\(\\chi^2_{p_2-p_1}\\). Para resolver la comparación debemos obtener el cuantil 0.95 de la distribución chi cuadrado y compararlo con el valor del estadístico. Si el pvalor asociado es inferior a 0.05 rechazaremos el modelo \\(M1\\) en favor del modelo \\(M2\\), mientras que si es superior a 0.05 elegiremos el modelo \\(M1\\). Para la selección automática de efectos en la construcción de un modelo se pueden utilizar los estadísticos AIC o el BIC. En ambos casos seleccionaremos el modelo con menor valor en dichos estadísticos. Procedemos de igual forma a los que hacíamos en los modelos lineales que involucran más de una variable predictora. 11.5 Diagnóstico de los GLM Los residuos se pueden utilizar para explorar la adecuación del ajuste de un modelo respecto a la elección de la función de varianza, la función link y los términos a incluir en el predictor lineal. Los residuos pueden también ser útiles para detectar observaciones influyentes o valores anómalos que requieran una investigación más intensa. Para modelos lineales generalizados, requerimos una definición algo más amplia de residuos, que sea aplicable a todas las distribuciones que pueden reemplazar a la Normal. Los gráficos de residuos pueden ser muy útiles a la hora de detectar fallos sistemáticos en un modelo para ajustar unos datos. Detectados los fallos, la labor siguiente consiste en solventar las deficiencias y reajustar el modelo. Sin embargo, cuando la respuesta toma sólo unos pocos valores, como ocurre en pruebas Bernoulli, la utilidad de los residuos es limitada. La especificación incorrecta de un modelo se puede deber a una serie de factores: elección incorrecta de la distribución de probabilidad, especificación incorrecta de la forma en que la respuesta media cambia con las variables explicativas, ya sea porque: la componente sistemática \\(\\eta()\\) está mal especificada, o la función link \\(g()\\) no es apropiada, variables explicativas no incorporadas en el modelo, funciones incorrectas de las variables explicativas en el modelo, incluyendo interacciones desconocidas entre ellas, o no disponibilidad de suficientes funciones diferentes, dependencia entre las observaciones, por ejemplo, a lo largo del tiempo (autocorrelación). Se definen en este caso los residuos deviance estandarizados que son los utilizados para diagnosticar el modelo, obtenidos como los residuos asociados con el predictor lineal. Sin embargo, dada la estructura de los GLM podemos definir también los residuos de la respuesta que son los obtenidos entre el valor de la respuesta y el proporcionado al deshacer el cambio involucrado en la función link. Utilizaremos los procedimientos gráficos vistos en temas anteriores para proceder con el diagnóstico de este tipo de modelos. 11.6 Predicción de los GLM La predicción en este tipo de modelos se divide en dos fases: predicción del predictor lineal predicción de la respuesta Dado un GLM con predictor lineal dado por \\(\\eta_i = X_i\\beta\\) y función link \\(g(\\mu_i)\\), el proceso de estimación del modelo nos proporciona los valores estimados de \\(\\beta\\), de forma que obtendríamos el valor ajustado del predictor lineal como: \\[\\widehat{\\eta}_i = X_i\\widehat{\\beta}\\] y el valor ajustado de como \\[\\mu_i = g^{-1}(\\widehat{\\eta}_i) = g^{-1}(X_i\\widehat{\\beta})\\] "],["glmbinomial.html", "Unidad 12 GLM respuesta binomial 12.1 Tipos de datos binomiales 12.2 Especificación e hipótesis de modelo 12.3 Estimación y bondad de ajuste 12.4 Selección del modelo 12.5 Diagnóstico 12.6 Predicción 12.7 Ejercicios", " Unidad 12 GLM respuesta binomial Consideramos en este tema la modelización de variables respuesta de tipo binario, es decir, para cada individuo, la variable respuesta para cada uno de los sujetos puede tomar únicamente dos posibles valores, que denotaremos por 0 (fracaso) y 1 (éxito), \\[Pr(Y_i = 0) = 1 - \\pi_i; \\text{ } Pr(Y_i = 1) = \\pi_i\\] Si además se han observado una serie de covariables continuas o de tipo factor, el objetivo del análisis con el modelo lineal generalizado será predecir la probabilidad asociada al éxito, \\(\\widehat{\\pi_i}\\), (o equivalentemente el fracaso), en función de dichas covariables. 12.1 Tipos de datos binomiales Existen dos formas habituales en las que se presenta o se recoge la información experimental sobre variables que miden éxito o fracaso. A continuación detallamos dichas situaciones experimentales y vemos un ejemplo de cada una de ellas. 12.1.1 Información individualizada por sujeto En este caso el banco de datos recoge la información de cada sujeto de la muestra con una variable que indica el éxito o el fracaso. Dicha variable se suele codificar 1 (éxito) y 0 (fracaso). Asociada con esta variable binaria se pueden recoger variables predictoras, en cada uno de los sujetos, para tratar de explicar el comportamiento de la respuesta. 12.1.1.1 Datos de Kifosis En este banco de datos aparecen los datos de 81 niños que fueron intervenidos quirúrgicamente para corregirles problemas en la columna vertebral. La variable binaria kifosis indica la presencia o ausencia de una deformidad postoperatoria en la columna, denominada kifosis. Las otras tres variables son Age, edad del niñoo en meses, Number, número de vértebras intervenidas en la operación, y Start, que define la primera vértebra involucrada en la operación. Es de interés en el análisis investigar cómo están relacionadas dichas variables a la hora de predecir la incidencia de la kifosis en el postoperatorio. En este caso todas las variables predictoras son de tipo numérico. En este caso la variable respuesta se puede representar mediante el modelo \\(Y_i \\sim Bi(n = 1, \\pi_i)\\), dado que cada observación corresponde a un único sujeto con \\(\\pi_i\\) la probabilidad de sufrir una deformidad postoperatoria para el sujeto \\(i\\). Cargamos los datos a partir de la librería rpart y los representamos gráficamente. En este caso realizamos diagramas de caja para cada variable predictora. La variable respuesta viene codificada con las opciones absent y present, por lo que al cargar los datos codificaremos dichos valores como 0 y 1. En este caso el éxito viene marcado por tener la enfermedad. Kyphosis &lt;- factor(c(1, 1, 2L, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1), labels = c(&quot;absent&quot;, &quot;present&quot;)) Age &lt;- c(71, 158, 128, 2, 1, 1, 61, 37, 113, 59, 82, 148, 18, 1, 168, 1, 78, 175, 80, 27, 22, 105, 96, 131, 15, 9, 8, 100, 4, 151, 31, 125, 130, 112, 140, 93, 1, 52, 20, 91, 73, 35, 143, 61, 97, 139, 136, 131, 121, 177, 68, 9, 139, 2, 140, 72, 2, 120, 51, 102, 130, 114, 81, 118, 118, 17, 195, 159, 18, 15, 158, 127, 87, 206, 11, 178, 157, 26, 120, 42, 36) Number &lt;- c(3, 3, 4, 5, 4, 2, 2, 3, 2, 6, 5, 3, 5, 4, 3, 3, 6, 5, 5, 4, 2, 6, 3, 2, 7, 5, 3, 3, 3, 2, 3, 2, 5, 3, 5, 3, 3, 5, 6, 5, 5, 3, 9, 4, 3, 3, 4, 5, 3, 2, 5, 2, 10, 2, 4, 5, 3, 5, 7, 3, 4, 7, 4, 3, 4, 4, 2, 4, 4, 5, 5, 4, 4, 4, 3, 4, 3, 7, 2, 7, 4) Start &lt;- c(5, 14, 5, 1, 15, 16, 17, 16, 16, 12, 14, 16, 2, 12, 18, 16, 15, 13, 16, 9, 16, 5, 12, 3, 2, 13, 6, 14, 16, 16, 16, 11, 13, 16, 11, 16, 9, 6, 9, 12, 1, 13, 3, 1, 16, 10, 15, 13, 3, 14, 10, 17, 6, 17, 15, 15, 13, 8, 9, 13, 1, 8, 1, 16, 16, 10, 17, 13, 11, 16, 14, 12, 16, 10, 15, 15, 13, 13, 13, 6, 13) kyphosis &lt;- data.frame(Kyphosis, Age, Number, Start) # Recodificación a 0 - 1 kyphosisb = kyphosis %&gt;% mutate(Kyphosis = 1*(Kyphosis==&quot;present&quot;)) # Gráficos de predictoras y variable datacomp = melt(kyphosis, id.vars=&#39;Kyphosis&#39;) ggplot(datacomp) + geom_boxplot(aes(Kyphosis,value, colour=variable)) + facet_wrap(~variable, scales =&quot;free_y&quot;) + labs(x = &quot;&quot;, y = &quot;Kyphosis&quot;) En dichos gráficos podemos ver como hay más incidencia de la enfermedad para los bebes más grandes y cuando el número de vértebras intervenidas es inferior, mientras que disminuye cuando la primera vértebra involucrada en la operación tiene un valor más bajo, es decir, se sitúa más arriba en la columna vertebral. 12.1.2 Información agrupada por sujetos Los bancos de datos de este tipo suelen identificar por fila el “tratamiento” al que se ven sometidos un grupo de sujetos, registrándose el número total de sujetos en esa combinación y el número de éxitos (en algunos casos se recogen los éxitos y fracasos para dicha combinación). El “tratamiento” puede ser la combinación de una o más predictoras. Estos bancos de datos son muy habituales en ensayos de dosis-repuesta donde únicamente queremos valorar eficacia, ya que no es necesario recoger una información exhaustiva sobre los sujetos bajo estudio. En estos casos no estimamos la probabilidad de éxito individual sino del grupo de sujetos que se ven sometidos al mismo tratamiento. La información muestral debe recoger la probabilidad de éxito asociada a cada combinación. 12.1.2.1 Datos dosis-respuesta Collet (1991) presenta un experimento sobre la toxicidad de distintas dosis (en microgramos) del piretroide trnas-cipemetrín en los capullos de gusano del tabaco. Se había comenzado a detectar resistencia de esas polillas a dicho tóxico. El experimento consistía en exponer, durante tres días y a distintas dosis de tóxico, a series de 20 polillas de cada sexo (total). Se anotaron el número de polillas muertas en cada serie (dead). Es de interés en el análisis investigar si efectivamente se demostraba tal resistencia al tóxico en función del sexo de la polilla (sex) y a partir de qué dosis (dosis). También se desea determinar la dosis a la cual es posible garantizar el exterminio del 50% de los insectos. En este caso tenemos un modelo \\(Y_i \\sim Bi(n = 20, \\pi_i)\\), con \\(\\pi_i\\) la probabilidad de morir para una polilla en la combinación dosis-sexo. Veamos los datos para este experimento y la representación gráfica. Utilizamos la variable log(dosis) como es habitual en este tipo de experimentos para linealizar la relación entre probabilidad de éxito y dosis . Dosis = read_csv(&quot;https://goo.gl/w23RGz&quot;, col_types = &quot;cdii&quot;) Dosis Tabla 12.1: sexdosistotaldead M1201 M2204 M4209 M82013 M162018 M322020 F1200 F2202 F4206 F82010 F162012 F322016 # Calculamos los vivos, la probabilidad de morir, y el # logaritmo de dosis que es la forma habitual de medir # en este tipo de situaciones Dosis = Dosis %&gt;% mutate(alive = total - dead, probabilidad = dead/total, ldosis = log(dosis)) Dosis Tabla 12.1: sexdosistotaldeadaliveprobabilidadldosis M1201190.050&nbsp;&nbsp;&nbsp;&nbsp; M2204160.2&nbsp;0.693 M4209110.451.39&nbsp; M8201370.652.08&nbsp; M16201820.9&nbsp;2.77&nbsp; M32202001&nbsp;&nbsp;&nbsp;3.47&nbsp; F1200200&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp; F2202180.1&nbsp;0.693 F4206140.3&nbsp;1.39&nbsp; F82010100.5&nbsp;2.08&nbsp; F16201280.6&nbsp;2.77&nbsp; F32201640.8&nbsp;3.47&nbsp; # Representamos la probabilidad de morir en función de # las covariables sex y ldosis ggplot(Dosis,aes(x = ldosis, y = probabilidad, color = sex)) + geom_point() + labs(x = &quot;Logaritmo Dosis&quot;, y = &quot;Probabilidad de morir&quot;) Se observa que para la misma dosis la probabilidad de morir en las hembras es menor que en los machos. Además, hay una tendencia creciente con la dosis, es decir, cuanto aumenta la dosis aumenta la probabilidad de morir. 12.2 Especificación e hipótesis de modelo Las hipótesis que debe verificar los modelos de este tipo son: independencia entre las observaciones linealidad entre transformaciones de la proporción de éxitos y de las variables explicativas continuas (función link) consistencia entre la modelización y la interpretación física. Si \\(\\pi_i\\) es la probabilidad de éxito asociado al i-ésimo experimento binomial con respuesta \\(Y_i\\), y condiciones de experimentación observadas en las variables predictoras \\(X_1;X_2,...,X_p\\), la formulación del GLM viene dada por: \\[g(\\pi_i) = \\eta_i = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip}\\] donde \\(g()\\) es la función link asociada con este tipo de datos. En este tipo de modelos los coeficientes \\(\\beta_i\\) representan el incremento o decremento sobre la función de enlace que nos permite linealizar la relación entre la probabilidad de éxito y las variables predictora o predictor lineal. A continuación, presentamos las diferentes posibilidades de funciones link para este tipo de datos. 12.2.1 Funciones link En este tipo de modelos se contemplan diferentes funciones link. De forma habitual se suelen ajustar los modelos obtenidos para función de enlace, y nos quedamos con aquel modelo, y por tanto función de enlace, con mejor capacidad explicativa. 12.2.1.1 link logit El link logit proporciona los comúnmente conocidos como modelos de regresión logística y su expresión viene dada por: \\[g(\\pi_i) = log\\left( \\frac{\\pi_i}{1-\\pi_i}\\right) = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip}\\] En esta situación la probabilidad de éxito se puede escribir en términos de las variables predictoras (despejando de la ecuación anterior) como: \\[\\pi_i = \\frac{exp(\\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip})}{1+exp(\\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip})} \\] Si \\(\\pi_i (x_1)\\) y \\(\\pi_i (x_2)\\) denotan las probabilidades de éxito para dos valores de la predictora (\\(x_1\\) y \\(x_2\\)), el cociente \\((\\pi_i (x_1)/(1-\\pi_i (x_1))) / (\\pi_i (x_2)/(1-\\pi_i (x_2)))\\) se denomina odds ratio y valora la relación entre probabilidad de éxito y fracaso para dos valores de la covaraible, de forma que: un valor mayor que 1 indica un aumento de la probabilidad de éxito en \\(x_1\\) con respecto a \\(x_2\\), un valor menor que 1 indica un decremento de la probabilidad de éxito en \\(x_1\\) con respecto a \\(x_2\\). En términos del modelo ajustado se puede valorar el incremento o decremento del odds ratio con el valor de \\(exp(\\beta_i)\\), para cada uno de los efectos (variables numéricas o niveles de un factor) presentes en el modelo. Valores negativos de \\(\\beta_i\\) dan lugar a odds ratios menores que 1, mientras que valores de \\(\\beta_i\\) positivos dan odds ratios positivos. De hecho, esta propiedad es la que motiva que esta función de enlace sea la más utilizada en este tipo de modelos. En R podemos obtener el valor de la función enlace para cualquier probabilidad con la sentencia binomial(link = logit)$linlfun(probabilidad) y el valor de la probabilidad de éxito a partir del valor del predictor lineal con binomial(link = logit)$linlinv(predictor) 12.2.1.2 link probit El link probit proporciona los comúnmente conocidos como modelos de regresión probit y su expresión viene dada por: \\[g(\\pi_i) = \\Phi^{-1}(\\pi_i) = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip}\\] donde \\(\\Phi^{-1}\\) es la función inversa de la función de distribución Normal estándar. En esta situación la probabilidad de éxito se puede escribir en términos de las variables predictoras (despejando de la ecuación anterior) como: \\[\\pi_i = \\Phi(\\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} + ... + \\beta_p x_{ip})\\] donde \\(\\Phi\\) es la función de distribución Normal estándar. 12.2.1.3 link cloglog El link cloglog es el menos habitual en la práctica y su expresión viene dada por: \\[g(\\pi_i) = log(-log(1-\\pi_i)) = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{21} +...+\\beta_p x_{ip}\\] ¿Cuál es la probabilidad de éxito en este caso? La diferencia entre un link y otro hace referencia a como modelizamos las probabilidades más extremas, es decir, las muy bajas o muy altas, pero en la práctica proporcionan resultados muy similares. Por eso casi siempre el modelo utilizado es el de regresión logística. 12.2.2 Representación de las funciones link Para poder comparar los diferentes links presentados veamos cual es su comportamiento en función de la probabilidad de éxito, lo que se denomina en los modelos de dosis-respuesta función de tolerancia. Respectivamente se representan el link logit (línea continua), link probit (línea discontinua), link cloglog (puntos): En este gráfico se puede apreciar las pequeñas diferencias entre las funciones de enlace. Podemos ver que para un valor del predictor lineal de 2.5 la probabilidad de éxito en los modelos probit y cloglog es 1 mientras que para el modelo logit está próxima a 0.9. La elección de un tipo de enlace u otro dependerá por tanto del comportamiento de los datos observados. Representamos a continuación las diferentes funciones link para los datos de dosis-respuesta. Este gráfico sólo se puede hacer para datos en formato agrupado. Se aprecia como las tres funciones de enlace tienen un comportamiento muy similar. En el resto de esta unidad mostraremos los resultados correspondientes al modelo de regresión logística (link logit), e indicaremos como obtener los modelos para el resto de funciones link. 12.3 Estimación y bondad de ajuste Para la estimación utilizamos la función glm con las especificaciones siguientes: # Modelo de regresión logística glm(modelo,family = binomial(link = logit),data_set) # Modelo de regresión probit glm(modelo,family = binomial(link = probit),data_set) # Modelo cloglog glm(modelo,family = binomial(link = cloglog),data_set) Sin embargo, la especificación del modelo varía en función del tipo de datos (individualizados o conteos). En el caso de nuestro banco de datos contenga información individualizada para cada sujeto la variable respuesta se debe codificar con un 1 para el éxito y 0 para el fracaso, y el modelo se especifica como: respuesta ~ predictoras En el caso de disponer del número de éxitos y fracasos el modelo se especifica e la forma siguiente: cbind(exitos,fracasos) ~ predictoras 12.3.1 Ejemplos Estudiamos ahora el proceso de estimación del modelo completo (con todos los efectos posibles) para cada uno de los ejemplos. Utilizamos la función tab_model() con diferentes especificaciones para obtener las estimaciones de los parámetros del modelo (predictor lineal) y de los odds ratios. 12.3.1.1 Kyphosis En este caso ya hemos creado un variable para identificar el éxito (tener malformación postoperatoria) o el fracaso (no tener malformación) para cada sujeto de la muestra. El banco de datos es kyphosisb con variable respuesta Kyphosis y con tres posibles variables predictoras de tipo numérico: Age, Number, Start. Para ajustar el modelo de regresión logística escribimos: fit.kyphosis &lt;- glm(Kyphosis ~ Age + Number + Start, family = binomial(link = logit), data = kyphosisb) Veamos las estimaciones del modelo ajustado: # Resumen del predictor lineal tab_model(fit.kyphosis, transform = NULL, string.est = &quot;Estimate&quot;, show.r2 = FALSE)   Kyphosis Predictors Estimate CI p (Intercept) -2.04 -5.11 – 0.67 0.160 Age 0.01 -0.00 – 0.02 0.090 Number 0.41 0.00 – 0.90 0.068 Start -0.21 -0.35 – -0.08 0.002 Observations 81 # Gráfico plot_model(fit.kyphosis, transform = NULL, axis.title = c(&quot;Estimate&quot;,&quot;&quot;), show.values = TRUE) A la vista de los coeficientes estimados se desprende que la única preditora que parece tener influencia en la probabilidad de observar una malformación es la variable Start. Dado que el coeficiente es negativo dicha probabilidad disminuye cuando aumenta dicha variable. La ecuación del modelo viene dada por: \\[log\\left( \\frac{\\hat{\\pi}_i}{1-\\hat{\\pi}_i}\\right) = -2.04 + 0.01 *Age_{i} + 0.41 *Number_{1} - 0.21 *Start_{i}\\] donde la probabilidad de éxito es: \\[\\pi_i = \\frac{exp(-2.04 + 0.01 * Age_{i} + 0.41* Number_{i} - 0.21* Start_{i})}{1 -exp(2.04 + 0.01* Age_{i} + 0.41* Number_{i} - 0.21* Start_{i})}\\] Los odds ratios asociados a cada variable presente en el modelo vienen dados por \\[ \\begin{array}{ll} odds(Age) = &amp; exp(0.01) = 1.01\\\\ odds(Number) = &amp; exp(0.41) = 1.51\\\\ odds(Start) = &amp; exp(-0.21) = 0.81\\\\ \\end{array} \\] En términos de los odds ratios podemos ver que la probabilidad de sufrir una malformación aumenta 1.01 y 1.51 al aumentar respectivamente las variables Age y Number, es decir, la probabilidad de sufrir una malformación al incrementar en una unidad el número de vértebras intervenidas es 1.5 (odds ratio) veces superior que de no padecerla. Con la variable Start podemos ver que la relación entre sufrir la malformación es 0.81 veces la probabilidad de no sufrirla, es decir, disminuye al aumentar la vértebra de inicio. Con la formulación siguiente podemos obtener y representar de forma directa los odds ratios asociados al modelo analizado: # Resumen del predictor lineal tab_model(fit.kyphosis, show.r2 = FALSE)   Kyphosis Predictors Odds Ratios CI p (Intercept) 0.13 0.01 – 1.95 0.160 Age 1.01 1.00 – 1.02 0.090 Number 1.51 1.00 – 2.45 0.068 Start 0.81 0.71 – 0.92 0.002 Observations 81 # Gráfico plot_model(fit.kyphosis, show.values = TRUE) De todas formas hay que ser cautelosos en la interpretación dado que todavía no hemos validado el modelo ni hemos realizado el proceso de selección de efectos relevantes en el modelo. Para realizar la bondad de ajuste del modelo obtenemos los estadísticos asociados (función glance) y el contraste de bondad de ajuste utilizando la deviance explicada y sus grados de libertad asociados utilizando el test \\(\\chi^2\\). # P-valor del contraste 1-pchisq(fit.kyphosis$deviance,fit.kyphosis$df.residual) ## [1] 0.9033442 # Bondad del ajuste glance(fit.kyphosis) Tabla 12.2: null.deviancedf.nulllogLikAICBICdeviancedf.residualnobs 83.280-30.769.47961.47781 El p-valor obtenido es superior a 0.05 indicando que el modelo considerado tiene una buena capacidad explicativa. En el punto siguiente estudiaremos la selección de variables para quedarnos con el mejor modelo posible. 12.3.1.2 Dosis-Respuesta En este caso trabajamos con datos agrupados que contabilizan los éxitos (número de polillas muertas) y los fracasos (número de polillas vivas) para cada combinación considerada en el diseño experimental. Se consideran las variables predictoras sex (categórica) y dosis (numérica). El banco de datos es Dosis y contiene además las polillas totales, muertas y vivas (calculadas como muertas - vivas), y el logaritmo de la dosis suministrada, ya que de forma habitual en este tipo de modelos se suele trabajar en dicha escala logarítmica. Para ajustar el modelo de regresión logística consideramos los efectos asociados con cada predictora, así como la posible interacción entre ambos: Yres &lt;- cbind(Dosis$dead,Dosis$alive) fit.dosis &lt;- glm(Yres ~ sex * ldosis, family = binomial(link = logit), data = Dosis) Analizamos el modelo obtenido: # Resumen del predictor lineal tab_model(fit.dosis, transform = NULL, string.est = &quot;Estimate&quot;, show.r2 = FALSE)   Yres Predictors Estimate CI p (Intercept) -2.99 -4.19 – -2.00 &lt;0.001 sex [M] 0.17 -1.37 – 1.72 0.822 ldosis 1.31 0.87 – 1.82 &lt;0.001 sex [M] * ldosis 0.51 -0.24 – 1.31 0.191 Observations 12 # Gráfico plot_model(fit.dosis, transform = NULL, axis.title = c(&quot;Estimate&quot;,&quot;&quot;), show.values = TRUE) De los resultados obtenidos parece desprenderse que no existe efecto de interacción entre sexo y dosis. Antes de tratar de explicar el resto de efectos deberemos estudiar la posibilidad de eliminar dicho efecto del modelo. Las ecuaciones de este modelo vienen dadas por: \\[ log\\left(\\frac{\\widehat{\\pi_i}}{1-\\widehat{\\pi_i}}\\right)_{Machos} = -2.82 + 1.82 * ldosis_{i} \\] \\[ log\\left(\\frac{\\widehat{\\pi_i}}{1-\\widehat{\\pi_i}}\\right)_{Hembras} = -2.99 + 1.31 * ldosis_{i} \\] En el punto siguiente seleccionaremos el mejor modelo e interpretaremos con detalle los coeficientes y los odds-ratios estimados. Por otro lado, el p-valor para valorar la bondad del ajuste: 1-pchisq(fit.dosis$deviance,fit.dosis$df.residual) ## [1] 0.7582464 parece indicar que el ajuste obtenido es bueno, dado que es superior a 0.05. 12.4 Selección del modelo Para la construcción del mejor modelo utilizaremos los mismos procedimientos secuenciales de selección de efectos que vimos en unidades anteriores. En este caso disponemos del criterio Deviance, del AIC y del test \\(\\chi^2\\) (p-valor significativo o no) para valorar los efectos del modelo. En este caso utilizaremos el AIC dado que los p-valores son aproximados en este tipo de modelos, y tienen que ser interpretados con mucha cautela. Para realizar la selección del modelo utilizaremos el procedimiento: modelo.final &lt;- step(modelo) 12.4.1 Ejemplos Estudiamos a continuación cada uno de los ejemplos. 12.4.1.1 Kyphosis Realizamos la selección del modelo: stats::step(fit.kyphosis) ## Start: AIC=69.38 ## Kyphosis ~ Age + Number + Start ## ## Df Deviance AIC ## &lt;none&gt; 61.380 69.380 ## - Age 1 64.536 70.536 ## - Number 1 65.299 71.299 ## - Start 1 71.627 77.627 ## ## Call: glm(formula = Kyphosis ~ Age + Number + Start, family = binomial(link = logit), ## data = kyphosisb) ## ## Coefficients: ## (Intercept) Age Number Start ## -2.03693 0.01093 0.41060 -0.20651 ## ## Degrees of Freedom: 80 Total (i.e. Null); 77 Residual ## Null Deviance: 83.23 ## Residual Deviance: 61.38 AIC: 69.38 El proceso de selección de efectos indica que no podemos eliminar ninguna variable del modelo (todos los AIC asociados con las predictoras aumentan al eliminarlas). Los valores de Deviance siempre aumentan (deviance asociada a cada variable) cuando eliminamos cualquiera de las variables con respecto a la del modelo que se queda con todas ellas (&lt;none&gt;). Lo mismo ocurre con el estadístico AIC. Por tanto, el modelo final es el obtenido en el punto anterior. Todo el análisis de los coeficientes y de los odds ratios ya fue detallado y no se repite aquí. 12.4.1.2 Dosis-respuesta Realizamos la selección para el modelo de dosis-respuesta: stats::step(fit.dosis) ## Start: AIC=43.1 ## Yres ~ sex * ldosis ## ## Df Deviance AIC ## - sex:ldosis 1 6.7571 42.867 ## &lt;none&gt; 4.9937 43.104 ## ## Step: AIC=42.87 ## Yres ~ sex + ldosis ## ## Df Deviance AIC ## &lt;none&gt; 6.757 42.867 ## - sex 1 16.984 51.094 ## - ldosis 1 118.799 152.909 ## ## Call: glm(formula = Yres ~ sex + ldosis, family = binomial(link = logit), ## data = Dosis) ## ## Coefficients: ## (Intercept) sexM ldosis ## -3.473 1.101 1.535 ## ## Degrees of Freedom: 11 Total (i.e. Null); 9 Residual ## Null Deviance: 124.9 ## Residual Deviance: 6.757 AIC: 42.87 El proceso de selección indica que no debemos considerar el efecto de interacción ya que el valor de deviance es inferior cuando está presente que cuando lo eliminamos, el AIC aumenta al eliminarlo. El resto de efectos del modelo no pueden ser eliminados. Esto implica que al no haber efecto de interacción la probabilidad de morir se puede obtener mediante comportamientos paralelos para machos y hembras. Ajustamos el modelo sin interacción y realizamos el análisis de dicho modelo: fit.dosis &lt;- glm(Yres ~ sex + ldosis, family = binomial(link = logit), data = Dosis) La inferencia sobre el modelo viene dada por: # Resumen del predictor lineal tab_model(fit.dosis, transform = NULL, string.est = &quot;Estimate&quot;, show.r2 = FALSE)   Yres Predictors Estimate CI p (Intercept) -3.47 -4.46 – -2.61 &lt;0.001 sex [M] 1.10 0.42 – 1.82 0.002 ldosis 1.54 1.19 – 1.93 &lt;0.001 Observations 12 de forma que podemos escribir el predictor lineal mediante las expresiones siguientes (atendiendo a los diferentes valores de sex): \\[ log\\left(\\frac{\\widehat{\\pi_i}}{1-\\widehat{\\pi_i}}\\right)_{Machos} = -2.37 + 1,54* ldosis_{i} \\] \\[ log\\left(\\frac{\\widehat{\\pi_i}}{1-\\widehat{\\pi_i}}\\right)_{Hembras} = -3.47 + 1.54* ldosis_{i} \\] donde \\(\\pi_i\\) es la probabilidad de muerte de la polilla. Dado que la interceptación es más pequeña para las hembras que para los machos tenemos un indicador de que las hembras son más resistentes que los machos. La pendiente positiva refleja que la probabilidad de muerte aumenta cuando lo hace la dosis. En términos de los odds ratios: # Resumen del predictor lineal tab_model(fit.dosis, show.r2 = FALSE)   Yres Predictors Odds Ratios CI p (Intercept) 0.03 0.01 – 0.07 &lt;0.001 sex [M] 3.01 1.52 – 6.17 0.002 ldosis 4.64 3.28 – 6.90 &lt;0.001 Observations 12 podemos ver que el odds ratio de los machos frente a las hembras es 3.01 veces (coeficiente de sexo) superior, y es 4.64 veces mayor (coeficiente de log(dosis)) cuando aumentamos en una unidad el logaritmo de la dosis. El odds ratio por sexo se obtiene como: \\[ \\frac{\\left(\\widehat{\\pi_i}/(1-\\widehat{\\pi_i})\\right)_{Machos}}{\\left(\\widehat{\\pi_i}/(1-\\widehat{\\pi_i})\\right)_{Hembras}} = \\frac{exp(-2.37 + 1,54 * ldosis_{i})}{exp(-3.47 + 1.54 * ldosis_{i})} = exp(3.47 - 2.37) = exp(1.1) \\] mientras que el odds ratio por ldosis, tanto para machos como para hembras, se obtiene como (tomamos los machos): \\[ \\frac{\\left(\\widehat{\\pi_i}/(1-\\widehat{\\pi_i})\\right)_{Machos}}{\\left(\\widehat{\\pi_i}/(1-\\widehat{\\pi_i})\\right)_{Machos}} = \\frac{exp(-2.37 + 1,54 * (ldosis_{i}+1))}{exp(-2.37 + 1.54 * ldosis_{i})} = exp(1.54) \\] La bondad de ajuste de este modelo: 1-pchisq(fit.dosis$deviance,fit.dosis$df.residual) ## [1] 0.6623957 muestra que el ajuste obtenido puede considerarse como bueno dado que el p-valor resulta no significativo. Para verificar el efecto de la dosis por sexo podemos calcular cuál es la dosis necesaria aplicar a cada sexo para conseguir una probabilidad de muerte del 50%, o como habitualmente se conoce con el nombre de dosis letal al 50% (LD50). Para ello basta con sustituir en las ecuaciones anteriores el valor de \\(\\pi_i\\) por 0.5 y despejar el valor de ldosis: \\[ldosis50_{Machos} = \\frac{2.372}{1.535} = 1.54277 \\to dosis50_{Machos} = exp(1.54277) = 4.69 \\] \\[ldosis50_{Hembras} = \\frac{3.473}{1.535} = 2.262541 \\to dosis50_{Hembras} = exp(1.54277) = 9.61 \\] De los resultados obtenidos podemos ver que hay que aplicar el doble de dosis en las hembras para conseguir la misma probabilidad de muerte del 50%. Para conseguir cualquier otra dosis letal basta con sustituir \\(\\pi_i\\) por la correspondiente probabilidad y despejar en las ecuaciones obtenidas, o utilizar el código siguiente para obtener la dosis letal a una probabilidad “prob”: # prob = Probabilidad buscada predictor &lt;- binomial(link = logit)$linkfun(prob) machos &lt;-exp((predictor+2.372)/1.535) hembras &lt;- exp((predictor+3.473)/1.535) Utilizamos el código anterior para representar y estudiar las curvas de dosis letales para ambos sexos (machos = azul, hembras = rojo): prob &lt;- seq(0.05,0.95,0.01) # Trabajamos con dosis predictor &lt;- binomial(link = logit)$linkfun(prob) machos &lt;-exp((predictor + 2.372) / 1.535) hembras &lt;- exp((predictor + 3.473) / 1.535) dosis &lt;- data.frame(prob, machos, hembras) ggplot(dosis) + geom_line(aes(x = prob, y = machos), color = &quot;blue&quot;) + geom_line(aes(x = prob, y = hembras), color = &quot;red&quot;) + scale_x_continuous(breaks = seq(0,1,0.05)) + scale_y_continuous(breaks = seq(0,70,5)) + labs(x = &quot;Probabilidad de muerte&quot;, y = &quot;Dosis&quot;) + theme_bw() 12.5 Diagnóstico Antes de comenzar el proceso de diagnóstico hay que recordar que en este tipo de modelos tenemos dos tipos de valores ajustados y dos tipos de residuos: Los correspondientes al predictor lineal obtenidos con las estimaciones de los parámetros del modelo. Los correspondientes a los valores originales que se obtienen al deshacer la transformación de la función de enlace. El diagnóstico de los GLM se basa en los procedimientos gráficos, que vimos en temas anteriores, aplicado a los residuos deviance obtenidos a partir del predictor lineal considerado (\\(X\\widehat{\\beta}\\)). Tanto para obtener los valores ajustados y residuos del predictor lineal utilizaremos la función fortify. Al resultado de dicha función podemos añadir sin muchos problemas los residuos entre valores originales de la respuesta y predichos. En el caso del modelo de regresión logística el código necesario viene dado por: # Sólo hay que sustituir &quot;modelo&quot; por el modelo ajustado a nuestros datos diagnostico &lt;- fortify(&quot;modelo&quot;) diagnostico$fitoriginal &lt;- predict.glm(&quot;modelo&quot;, type = &quot;response&quot;) diagnostico$residoriginal &lt;- residuals.glm(&quot;modelo&quot;, type = &quot;response&quot;) Los gráficos de diagnóstico que vamos a utilizar son: Residuos vs Ajustados (predictor lineal) Residuos vs variables en el modelo (predictor lineal) Valores influyentes 12.5.1 Ejemplos Pasamos a analizar cada uno de los ejemplos. 12.5.1.1 Kyphosis Obtenemos todas las cantidades de interés del modelo # Obtención de valores para el diagnóstico diagnostico &lt;- fortify(fit.kyphosis) diagnostico$fitoriginal &lt;- predict.glm(fit.kyphosis, type = &quot;response&quot;) diagnostico$residoriginal &lt;- residuals.glm(fit.kyphosis, type = &quot;response&quot;) Realizamos los gráficos de diagnóstico #Gráfico de residuos vs ajustados (predictor lineal) ggplot(diagnostico, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_smooth(method=loess, se=FALSE) + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) Como se puede observar en el gráfico de ajustados versus residuos la interpretación en este tipo de modelos se hace bastante complicada. Esto es debido a que la variable respuesta sólo toma valores 0 y 1, lo que motiva que el gráfico tenga esa pinta tan extraña. Si valoraros las distancias de Cook obtenidas (diagnostico$.cooksd) podemos ver que no hay ninguna superior a 1, y por tanto no tenemos ninguna observación influyente. # Gráficos de residuos vs predictoras (preditor lineal) plot_model(fit.kyphosis, type = &quot;resid&quot;, show.data = TRUE, ci.lvl = NA) + geom_point(color = &quot;black&quot;, size = 0.8) En cuanto a los gráficos con respecto a las variables predictoras parece apreciarse ciertas tendencias con respecto a ellas. Este comportamiento parece más evidente con la variable edad donde se ve una parábola indicando la posible existencia de un efecto polinómico de grado 2 con respecto a ella. En las otras dos predictoras el efecto es menos apreciable. Para solucionar este problema la opción más habitual sería ajustar un nuevo modelo indicando dicha tendencia de grado 2 (modelo polinómico con Age), pero se podría optar también por la inclusión de efectos de suavizado sobre cada una de ellas para evitar esas tendencias observadas. Utilizamos esta última opción y optamos por incluir efectos de suavizado para Age y Start (ambos con tendencias parabólicas) y comparamos con en el modelo sin suavizado. A pesar de que la respuesta no es numérica pode os utilizar la función gam sin más que identificar el tipo de respuesta y la función de enlace a utilizar. Veamos el ajuste y la comparación entre ambos modelos: # Modelo con suavizado en edad y start fit.kyphosis.gam &lt;- gam(Kyphosis ~ s(Age, k = 10, m = 2, bs = &quot;ps&quot;) + Number + s(Start, k = 10, m = 2, bs = &quot;ps&quot;), family = binomial(link = logit),kyphosisb) # Comparamos utilizando el estadístico AIC AIC(fit.kyphosis,fit.kyphosis.gam) Tabla 12.3: dfAIC 4&nbsp;&nbsp;&nbsp;69.4 6.1162.7 El menor valor de AIC indica que el modelo con efectos de suavizado es preferible al que no los tiene. Estudiamos con un poco más detalle dicho modelo: # Resumen del predictor lineal summary(fit.kyphosis.gam) ## ## Family: binomial ## Link function: logit ## ## Formula: ## Kyphosis ~ s(Age, k = 10, m = 2, bs = &quot;ps&quot;) + Number + s(Start, ## k = 10, m = 2, bs = &quot;ps&quot;) ## ## Parametric coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.6011 1.1482 -3.136 0.00171 ** ## Number 0.3333 0.2324 1.434 0.15160 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Approximate significance of smooth terms: ## edf Ref.df Chi.sq p-value ## s(Age) 2.151 2.671 6.345 0.0699 . ## s(Start) 1.956 2.409 9.747 0.0130 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## R-sq.(adj) = 0.354 Deviance explained = 39.3% ## UBRE = -0.22572 Scale est. = 1 n = 81 En los efectos paramétricos se comprueba que el efecto asociado con Number no resulta significativo, mientras que en los no paramétricos vemos que el suavizado con edad no resulta significativo al 95%. Construimos todos los posibles modelos y valoramos cual de ellos es el mejor: # Modelo con suavizados y number M1 &lt;- gam(Kyphosis ~ s(Age, k = 10, m = 2, bs = &quot;ps&quot;) + Number + s(Start, k = 10, m = 2, bs = &quot;ps&quot;), family = binomial(link = logit),kyphosisb) # Modelo con suavizados y sin number M2 &lt;- gam(Kyphosis ~ s(Age, k = 10, m = 2, bs = &quot;ps&quot;) + s(Start, k = 10, m = 2, bs = &quot;ps&quot;), family = binomial(link = logit),kyphosisb) # Modelo con suavizados con Start unicamente M3 &lt;- gam(Kyphosis ~ s(Start, k = 10, m = 2, bs = &quot;ps&quot;), family = binomial(link = logit),kyphosisb) # Valores de AIC AIC(M1,M2,M3) Tabla 12.4: dfAIC 6.1162.7 5.2463&nbsp;&nbsp; 3.0768.3 # Valores de GCV c(M1$gcv.ubre,M2$gcv.ubre,M3$gcv.ubre) ## GCV.Cp GCV.Cp GCV.Cp ## -0.2257187 -0.2223853 -0.1562664 El menor valor de AIC corresponde al modelo con los dos suavizados y la variable Number. Hay que tener en cuenta que las significatividades que parecen en las tablas son aproximaciones asintóticas, y por tanto siempre se deben tomar con cautela y proceder con otro tipo de comparación. El estadístico GCV también proporciona la misma conclusión. Por tanto, el modelo final ajustado viene dado por: \\[log\\left(\\frac{\\pi_i}{1-\\pi_i}\\right) = -3.60 + 0.33 * Number_i + s(Age_i) + s(Start_i)\\] Realizamos el diagnóstico del modelo de suavizado utilizando los procedimientos vistos en dicha unidad. # Gráficos de diagnóstico gam.check(fit.kyphosis.gam) ## ## Method: UBRE Optimizer: outer newton ## full convergence after 4 iterations. ## Gradient range [-5.641377e-09,6.154328e-08] ## (score -0.2257187 &amp; scale 1). ## Hessian positive definite, eigenvalue range [0.007746516,0.01021528]. ## Model rank = 20 / 20 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(Age) 9.00 2.15 1.11 0.86 ## s(Start) 9.00 1.96 1.14 0.92 Ningún p-valor resulta significativo indicando que el suavizado utilizado es adecuado. Además, los gráficos de diagnóstico no reportan ninguna incidencia. 12.5.1.2 Dosis - respuesta Realizamos ahora el diagnóstico para el modelo de dosis-respuesta a partir del modelo sin interacción obtenido en el apartado de selección del modelo. Obtenemos las cantidades de interés y realizamos los gráficos correspondientes. Obtenemos todas las cantidades de interés del modelo # Obtención de valores para el diagnóstico diagnostico &lt;- fortify(fit.dosis) diagnostico$fitoriginal &lt;- predict.glm(fit.dosis, type = &quot;response&quot;) diagnostico$residoriginal &lt;- residuals.glm(fit.dosis, type = &quot;response&quot;) Realizamos el gráfico de residuos versus ajustados identificando por el factor: #Gráfico de residuos vs ajustados (predictor lineal) ggplot(diagnostico, aes(x = .fitted, y = .stdresid, color = sex)) + geom_point() + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) En este caso no hemos ajustado las tendencias, ya que dado el tamaño de muestra tan pequeño en cada uno de los grupos, los resultados podrían mostrar tendencias ficticias que nos podrían hacer dudar de la validez del modelo. En este caso no se puede afirmar que exista ningún tipo de tendencia destacable. Tampoco se registra ninguna observación influyente. En los gráficos de residuos versus predictoras ocurre algo similar, ya que el número de observaciones es tan bajo que las posibles tendencias observadas no implican una modificación del modelo planteado. Dado el número tan bajo de observaciones el planteamiento de modelos con suavizado sobre dosis no resulta una opción. # Gráficos de residuos vs predictoras (preditor lineal) plot_model(fit.dosis, type = &quot;resid&quot;, show.data = TRUE, ci.lvl = NA) + geom_point(color = &quot;black&quot;, size = 0.8) 12.6 Predicción La predicción en este tipo de modelos se divide en dos fases: i) predicción del predictor lineal, y ii) predicción de la respuesta, aunque evidentemente la más interesante es la correspondiente a la respuesta. Sin embargo, cuando la respuesta viene individualizada, la predicción obtenida es un valor comprendido entre 0 y 1, con lo que hay que definir una regla para clasificar finalmente al sujeto con un 1 o un 0, identificando el éxito o el fracaso. En esta situación se toma la regla: si la predicción es mayor o igual a 0.5 asignamos un éxito como resultado de la predicción si la predicción es menor a 0.5 asignamos un fracaso como resultado de la predicción El resultado de la predicción es una tabla de doble entrada donde comparamos los valores observados frente a los predichos calculados con la regla anterior. En esta situación estamos interesados en el porcentaje de observaciones que son correctamente clasificadas como éxitos o fracasos. Este problema no aparece cuando tenemos datos agrupados ya que la variable respuesta ya es un valor entre 0 y 1, ya que modelizamos directamente la probabilidad de éxito. En los modelos de suavizado utilizaremos la función gam.predict para conseguir las predicciones. 12.6.1 Ejemplos A continuación, presentamos los procedimientos para obtener y representar la predicción de los modelos obtenidos en apartados anteriores. 12.6.1.1 Kyphosis Dado que en este caso tenemos datos individualizamos, en primer lugar calculamos la predicción de la respuesta y utilizamos la regla de clasificación presentada anteriormente, para obtener el porcentaje de clasificación correcta. # Obtención de predicción de la respuesta prediccion &lt;- predict.gam(fit.kyphosis.gam, type = &quot;response&quot;) # Clasificacmos a cada sujeto como éxito o fracaso clasificado &lt;- 1*(prediccion&gt;=0.5) tabla &lt;- table(kyphosis$Kyphosis,clasificado) tabla ## clasificado ## 0 1 ## absent 60 4 ## present 7 10 # Porcentaje de clasificación correcta round(100*sum(diag(tabla))/sum(tabla),2) ## [1] 86.42 Tenemos un 86.42% de clasificar correctamente a un individuo como éxito o fracaso en función de las variables predictoras consideradas. El modelo construido tiene alta capacidad predictiva ya que identifica bastante bien a los sujetos clasificados como éxitos y como fracasos. Estudiamos ahora los efectos marginales individuales de cada efecto presente en el modelo para valorar como influyen en la probabilidad de éxito, es decir, probabilidad de sufrir una malformación. # Gráficos marginales plot_model(fit.kyphosis.gam, &quot;pred&quot;) ## $Age ## ## $Number ## ## $Start Se observa la parábola que describe la variable Age, la función creciente con Number y la función decreciente con Start. En conclusión, la probabilidad de malformación: es más alta en valores de Age próximos a los 100 meses (probabilidad superior a 0.2). crece conforme aumenta el número de vértebras involucradas hasta superar el 0.6 con 10 vértebras. disminuye con la primera vértebra operada (si es a partir de la quinta) hasta hacerse prácticamente cero si empezamos en la vértebra 20. Construimos ahora los gráficos conjuntos para las tres predictoras mediante la creación de escenarios. Concretamente seleccionamos valores para Start y Age: Valores Start: 1, 5, 10, 15. Valores Age: 0, 50, 100, 150, 200, 250, 300 # Gráficos marginales plot_model(fit.kyphosis.gam, &quot;pred&quot;, terms =c(&quot;Number&quot;, &quot;Age [0, 50, 100, 150, 200, 250, 300]&quot;, &quot;Start [1,5,10,15]&quot;), ci.lvl = NA) Podemos ver el efecto de los escenarios con Number para predecir la probabilidad de malformación. No se aprecian muchas diferencias entre los perfiles de predicción para Start en los tres primeros niveles considerados, donde la probabilidad de malformación es muy similar, pero si se aprecian cambios cuando Start = 15. Esto implica directamente que cuando dicha variable toma valores más grandes la probabilidad de malformación disminuye drásticamente. 12.6.1.2 Dosis-respuesta Dado que los datos están en formato agrupado obtenemos los gráficos de predicción asociados a los efectos del modelo: plot_model(fit.dosis,&quot;pred&quot;, terms = c(&quot;ldosis&quot;,&quot;sex&quot;), title = &quot;Porcentaje de insectos muertos&quot;, axis.title = c(&quot;Log(dosis)&quot;,&quot;&quot;)) En los perfiles obtenidos se aprecia claramente el paralelismo entre ambos sexos, mostrando que las hembras son más resistentes (probabilidad de morir más baja) para todos los niveles de dosis considerados, y que la probabilidad de morir aumenta con la dosis suministrada. 12.7 Ejercicios Ejercicio 1. En un experimento se sometió a cierto número de cucarachas (number) a cinco horas de exposición a disulfato de carbono gaseoso a varias concentraciones. Se pretendía investigar la relación existente entre la dosis (dose) de disulfato administrada y la resistencia de los insectos (dead); si existe tal relación, determinar la dosis a la cual es posible garantizar el exterminio del 50% de los insectos. ejercicio01 = read_csv(&quot;https://goo.gl/E2MlSZ&quot;, col_types = &quot;dii&quot;) # Calculamos los vivos para el ajuste de modelos ejercicio01 = ejercicio01 %&gt;% mutate(alive = number - dead) Ejercicio 2. Se realiza un experimento in vitro para estimar el número de anteras embriogénicas de las especies de plantas Datura innoxia Mill bajo dos condiciones experimentales. El primer tratamiento consiste en almacenar a 3° C durante 48 horas, y el segundo consiste en un control donde no se aplica ningún tratamiento. Además se considera una variable que representa los tres valores de fuerza de centrifugación. Las variables registradas son total, embryogenic, storage, centrifuge. Es de interés en el análisis investigar si efectivamente se demostraba un mayor número de anteras para las diferentes condiciones experimentales. ejercicio02 = read_csv(&quot;https://goo.gl/6P3zRr&quot;, col_types = &quot;iici&quot;) # Recodificación del factor y variable de no embryogenic ejercicio02 = ejercicio02 %&gt;% mutate(storage=fct_recode(storage,&quot;Control&quot; = &quot;1&quot;,&quot;treatment&quot; = &quot;2&quot;), nembrig = total - embryogenic) Ejercicio 3. Se realiza un ensayo clínico para determinar en un grupo de personas mayores su estado psiquiátrico. Para cada sujeto se realiza un análisis completo y se clasifica cada uno en función de si muestra rasgos de senilidad (senility) (calificados como 1) o no (calificados como 0). Por otro lado se les pasa el test de escala de inteligencia de adultos (score) para saber si la puntuación obtenida puede ser un indicador de si la persona tiene rasgos de senilidad o no. ejercicio03 = read_csv(&quot;https://goo.gl/6E8fhd&quot;, col_types = &quot;ic&quot;) # Convertimos la respuesta para el ajuste de modelos ejercicio03 = ejercicio03 %&gt;% mutate(senility = 1*(senility==1)) Ejercicio 4. Se realiza un estudio para conocer que el impacto de la bomba de hiroshima en al aparición de caso de leucemia. Para ello se registro para todos los sujetos que presentaron algún tipo de cáncer el grado de radiación al que fue sometida la persona. Las variables que aparecen son los conteos del número de casos de leucemia (leukemia) y de otros tipos de cáncer (other) para los diferentes niveles de radiación (radiation). Se contabilizan también el número total de casos de cáncer registrados (total). Es de interés en el análisis investigar la influencia del grado de radiación en la aparición de un mayor número de casos de leucemia. ejercicio04 = read_csv(&quot;https://goo.gl/ZDIWVC&quot;, col_types = &quot;ciii&quot;) Ejercicio 5. La Oficina Europea de Patentes puede proteger una patente de la competencia durante un cierto período de tiempo. La Oficina de Patentes tiene la tarea de examinar las invenciones y declarar patentes si se cumplen ciertos requisitos previos. El requisito más importante es que la invención sea algo realmente nuevo. Con el fin de analizar las objeciones contra las patentes, se recopiló un conjunto de datos con 4,866 patentes de los sectores biotecnología / farmacia y semiconductor / computadora. Las variables inclinadas son: opp = oposición de patente; biopharm = Patente del sector biotecnológico / farmacéutico; ustwin = existe la patente gemela estadounidense; patus = titular de la patente de los Estados Unidos; patgsgr = titular de la patente de Alemania, Suiza o Gran Bretaña; año = Año de concesión; ncit = Número de citas de la patente; ncountry = Número de estados designados para la patente; nclaims = Número de declaraciones. ¿Cómo afecta cada una de las variables consideradas en la posible objeción a una patente? ejercicio05 = read_csv(&quot;https://goo.gl/2EygLk&quot;, col_types = &quot;ccccciiii&quot;) # Recodificación de factores ejercicio05 = ejercicio05 %&gt;% mutate(opp = fct_recode(opp,&quot;yes&quot; = &quot;1&quot;,&quot;no&quot; = &quot;0&quot;), biopharm=fct_recode(biopharm,&quot;yes&quot; = &quot;1&quot;,&quot;no&quot; =&quot;0&quot;), ustwin=fct_recode(ustwin,&quot;yes&quot; = &quot;1&quot;,&quot;no&quot; = &quot;0&quot;), patus=fct_recode(patus,&quot;yes&quot; = &quot;1&quot;,&quot;no&quot; = &quot;0&quot;), patgsgr=fct_recode(patgsgr,&quot;yes&quot; = &quot;1&quot;,&quot;no&quot; = &quot;0&quot;)) Ejercicio 6. Los datos siguientes describen los patrones de comportamiento en el consumo de drogas psicotrópicas en una muestra de individuos del Oeste de Londres. Los investigadores se plantean las preguntas siguientes: ¿Hay diferencias por sexo en el consumo de drogas? ¿Cómo influye la edad para explicar el consumo de psicotrópicos? ¿La edad influye igual en hombres y en mujeres? Obtén la expresión y el valor de las predicciones sobre el consumo de psicotrópicos en hombres y en mujeres de 17 y 52 años con el modelo ajustado. Las variables usa y nousa contienen la información sobre el uso de drogas psicotrópicas. sexo &lt;- c(rep(&quot;H&quot;,4),rep(&quot;M&quot;,4)) edad &lt;- c(&quot;16-29&quot;,&quot;30-44&quot;,&quot;45-64&quot;,&quot;65-74&quot;,&quot;16-29&quot;,&quot;30-44&quot;,&quot;45-64&quot;,&quot;65-74&quot;) usa &lt;- c(21,32,70,43,46,89,169,51) nousa &lt;- c(683,596,705,295,738,700,847,196) ejercicio06 = data.frame(sexo, edad, usa, nousa) Ejercicio 7. Se desea estudiar la sensibilidad de un test basado en el diagnóstico de la tuberculosis a través de una prueba basada en rayos X. la información registrdas viene agrupada para las variables tuberculosis, total y rayosx. En las dos primeras se registran los positivos y negativos detectados por rayox para los enfermos de tuberculosis y para todos los que se realziaron las pruebas. tuberculosis &lt;- c(22,8) total &lt;- c(51,1739) rayosx &lt;- c(&quot;Positivo&quot;,&quot;Negativo&quot;) ejercicio07 = data.frame(tuberculosis, total, rayosx) Ejercicio 8. En el Hospital de Yale-New Heaven, en Connecticut, se llevó a cabo un estudio para investigar la relación entre los nacimientos prematuros (el niño nazca antes de 37 semanas de gestación o su peso sea inferior a 2500 g.) y la edad de la madre. La población de estudio consistió en 175 madres de niños nacidos únicos y prematuros, y 303 madres de niños no prematuros. Los datos agrupados en función de la edad de la madre se presentan a continuación. ¿Hay alguna relación entre la edad de la madre y el hecho de que un niño nazca prematuro? ¿Cuál es el grupo de edad con mayor riesgo? edad &lt;- c(&quot;14-17&quot;,&quot;18-19&quot;,&quot;20-24&quot;,&quot;25-29&quot;,&quot;+30&quot;) casos &lt;- c(15,22,47,56,35) controles &lt;- c(16,25,62,122,18) ejercicio08 = data.frame(edad, casos, controles) Ejercicio 9. En el banco de datos siguiente se presentan los resultados de una encuesta realizada en 1998. A cada sujeto de una muestra de 300 adultos se le pidió que opinara sobre qué política consideraba adecuada implantar respecto al uso de tabaco en lugares públicos. Las opciones planteadas son: Opción 1: Sin restricciones Opción 2: Fumar sólo en áreas exclusivas Opción 3: No fumar nunca Opción 4: No opina ¿Hay alguna relación entre la actitud frente al tabaco y el nivel de estudios? nivel &lt;- c(&quot;Est. Superiores&quot;, &quot;Secundaria&quot;, &quot;Primaria&quot;) opt1 &lt;- c(5,15,15) opt2 &lt;- c(44,100,40) opt3 &lt;- c(23,30,10) opt4 &lt;- c(3,5,10) total &lt;- c(75,150,75) ejercicio09 = data.frame(nivel, opt1, opt2, opt3, opt4, total) "],["glmpoisson.html", "Unidad 13 GLM Poisson 13.1 Bancos de datos 13.2 Modelo Teórico 13.3 Estimación y bondad de ajuste del modelo 13.4 Selección del modelo 13.5 Diagnóstico 13.6 Predicción 13.7 Ejercicios", " Unidad 13 GLM Poisson Son frecuentes los datos discretos que provienen de conteos de sucesos que se producen por azar con cierta frecuencia y son modelizables en términos de tasas de incidencia que dependen de ciertas variables predictoras. Para modelizar este tipo de datos se utiliza la distribución de Poisson, \\(X \\sim Po(\\mu)\\), donde \\(\\mu\\) representa el número medio de ocurrencias, de forma que: \\[E(X) = \\mu \\quad \\text{ y } \\quad V(X) = \\mu.\\] El parámetro \\(\\mu\\) requiere una definición cuidadosa. A menudo es necesario describirlo como una tasa; por ejemplo, el número promedio de clientes que compran un particular producto de cada 100 clientes que ingresan a la tienda. De manera más general, la tasa se especifica en términos de unidades de “exposición” o en términos de años-persona ‘en riesgo,’ por ejemplo, el número de personas que sufren cierta enfermedad sobre el total de personas para un instante de tiempo determinado. El efecto de las variables predictoras sobre la respuesta se modeliza valorando su efecto sobre \\(\\mu\\). Sea \\(Y_1, Y_2,..., Y_n\\) un conjunto de variables aleatorias Poisson, donde \\(Y_i\\) representa el número de eventos observados a partir de la exposición \\(n_i\\) para el i-ésimo patrón de covariables. En esta situación el valor esperado de \\(Y_i\\) se puede escribir como: \\[E(Y_i) = \\mu_i = n_i \\lambda_i,\\] donde \\(\\lambda_i\\) representa la tasa de incidencia para el patrón i-ésimo. En este tipo de modelos es muy habitual trabajar con variables categóricas de tipo ordinal. Dichas variables pueden ser incorporadas en el modelo como factores pero en ocasiones interesa introducirlas como numéricas para captar las posibles tendencias de la respuesta conforme aumenta la relevancia del factor. Recordemos que una variable categórica ordinal se puede obtener siempre a partir de una variable de tipo numérico. Para poder hacer esto introducimos un código numérico artificial asociado con cada categoría. Disponemos de dos alternativas: Asignar un código continuo: 1, 2, 3,… donde los valores más bajos se asocian con los niveles más bajos de la variable categórica. Cuando la variable categórica viene dada en términos de un intervalo se puede usar el punto medio de dicho intervalo para establecer el código numérico. De hecho, en el análisis descriptivo inicial de los datos (sobre todo en los gráficos) esta forma de proceder permite analizar con más detalle la evolución del factor ordinal en la respuesta. 13.1 Bancos de datos A continuación se epresentan los ancos de datos con los que iremos trabajando. 13.1.1 Telas Se recogen los resultados de un experimento para determinar el efecto del tipo de lana (A o B) y la tensión (baja, media o alta) en el número de roturas de deformación en la fabricación de telas. Se recopilaron datos de nueve telares para cada combinación de configuraciones. Las variables consideradas son: breaks (número de roturas), wool (tipo de lana), tension (tensión de la lana). La pregunta de interés es si resulta posible predecir el número de roturas en función del tipo de lana y de la tensión. En este caso la exposición a riesgo es constante (\\(n_i =1\\)) de forma que \\(log(n_i) = 0\\) desapareciendo de la especificación del modelo. Por tanto, se considera que las posibles predictoras influyen directamente sobre \\(\\mu_i = breaks_i\\). En primer lugar cargamos los datos de la librería datasets roturas &lt;- warpbreaks str(roturas) ## &#39;data.frame&#39;: 54 obs. of 3 variables: ## $ breaks : num 26 30 54 25 70 52 51 26 67 18 ... ## $ wool : Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ tension: Factor w/ 3 levels &quot;L&quot;,&quot;M&quot;,&quot;H&quot;: 1 1 1 1 1 1 1 1 1 2 ... Para la representación gráfica y análisis de este banco de datos introducimos una variable codificada para el factor ordinal tension mediante un código continuo: # Creamos código asociado a cada nivel del factor y la variable asociada roturas &lt;- roturas %&gt;% mutate(t1 = ifelse(tension == &quot;L&quot;, 1, 0)) %&gt;% mutate(t2 = ifelse(tension == &quot;M&quot;, 2, 0)) %&gt;% mutate(t3 = ifelse(tension == &quot;H&quot;, 3, 0)) %&gt;% mutate(tension.num = t1 + t2 + t3) # Nos quedamos con las variables de interés roturas &lt;- dplyr::select(roturas,c(&quot;breaks&quot;, &quot;wool&quot;, &quot;tension&quot;, &quot;tension.num&quot;)) Representamos la incidencia (en este caso \\(n_i = 1\\)) que corresponde con la variable breaks, es decir, representamos el logaritmo de la incidencia con respecto a las predictoras, para valorar la linealidad del efecto. # Utilizamos las dos variables categóricas ggplot(roturas,aes(x = tension, y = log(breaks), color = wool)) + geom_boxplot() En el gráfico se aprecia cierta tendencia con la tensión, pero no tanto con el tipo de lana. Realizamos el gráfico de interacción con las medias para las combinaciones de ambos factores. ggplot(roturas, aes(x = tension, y = log(breaks), group = wool, color = wool)) + stat_summary(fun = mean, geom = &quot;point&quot;) + stat_summary(fun = mean, geom = &quot;line&quot;) Se puede ver un efecto conjunto entre tension y wool. Parece bastante claro que deberemos considerar un efecto de interacción para este modelo. De hecho, se aprecian curvas descendientes con tension (indicando que las telas sufren menos roturas a mayor tensión) no apreciándose efecto lineal lo que puede provocar que no se verifiquen las hipótesis del modelo, y que sea necesario introducir ciertas tendencias en las variables predictoras. En el tipo de lana resulta imposible hacer esto porque es una variable categórica nominal, pero si podríamos hacerlo con tension si consideramos la variable numérica construida a partir de ella. 13.1.2 Barcos En este banco de datos se analizan lo datos proporcionados por la aseguradora Lloyd’s con respecto al número de incidentes causados por las olas en cierto componente de los buques cargueros. El banco de datos contiene información sobre: type (el tipo de barco, codificado de A hasta E), year (el año de construcción del barco en los periodos 1960-64, 65-69, 70-74, 75-79 codificados como 60, 65, 70, 75), period (período de operación del barco 1960-74, 75-79 codificados como 60, 75), service (meses de servicio), incidents (número de incidentes sufridos). La pregunta de interés es si resulta posible predecir el número de incidentes en función de las predictoras consideradas. En este caso la exposición a riesgo no es constante, ya que cuanto mayor sea el tiempo de servicio de un barco parece más probable que sufra un incidente. En este caso \\(n_i = service_i\\) de forma que \\(log(n_i) = log(service_i)\\) remarcando el hecho de que el riesgo aumenta cuando lo hace el tiempo de servicio. El offset no se puede estimar ya que es fijo, y modelizamos la tasa de riesgo \\(\\lambda_i\\) con la información de las variables predictoras. En la práctica dicha tasa debe aproximarse a \\(\\lambda_i = incidents_i/service_i\\), por lo que representamos dicha variable con respecto a las predictoras para el planteamiento del modelo. Comenzamos con la lectura del banco de datos creando factores a partir de los códigos numéricos de las variables year y period. barcos &lt;- ships # Generamos factores a partir de los códigos numéricos barcos$year.f &lt;- as.factor(barcos$year) barcos$period.f &lt;- as.factor(barcos$period) Un análisis descriptivo inicial del banco de datos muestra que hay barcos que tienen 0 meses de servicio. Estos barcos deben ser eliminados del análisis, ya que al tratar de ajustar la tasa de incidentes dividiríamos por un valor de 0, lo que provocaría la imposibilidad de un ajuste adecuado. Seleccionamos todos los barcos con tiempo de servicio mayor que cero y obtenemos la tasa de incidencia a partir de la relación entre el número de incidentes y las horas de servicio de cada barco. barcos &lt;- barcos %&gt;% filter(service&gt;0) %&gt;% mutate(tasa = incidents/service) Realizamos el gráfico de la media del logaritmo de la tasa para type, year y period. En realidad trabajamos con los factores para representar adecuadamente el gráfico de interacción. ggplot(barcos, aes(x = year.f, y = log(tasa), group = period.f, color = period.f)) + stat_summary(fun = mean, geom = &quot;point&quot;) + stat_summary(fun = mean, geom = &quot;line&quot;) + facet_grid(~type) Se observa que los tipos de barco se comportan de forma diferente en cuanto a la tasa de incidentes. Los barcos del tipo “E” son los que tienen tasas más altas. En cuanto al año de fabricación y el periodo de funcionamiento varían con el tipo de barco. Mientras que para los tipos “A” y “B” se observan comportamientos muy similares no ocurre los mismo para el tipo “C.” De nuevo habrá que vigilar el efecto para asegurar la linealidad del predictor lineal asociado al GLM considerado. En este caso nos podemos plantear un modelo con tres predictoras de tipo factor y considerar sus posibles interacciones (lo que nos da un modelo bastante complejo), u optar por un modelo más sencillo donde consideramos year y period como numéricas. Obtenemos la tabla cruzada de ambos factores para ver si hay alguna combinación que no se da, y por tanto desechar el modelo de interacción al que darían lugar. table(barcos$year.f, barcos$period.f) ## ## 60 75 ## 60 5 4 ## 65 5 5 ## 70 5 5 ## 75 0 5 Se observa que la combinación year_f = 75 y period_f = 60 no tiene ningún dato. Si consideráramos un modelo con dicha interacción resultaría imposible obtener la estimación de dicho modelo. Para evitar ese problema, y dado el carácter ordinal de los factores, consideramos sus versiones numéricas para la estimación del modelo correspondiente. 13.2 Modelo Teórico El modelo lineal generalizado para variables aleatorias Poisson o más conocido como regresión de Poisson se puede especificar siguiendo la definición establecida en el punto anterior como: La distribución de cada variable aleatoria \\(Y_i\\) viene dada por \\[Y_i \\sim Po(\\mu_i)\\] El valor medio de cada variable viene dado por: \\[E(Y_i) = \\mu_i = n_i\\lambda_i\\] Si consideramos un conjunto \\(x_{i1}, x_{i2},...,x_{ip}\\) de \\(p\\) variables predictoras que pueden afectar el comportamiento de \\(Y_i\\) asumimos que: \\[\\lambda_i = exp(\\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{i2} + ...+ \\beta_p x_{ip}),\\] donde cada \\(\\beta\\) representa el efecto de la correspondiente variable predictora. En esta situación y tomando como función de enlace el logaritmo tenemos que: \\[log(E(Y_i)) = log(\\mu_i) = log(n_i\\lambda_i) = log(n_i) + log(\\lambda_i)= log(n_i) + \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{i2} + ...+ \\beta_p x_{ip}\\] donde tenemos la expresión del modelo lineal generalizado. La única diferencia de este modelo con los vistos hasta ahora es la inclusión de un término fijo en el modelo (\\(log(n_i)\\)) que actúa como “offset” y hace referencia al logaritmo de sujetos en riesgo para la combinación de predictoras correspondiente al índice \\(i\\). Este término se debe incorporar en la estimación del modelo como una constante para cada \\(i\\). Respecto de la interpretación de dichos coeficientes se puede demostrar que \\(exp(\\beta_j)\\) representa el riesgo relativo (\\(RR\\)) sobre la tasa de incidencia de los sucesos asociado a un incremento de una unidad en la covariable \\(x_j\\). Es similar a la interpretación que hacíamos en los modelos lineales, salvo el cambio de escala debido a la transformación logaritmo sobre la media de la respuesta. Para una variable de tipo numérico se define el riesgo relativo al incrementar una unidad el valor de la variable predictora \\(X\\) como: \\[RR(X) = \\frac{\\lambda(X = x+1)}{\\lambda(X = x+1)} = exp(\\beta_x)\\] mientras que el riesgo relativo para valorar el cambio entre dos niveles de una variable categórica (A y B) se define como: \\[RR(X_{AB}) = \\frac{\\lambda(X = B)}{\\lambda(X = A)} = exp(\\text{coeficiente asociado a B} - \\text{coeficiente asociado a A})\\] En ambos casos, el riesgo relativo aumenta cuando \\(RR &gt; 1\\) y disminuye cuando \\(RR &lt; 1\\). Tenemos el mismo riesgo cuando \\(RR = 1\\). De esta forma tenemos un indicador de cuanto aumenta la respuesta en función de las predictoras consideradas. 13.3 Estimación y bondad de ajuste del modelo Como hemos hecho hasta ahora, en un primer momento estimamos el modelo más complejo posible para proceder posteriormente con la selección de aquellos efectos que de verdad resultan significativos. Para la estimación utilizamos la función glm con las especificaciones siguientes: glm(modelo,family = poisson(), offset = value, data_set) La diferencia principal con los modelos de regresión logística es la introducción de los offsets en el ajuste del modelo. Si no disponemos de offsets no se especificarán en el ajuste del modelo. Para el estudio de bondad de ajuste utilizamos el test \\(\\chi^2\\) basado en la deviance del modelo. En este caso dejamos los calculo para el lector. También podemos saber la capacidad explicativa (explained deviance) del modelo que se puede obtener con la función summary(m) donde m es el modelo que deseamos estudiar. 13.3.1 Ejemplos Procedemos con el análisis de cada uno de los ejemplos. 13.3.1.1 Telas Para este banco de datos ajustamos dos modelos completos considerando la tensión como factor (tension) o como variable numérica (tension.num). 13.3.1.1.1 Modelo con tension Para este banco de datos ajustamos dos modelos completos considerando la tensión como factor o como variable numérica. Comenzamos con el modelo considerando todas las predictoras como factores. Consideramos tanto los efectos asociados a cada factor como la posible interacción entre ellos. En este caso no hay offsets. El modelo propuesto es: \\[breaks \\sim wool*tension\\] que se puede ajustar mediante fit.telas.cat &lt;-glm(breaks ~ wool*tension, family = poisson(), data = roturas) Al igual que ocurría con los modelos de regresión logística hacemos uso de la función tab_model para obtener las estimaciones del predictor lineal y de la tasa de incidencia. Analizamos en primer lugar el predictor lineal. tab_model(fit.telas.cat, transform = NULL, show.r2 = FALSE)   breaks Predictors Log-Mean CI p (Intercept) 3.80 3.70 – 3.89 &lt;0.001 wool [B] -0.46 -0.61 – -0.30 &lt;0.001 tension [M] -0.62 -0.79 – -0.45 &lt;0.001 tension [H] -0.60 -0.76 – -0.43 &lt;0.001 wool [B] * tension [M] 0.64 0.40 – 0.88 &lt;0.001 wool [B] * tension [H] 0.19 -0.07 – 0.44 0.147 Observations 54 Los coeficientes del modelo resultan significativos salvo en la combinación wool B y tension H. Ajustamos el modelo sin interacción de forma que las ecuaciones del predictor lineal para este nuevo modelo son: \\[\\left\\{\\begin{array}{ll} log(breaks)_{woolA;tensionL} &amp; = 3.80 \\\\ log(breaks)_{woolA;tensionM} &amp; = 3.80 - 0.62 = 3.18 \\\\ log(breaks)_{woolA;tensionH} &amp; = 3.80 - 0.60 = 3.20 \\\\ log(breaks)_{woolB;tensionL} &amp; = 3.80 - 0.46 = 3.34 \\\\ log(breaks)_{woolB;tensionM} &amp; = 3.80 - 0.46 - 0.62 + 0.64 = 3.36 \\\\ log(breaks)_{woolB;tensionH} &amp; = 3.80 - 0.46 - 0.60 + 0.19 = 2.93 \\\\ \\end{array}\\right.\\] El proceso de estimación nos proporciona que el mayor número de roturas se produce para la combinación wool = A y tension = L, mientras que el menor número se estima para la combinación wool = B y tension = H. Obtenemos ahora las tasas de incidencia de rotura asociados con este modelo: tab_model(fit.telas.cat, show.r2 = FALSE)   breaks Predictors Incidence Rate Ratios CI p (Intercept) 44.56 40.34 – 49.06 &lt;0.001 wool [B] 0.63 0.54 – 0.74 &lt;0.001 tension [M] 0.54 0.46 – 0.63 &lt;0.001 tension [H] 0.55 0.47 – 0.65 &lt;0.001 wool [B] * tension [M] 1.89 1.49 – 2.41 &lt;0.001 wool [B] * tension [H] 1.21 0.94 – 1.56 0.147 Observations 54 Identificamos de esta forma los efectos del modelo que producen un mayor riesgo relativo (valores mayores que 1) con respecto a la combinación que se utiliza como referencia en el modelo que es wool = A y tension = L. En realidad la tabla presenta los valores de \\(exp(\\beta)\\) para cada uno de los efectos del modelo con las que podemos obtener las tasas de incidencia: \\[\\left\\{\\begin{array}{ll} breaks_{woolA;tensionL} &amp; = 44.56 \\\\ breaks_{woolA;tensionM} &amp; = 44.56 * 0.54 = 24.06 \\\\ breaks_{woolA;tensionH} &amp; = 44.56 * 0.55 = 24.51 \\\\ breaks_{woolB;tensionL} &amp; = 44.56 * 0.63 =28.07\\\\ breaks_{woolB;tensionM} &amp; = 44.56 * 0.63 * 0.54 * 1.89 = 28.65 \\\\ breaks_{woolB;tensionH} &amp; = 44.56 * 0.63 * 0.55 * 1.21 = 18.68 \\\\ \\end{array}\\right.\\] A partir de las tasas de incidencia es posible estimar los riesgos relativos para la combinación de los dos factores. Comparamos las combinaciones {woolA;tensionL} y {woolA;tensionH} de forma que el riesgo relativo es: \\[ RR_{(A-L; A-H)} = \\frac{44.56}{24.51} = 1.81 \\] Se concluye que el riesgo de rotura de la combinación {woolA;tensionL} es casi el doble que el de la combinación {woolA;tensionH}. 13.3.1.1.2 Modelo con tension.num Ajustamos ahora el modelo asumiendo la variable tensión con su código numérico (para valorar el efecto ordinal del factor). El modelo propuesto es: \\[breaks \\sim wool*tension.num\\] Ajustamos el modelo y estudíamos las ecuaciones de estimación obtenidas fit.telas.num &lt;-glm(breaks ~ wool*tension.num, family = poisson(), data = roturas) tab_model(fit.telas.num, transform = NULL, show.r2 = FALSE)   breaks Predictors Log-Mean CI p (Intercept) 4.06 3.89 – 4.22 &lt;0.001 wool [B] -0.46 -0.71 – -0.21 &lt;0.001 tension num -0.33 -0.41 – -0.24 &lt;0.001 wool [B] * tension num 0.14 0.01 – 0.27 0.029 Observations 54 Todos los coeficientes estimados resultan significativos y las ecuaciones de estimación vienen dadas por: \\[\\left\\{\\begin{array}{ll} log(breaks_{woolA}) &amp; = 4.06 - 0.33*tension.num \\\\ log(breaks_{woolB}) &amp; = 3.60 - 0.19*tension.num\\\\ \\end{array}\\right.\\] Dado que los coeficientes asociados a tension.num son negativos, el efecto de la tensión es menos relevante para wool = A que para wool = B, de forma que el nivel de roturas disminuye al aumentar la tensión. Obtenemos las incidencias asociadas con el modelo tab_model(fit.telas.num, show.r2 = FALSE)   breaks Predictors Incidence Rate Ratios CI p (Intercept) 57.72 48.79 – 68.07 &lt;0.001 wool [B] 0.63 0.49 – 0.81 &lt;0.001 tension num 0.72 0.66 – 0.78 &lt;0.001 wool [B] * tension num 1.15 1.01 – 1.30 0.029 Observations 54 con estimaciones para cada nivel de wool: \\[\\left\\{\\begin{array}{ll} breaks_{woolA} &amp; = 57.72 *0.72^{tension.num} \\\\ breaks_{woolB} &amp; = (57.72*0.63) *(0.72*1.15)^{tension.num} = 36.36*0.83^{tension.num}\\\\ \\end{array}\\right.\\] de forma que el riesgo relativo entre los dos tipos de wool viene dado por: \\[ RR_{(A;B)} = \\frac{57.72*0.72^{tension.num}}{36.36*0.83^{tension.num}} = 1.59*0.87^{tension.num} \\] cuyos valores son 1.38, 1.20 y 1.05 para los valores de tension 1, 2, y 3 respectivamente. Esto implica que el riesgo de rotura entre wool = A y wool = B se iguala (tiende a 1) cuando aumenta la tensión, aunque siempre es superior en A que en B. Otras alternativas a este modelo serían considerar un modelo polinómico con tension.num para capturar la curvas observadas en los gráficos de medias o planteara un modelo de suavizado con ella y con interacción con wool. En estos materiales no exploramos estas posibilidades. En el apartado de selección del modelo valoraremos los dos modelos construidos para determinar cual de ellos es mejor. 13.3.1.2 Barcos Ajustamos el modelo utilizando las variables con los códigos numéricos en lugar de los factores. En este caso si disponemos de offset y el modelo planteado viene dado por: \\[incidents \\sim offset(service) + type *(year + period)\\] En realidad la estimación de este modelo nos proporciona las tasas de incidentes \\(\\lambda_i = incidents_i/service_i\\). Realizamos el ajuste del modelo a partir del cual podemos obtener las ecuaciones de estimación por los diferentes niveles de type: fit.barcos.num &lt;-glm(incidents ~ type *(year + period), family = poisson(), offset = log(service), data = barcos) tab_model(fit.barcos.num, transform = NULL, show.r2 = FALSE)   incidents Predictors Log-Mean CI p (Intercept) -9.24 -15.48 – -3.32 0.003 type [B] -2.27 -8.44 – 4.20 0.480 type [C] -2.94 -15.11 – 8.30 0.620 type [D] 1.54 -10.03 – 11.47 0.773 type [E] 13.40 3.63 – 23.14 0.007 year 0.04 -0.05 – 0.13 0.440 period 0.02 -0.03 – 0.08 0.496 type [B] * year 0.01 -0.08 – 0.11 0.756 type [C] * year 0.13 -0.05 – 0.32 0.167 type [D] * year -0.06 -0.21 – 0.10 0.442 type [E] * year -0.20 -0.35 – -0.05 0.009 type [B] * period 0.01 -0.05 – 0.06 0.723 type [C] * period -0.09 -0.20 – 0.00 0.065 type [D] * period 0.03 -0.08 – 0.17 0.591 type [E] * period 0.01 -0.06 – 0.09 0.762 Observations 34 Las ecuaciones para las diferentes tasas son: \\[\\left\\{\\begin{array}{ll} log(\\lambda_{typeA}) &amp; = - 9.24 + 0.04*year + 0.02*period \\\\ log(\\lambda_{typeB}) &amp; = - 11.51 + 0.05*year + 0.03*period \\\\ log(\\lambda_{typeC}) &amp; = - 12.18 + 0.17*year - 0.07*period \\\\ log(\\lambda_{typeD}) &amp; = - 7.70 - 0.02*year + 0.05*period \\\\ log(\\lambda_{typeE}) &amp; = 4.16 - 0.16*year + 0.03*period \\\\ \\end{array}\\right.\\] Sin embargo, dado que el modelo presenta muchos coeficientes que parecen no significativos, dejaremos la interpretación de este modelo hasta la selección del modelo definitivo. 13.4 Selección del modelo Para la construcción del mejor modelo utilizaremos los mismos procedimientos que presentamos en la unidad anterior basados en los procedimientos secuenciales con el estadístico AIC. 13.4.1 Ejemplos Estudiamos a continuación cada uno de los ejemplos. 13.4.1.1 Datos de telas En este caso realizamos la selección tanto en el modelo con la variable tensión como factor y como numérica, y elegimos como mejor modelo el que tenga un menor valor de AIC. Comenzamos con la selección del modelo con factor # Selección del modelo stats::step(fit.telas.cat) ## Start: AIC=468.97 ## breaks ~ wool * tension ## ## Df Deviance AIC ## &lt;none&gt; 182.31 468.97 ## - wool:tension 2 210.39 493.06 ## ## Call: glm(formula = breaks ~ wool * tension, family = poisson(), data = roturas) ## ## Coefficients: ## (Intercept) woolB tensionM tensionH woolB:tensionM ## 3.7967 -0.4566 -0.6187 -0.5958 0.6382 ## woolB:tensionH ## 0.1884 ## ## Degrees of Freedom: 53 Total (i.e. Null); 48 Residual ## Null Deviance: 297.4 ## Residual Deviance: 182.3 AIC: 469 No se elimina ningún efecto del modelo y el AIC correspondiente es de 468.97. Procedemos ahora con el modelo con tensión como variable numérica. # Selección del modelo stats::step(fit.telas.num) ## Start: AIC=489.55 ## breaks ~ wool * tension.num ## ## Df Deviance AIC ## &lt;none&gt; 206.89 489.55 ## - wool:tension.num 1 211.63 492.30 ## ## Call: glm(formula = breaks ~ wool * tension.num, family = poisson(), ## data = roturas) ## ## Coefficients: ## (Intercept) woolB tension.num woolB:tension.num ## 4.0555 -0.4620 -0.3279 0.1399 ## ## Degrees of Freedom: 53 Total (i.e. Null); 50 Residual ## Null Deviance: 297.4 ## Residual Deviance: 206.9 AIC: 489.6 De nuevo no se elimina ningún efecto pero el AIC es de 489.55, de forma que entre los dos modelos nos quedaríamos con el que toma la variable tension como factor. Recordamos las ecuaciones de estimación del número de roturas obtenidas en el apartado anterior, que venían dadas para cada combinación por: \\[\\left\\{\\begin{array}{ll} breaks_{woolA;tensionL} &amp; = 44.56 \\\\ breaks_{woolA;tensionM} &amp; = 24.06 \\\\ breaks_{woolA;tensionH} &amp; = 24.51 \\\\ breaks_{woolB;tensionL} &amp; = 28.07\\\\ breaks_{woolB;tensionM} &amp; = 28.65 \\\\ breaks_{woolB;tensionH} &amp; = 18.68 \\\\ \\end{array}\\right.\\] En la tabla siguiente se presentan los riesgos relativos asociados a la comparación entra wool = A y wool = B. \\[\\left\\{\\begin{array}{ll} RR\\left(\\frac{wool A; tension L}{wool B; tension L}\\right) = 44.56/28.07 = 1.59\\\\ RR\\left(\\frac{wool A; tension L}{wool B; tension M}\\right) = 44.56/28.65 = 1.56\\\\ RR\\left(\\frac{wool A; tension L}{wool B; tension H}\\right) = 44.56/18.68 = 2.39\\\\ RR\\left(\\frac{wool A; tension M}{wool B; tension L}\\right) = 24.06/28.07 = 0.86\\\\ RR\\left(\\frac{wool A; tension M}{wool B; tension M}\\right) = 24.06/28.65 = 0.84\\\\ RR\\left(\\frac{wool A; tension M}{wool B; tension H}\\right) = 24.06/18.68 = 1.29\\\\ RR\\left(\\frac{wool A; tension H}{wool B; tension L}\\right) = 24.51/28.07 = 0.87\\\\ RR\\left(\\frac{wool A; tension H}{wool B; tension M}\\right) = 24.51/28.65 = 0.86\\\\ RR\\left(\\frac{wool A; tension H}{wool B; tension H}\\right) = 24.51/18.68 = 1.31\\\\ \\end{array}\\right.\\] ¿Cómo interpretamos los valores obtenidos? Comparamos ahora para un mismo valor de wool atendiendo al orden del factor: \\[\\left\\{\\begin{array}{ll} RR\\left(\\frac{wool A; tension H}{wool A; tension M}\\right) = 24.51/24.06 = 1.02\\\\ RR\\left(\\frac{wool A; tension M}{wool A; tension L}\\right) = 24.06/44.56 = 0.54\\\\ \\end{array}\\right.\\] Mientras que el riesgo de sufrir una rotura para wool = A es prácticamente el mismo para los valores H y M de tensión, este se duplica cuando comparamos los valores M y L. ¿Qué podemos decir si utilizamos wool = B? 13.4.1.2 Datos de barcos Comenzamos con la selección del modelo # Selección del modelo stats::step(fit.barcos.num) ## Start: AIC=167 ## incidents ~ type * (year + period) ## ## Df Deviance AIC ## - type:period 4 45.138 165.00 ## &lt;none&gt; 39.136 167.00 ## - type:year 4 54.046 173.91 ## ## Step: AIC=165 ## incidents ~ type + year + period + type:year ## ## Df Deviance AIC ## &lt;none&gt; 45.138 165.00 ## - type:year 4 59.375 171.24 ## - period 1 54.589 172.46 ## ## Call: glm(formula = incidents ~ type + year + period + type:year, family = poisson(), ## data = barcos, offset = log(service)) ## ## Coefficients: ## (Intercept) typeB typeC typeD typeE year ## -9.40739 -1.99170 -4.80174 2.57742 13.61537 0.03166 ## period typeB:year typeC:year typeD:year typeE:year ## 0.02474 0.02134 0.06103 -0.03907 -0.19193 ## ## Degrees of Freedom: 33 Total (i.e. Null); 23 Residual ## Null Deviance: 146.3 ## Residual Deviance: 45.14 AIC: 165 El proceso de selección elimina únicamente la interacción entre tipo y periodo, de forma que el modelo final viene dado por: fit.barcos.num &lt;-glm(incidents ~ type + year + period + type:year, family = poisson(), offset = log(service), data = barcos) Las estimaciones del predictor lineal vienen dadas por: tab_model(fit.barcos.num, transform = NULL, show.r2 = FALSE)   incidents Predictors Log-Mean CI p (Intercept) -9.41 -15.48 – -3.63 0.002 type [B] -1.99 -7.99 – 4.28 0.524 type [C] -4.80 -16.45 – 5.87 0.395 type [D] 2.58 -7.50 – 11.82 0.597 type [E] 13.62 3.95 – 23.23 0.006 year 0.03 -0.05 – 0.12 0.461 period 0.02 0.01 – 0.04 0.002 type [B] * year 0.02 -0.07 – 0.11 0.632 type [C] * year 0.06 -0.09 – 0.23 0.456 type [D] * year -0.04 -0.17 – 0.10 0.569 type [E] * year -0.19 -0.33 – -0.05 0.007 Observations 34 de forma que las ecuaciones de estimación del logaritmo de la tasa de incidencia para cada combinación de tipo de barco vienen dadas por: \\[\\left\\{\\begin{array}{ll} log(\\lambda_{typeA}) &amp; = - 9.41 + 0.03*year + 0.02*period \\\\ log(\\lambda_{typeB}) &amp; = - 11.40 + 0.05*year + 0.02*period \\\\ log(\\lambda_{typeC}) &amp; = - 14.21 + 0.09*year + 0.02*period \\\\ log(\\lambda_{typeD}) &amp; = - 6.83 - 0.01*year + 0.02*period \\\\ log(\\lambda_{typeE}) &amp; = 4.21 - 0.16*year + 0.02*period \\\\ \\end{array}\\right.\\] Dado que el coeficiente asociado a period es el mismo para todos los tipos de barco (efecto de interacción eliminado del modelo), el riesgo entre dos tipos de barco se asocia directamente con el año de fabricación y la interceptación (donde se incluye el tipo de barco también). Podemos obtener los riesgos a partir de las ecuaciones anteriores. Por ejemplo, vamos a obtener el riesgo relativo para los tipos C y E: \\[ RR\\left(\\frac{type C}{type E}\\right) = \\frac{exp(- 14.21 + 0.09*year + 0.02*period)}{exp(4.21 - 0.16*year + 0.02*period)} = exp(-18.42 + 0.27*year) \\] que podemos representar gráficamente: # Asignamos valores al año secyear &lt;- 60:75 # Calculamos el riesgo entre C y E como el cociente de tasas estimadas rr &lt;- exp(-14.21 + 0.09*secyear)/exp(4.21 -0.16*secyear) riesgos &lt;- data.frame(secyear,rr) # Gráfico ggplot(riesgos,aes(x = secyear, y = rr)) + geom_line() + geom_hline(yintercept = 1, color = &quot;red&quot;) + labs(x =&quot;Año&quot;, y = &quot;Riesgo relativo&quot;) Se aprecia como el riesgo relativo entre los tipos de barco C y E aumenta con el año de fabricación del barco, pero mientras que hasta el año 73 o 74 hay un mayor riesgo en los barcos de tipo E que en los de tipo C, en los años anteriores es al contrario. Se ha utilizado un línea horizontal en el 1 para identificar la igualdad de riesgo relativo. En el apartado de predicción representaremos la incidencia correspondiente a todas las posibles combinaciones de predictoras. 13.5 Diagnóstico Las herramientas de diagnóstico para este tipo de modelos son las mismas que el caso de los GLM con respuesta binaria. Los gráficos que vamos a utilizar son: Residuos vs Ajustados (predictor lineal) Residuos vs variables en el modelo (predictor lineal) Valores influyentes 13.5.1 Ejemplos Procedemos con el diagnóstico de los modelos obtenidos hasta el momento. En caso de encontrar problemas con alguno de ellos, procederemos como en casos anteriores. 13.5.1.1 Datos de telas Obtenemos las cantidades de interés y realizamos los gráficos correspondientes. Obtenemos todas las cantidades de interés del modelo # Obtención de valores para el diagnóstico diagnostico &lt;- fortify(fit.telas.cat) Realizamos el gráfico de residuos versus ajustados: #Gráfico de residuos vs ajustados (predictor lineal) ggplot(diagnostico, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_hline(yintercept = 0, color = &quot;red&quot;) + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) Dado que las dos predictoras son factores el gráfico que aparece es bastante natural ya que solo resulta predecir cuatro valores posibles, que corresponden con las cuatro combinaciones de los dos factores. No se aprecian comportamientos extraño en cuanto a la tendencia o la homocedasticidad. Realizamos ahora los gráficos versus predictoras. # Gráficos de residuos vs predictoras (preditor lineal) plot_model(fit.telas.cat, type = &quot;resid&quot;, show.data = TRUE, ci.lvl = NA) + geom_point(color = &quot;black&quot;, size = 0.8) No se aprecian comportamientos que hagan dudar del incumplimiento de las hipótesis. El modelo obtenido es adecuado y puede ser usado para predecir el número de roturas debido a los factores considerados. 13.5.1.2 Datos de barcos Obtenemos las cantidades de interés y realizamos los gráficos correspondientes. # Obtención de valores para el diagnóstico diagnostico &lt;- fortify(fit.barcos.num) Realizamos el gráfico de residuos versus ajustados: #Gráfico de residuos vs ajustados (predictor lineal) ggplot(diagnostico, aes(x = .fitted, y = .stdresid)) + geom_point() + geom_hline(yintercept = 0, color = &quot;red&quot;) + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) Los residuos se reparten aleatoriamente pero parece apreciarse cierto efecto de embudo con los valores ajustados. Realizamos los gráficos con respecto a las predictoras: # Gráficos de residuos vs predictoras (preditor lineal) plot_model(fit.barcos.num, type = &quot;resid&quot;, show.data = TRUE, ci.lvl = NA) + geom_point(color = &quot;black&quot;, size = 0.8) Mientras que respecto de period y type no se aprecia ningún problema, si existe cierta tendencia con respecto a year. Se podría optar por un modelo polinómico o plantear directamente un suavizado con es variable. Se propone utiliza el modelo de suavizado, pero dado que tenemos pocos datos para tipo de barco, rebajamos el valor del número de nodos a 5 para conseguir el ajuste. Consideramos un modelo con interacción type:period y otro sin interacción para valorar cual de ellos se comporta mejor mediante el estadístico AIC: # Modelo con interacción type:period M1 &lt;- gam(incidents ~ type + period + s(year, k = 5, m = 2, bs = &quot;ps&quot;, by = type) + type:period, family = poisson(), offset = log(service), data = barcos) # Modelo sin interacción type:period M2 &lt;- gam(incidents ~ type + period + s(year, k = 5, m = 2, bs = &quot;ps&quot;, by = type), family = poisson(), offset = log(service), data = barcos) # Comparamos ambos modelos AIC(M1, M2) Tabla 13.1: dfAIC 17145 13143 El modelo seleccionado es el que no tiene la interacción. Empezamos el diagnóstico de dicho modelo asignando el modelo obtenido y realizamos el diagnóstico. # Asignamos el modelo fit.barcos.num &lt;- M2 # Gráficos de diagnóstico gam.check(fit.barcos.num) ## ## Method: UBRE Optimizer: outer newton ## full convergence after 10 iterations. ## Gradient range [-2.348054e-07,1.788437e-12] ## (score 0.3384798 &amp; scale 1). ## Hessian positive definite, eigenvalue range [1.827615e-07,0.02021138]. ## Model rank = 26 / 26 ## ## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may ## indicate that k is too low, especially if edf is close to k&#39;. ## ## k&#39; edf k-index p-value ## s(year):typeA 4.00 1.17 1.17 0.81 ## s(year):typeB 4.00 1.97 1.17 0.83 ## s(year):typeC 4.00 1.00 1.17 0.86 ## s(year):typeD 4.00 1.87 1.17 0.81 ## s(year):typeE 4.00 1.00 1.17 0.78 Se observan dos observaciones alejadas del resto por lo que se podría considerar su eliminación. Sin embargo, dado que el banco de datos contiene pocas observaciones podríamos tener problemas para ajustar el modelo si las eliminamos. Puesto que el test del suavizado no presenta ningún problema, utilizaremos el modelo obtenido como base para la predicción. El problema con las funciones de suavizado es que resulta más complicado la evaluación de los riesgos relativos, ya que al no disponer de una forma específica para las predictoras que forman parte del suavizado, no podemos obtener directamente dicho riesgo. En el apartado de predicción veremos como estimar dichos riesgos. 13.6 Predicción A continuación se presentan los resultados de predicción para los bancos de datos que hemos venido trabajando. Antes de proceder con la predicción para este tipo de modelos es necesario realizar la siguiente anotación. La inclusión de offset altera en cierta forma el proceso de predicción. En esta situación solo es posible predecir las tasas asociadas al modelo propuesto y no la predicción de la variable original. Podemos obtener el valor estimado en la escala de la variable original sin más que multiplicar las tasas predichas por un valor del offset prefijado. 13.6.1 Bancos de datos Detallamos el procedimiento de predicción en cada ejemplo. 13.6.1.1 Datos de telas En este caso no tenemos offset y podemos realizar la predicción sin problemas. Obtenemos tanto el gráfico como la tabla de predicción. # Obtenemos el objeto de predicción gpred &lt;- plot_model(fit.telas.cat,&quot;pred&quot;, terms=c(&quot;wool&quot;,&quot;tension&quot;), axis.labels = c(&quot;Wool&quot;, &quot;Número de roturas&quot;), title = &quot;Predicción del numéro medio de roturas&quot;) gpred$data Tabla 13.2: xpredictedstd.errorconf.lowconf.highgroupgroup_col 144.60.049940.449.1LL 124&nbsp;&nbsp;0.068&nbsp;21&nbsp;&nbsp;27.4MM 124.60.067321.528&nbsp;&nbsp;HH 228.20.062725&nbsp;&nbsp;31.9LL 228.80.062125.532.5MM 218.80.076916.121.8HH gpred El cociente entre los valores predichos de la tabla nos permite realizar una evaluación del riesgo de dos combinaciones de los factores. El gráfico nos permite realizar una comparación aproximada del riesgo, y una evaluación de la combinación que produce un mayor número de roturas (wool = A y tension = L), y la que menos (wool = B y tension = H). 13.6.1.2 Datos de barcos En este caso la predicción hace referencia a las tasas de incidencia del número de incidentes y no sobre el número de incidentes. # Obtenemos el objeto de predicción gpred &lt;- plot_model(fit.barcos.num,&quot;pred&quot;, terms=c(&quot;year&quot;,&quot;period&quot;,&quot;type&quot;), ci.lvl = NA, axis.labels = c(&quot;&quot;, &quot;Tasa de incidentes&quot;), title = &quot;Predicción de la tasa de incidencia de acidentes&quot;) gpred$data Tabla 13.3: xpredictedgroupfacetgroup_col 600.00209&nbsp;60A60 600.00101&nbsp;60B60 600.00077160C60 607.03e-1060D60 600.0197&nbsp;&nbsp;60E60 600.00307&nbsp;75A75 600.00148&nbsp;75B75 600.00113&nbsp;75C75 601.03e-0975D75 600.029&nbsp;&nbsp;&nbsp;75E75 650.00276&nbsp;60A60 650.00182&nbsp;60B60 650.00122&nbsp;60C60 653.07e-0560D60 650.00883&nbsp;60E60 650.00405&nbsp;75A75 650.00266&nbsp;75B75 650.00179&nbsp;75C75 654.5e-05&nbsp;75D75 650.013&nbsp;&nbsp;&nbsp;75E75 700.00337&nbsp;60A60 700.00217&nbsp;60B60 700.00194&nbsp;60C60 700.00611&nbsp;60D60 700.00395&nbsp;60E60 700.00495&nbsp;75A75 700.00318&nbsp;75B75 700.00285&nbsp;75C75 700.00897&nbsp;75D75 700.00579&nbsp;75E75 750.00376&nbsp;60A60 750.00181&nbsp;60B60 750.00308&nbsp;60C60 750.00134&nbsp;60D60 750.00177&nbsp;60E60 750.00552&nbsp;75A75 750.00265&nbsp;75B75 750.00451&nbsp;75C75 750.00196&nbsp;75D75 750.00259&nbsp;75E75 gpred El gráfico de predicción nos permite apreciar los cambios en la tasa de incidencia para la combinación de las predictoras consideradas (incluso con el suavizado introducido). Los tipos de barco tienen perfiles similares al comparar por periodo, pero su evolución es diferente en cuanto al año de fabricación. En casi todos los tipos de barco hay una evolución ligeramente creciente, salvo en el tipo D donde hay un descenso en los últimos años, y en el tipo E que hay un descenso. Para obtener el número de incidentes podemos fijar un valor de tiempo de servicio y multiplicarlo por los valores predichos obtenidos en la tabla. 13.7 Ejercicios Ejercicio 1. En el banco de datos siguiente aparecen los datos correspondientes a un pequeño experimento (grupo) en el que 7 de un total de 16 ratones fueron aleatoriamente seleccionados para recibir un nuevo tratamiento médico. Los 9 ratones restantes fueron asignados a un grupo control en el que no se administró ningún tipo de tratamiento. El objetivo del tratamiento era prolongar el tiempo de supervivencia (tiempo) después de una operación quirúrgica. La tabla muestra los tiempos de supervivencia (en días) tras la operación para los 16 ratones. El tratamiento, ¿prolongaba la vida de los ratones tras la operación? grupo &lt;- c(rep(&quot;T&quot;,7),rep(&quot;C&quot;,9)) tiempo &lt;- c(94,38,23,197,99,16,141,52,104,146,10,51,30,40,27,46) ejercicio01 &lt;- data.frame(grupo,tiempo) Ejercicio 2. Los datos siguientes contienen el tiempo de supervivencia, que es el tiempo (tiempo) hasta la muerte (en semanas) desde el diagnóstico de leucemia, y el número inicial de células blancas en sangre (lcelulas en escala log10), para un grupo de 17 sujetos que fueron diagnosticados de leucemia. ¿Cuáles son tus conclusiones sobre la utilidad de saber el número de células blancas en la sangre para predecir el tiempo de supervivencia? ¿Cuál es la probabilidad de sobrevivir de un paciente con 5000 células blancas en la sangre? lcelulas &lt;- c(3.36,2.88,3.63,3.41,3.78,4.02,4.00,4.72,5.00,4.23, 3.73,3.85,3.97,4.51, 4.54,5.00,5.00) tiempo &lt;- c(65,156,100,134,16,108,121,5,65,4,39,143,56,26,22,1,1) ejercicio02 &lt;- data.frame(lcelulas,tiempo) Ejercicio 3. Los datos de este ejercicio provienen de un famoso estudio realizado por Sir Richard Doll y colegas. En 1951, a todos los médicos británicos se les envió un breve cuestionario sobre si fumaban o no. Desde entonces, la información sobre la causa de la muerte ha sido recogida desde entonces. El conjunto de datos muestra el número de muertes por enfermedad coronaria (deaths), si eran o no fumadores (smoking), el grupo de edad al fallecimiento (age), y el número total de personas-años de observación en el momento del análisis (person-years). Para aprovechar el carácter ordinal de la variable age se sugiere utilizar una codificación numérica que identifique con un 1 al grupo de menor edad y con un 5 al grupo de mayor edad (otra opción sería utilizar el punto medio del intervalo). Representa la tasa de muertes por 100000 habitantes-año para el grupo de edad identificando si eran o no fumadores y ajusta el modelo que consideres más oportuno atendiendo a ese comportamiento. Los datos aparecen en Breslow and Day (1987). require(dobson) ## Loading required package: dobson ## ## Attaching package: &#39;dobson&#39; ## The following object is masked from &#39;package:survival&#39;: ## ## leukemia ## The following object is masked from &#39;package:lattice&#39;: ## ## melanoma ## The following object is masked from &#39;package:MASS&#39;: ## ## housing ejercicio03 &lt;- doctors # Construimos el vector numérico de edad ejercicio03$age_num &lt;- c(1,2,3,4,5,1,2,3,4,5) ejercicio03$age_num2 &lt;- c(40,50,60,70,80,40,50,60,70,80) Ejercicio 4. Los datos de este ejercicio contienen el número de pólizas de seguros de coches (n) y el número de reclamaciones o partes recibidos (y). Se registra además: el distrito donde se contrato la póliza (district), que toma valor 1 para las contratadas en la ciudad de Londres y 0 para el resto de ciudades, el nivel de la póliza contratada (car), registrada con un valor numérico donde 1 representa la categoría más baja y 4 la más alta, el grupo de edad del conductor (age), registrada con un valor numérico donde 1 indica los conductores de menor edad y 4 los de mayor edad. Estas dos últimas variables son categóricas ordinales que se codifican numéricamente para indicar el carácter ordinal de dicho factor. Analiza los datos teniendo en cuenta: Debes calcular el ratio entre pólizas y asegurados para cada categoría de las variables predictoras y representar sus posibles efectos. Ajusta un modelo adecuado a la información recogida y explica las conclusiones obtenidas. Los datos provienen de Baxter, Coutts, and Ross (1980). require(dobson) ejercicio04 &lt;- insurance ejercicio04$car_f &lt;- as.factor(ejercicio04$car) ejercicio04$age_f &lt;- as.factor(ejercicio04$age) Ejercicio 5. En este ejemplo están recogidos los datos de un estudio sobre 44 médicos que trabajaban en el servicio de urgencias de un hospital Le (1998). El objetivo del estudio era determinar qué variables estaban relacionadas con el número de quejas que recibían los médicos a lo largo de un año. Para ello se controló. para cada médico el número de consultas que realizó a lo largo del año (consultas) y el número de quejas recibidas (quejas). Se tuvieron en cuanta además otras posibles características que podrían influir como: el salario anual del médico (en dólares por hora) (ingresos) la carga de trabajo (en horas) en el servicio de urgencias (horas) el sexo del médico (H = hombre y M = Mujer) (sexo) si el médico recibió o no entrenamiento como residente en el servicio de urgencias Representa la tasa de quejas para cada posible variable predictora y obtén el modelo correspondiente a estos datos que te permita responde sobre la influencia de cada una de las características recogidas en el número de quejas recibidas. consultas &lt;- c(2014, 3091, 879, 1780, 3646, 2690, 1864, 2782, 3071, 1502, 2438, 2278, 2458, 2269, 2431, 3010, 2234, 2906, 2043, 3022, 2123, 1029, 3003, 2178, 2504, 2211, 2338, 3060, 2302, 1486, 1863, 1661, 2008, 2138, 2556, 1451, 3328, 2927, 2701, 2046, 2548, 2592, 2741, 3763) quejas &lt;- c(2, 3, 1, 1, 11, 1, 2, 6, 9, 3, 2, 2, 5, 2, 7, 2, 5, 4, 2, 7, 5, 1, 3, 2, 1, 1, 6, 2, 1, 1, 1, 0, 2, 2, 5, 3, 3, 8, 8, 1, 2, 1, 1, 10) residente &lt;- c(&quot;Si&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;, &quot;No&quot;, &quot;Si&quot;, &quot;Si&quot;) sexo &lt;- c(&quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;H&quot;, &quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;H&quot;, &quot;M&quot;, &quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;H&quot;, &quot;M&quot;, &quot;H&quot;) ingresos &lt;-c(263.03, 334.94, 206.42, 226.32, 288.91, 275.94, 295.71, 224.91, 249.32, 269, 225.61, 212.43, 211.05, 213.23, 257.3, 326.49, 290.53, 268.73, 231.61, 241.04, 238.65, 287.76, 280.52, 237.31, 218.7, 250.01, 251.54, 270.52, 247.31, 277.78, 259.68, 260.92, 240.22, 217.49, 250.31, 229.43, 313.48, 293.47, 275.4, 289.56, 305.67, 252.35, 276.86, 308.84) horas &lt;- c(1287.25, 1588, 705.25, 1005.5, 1667.25, 1517.75, 967, 1609.25, 1747.75, 906.25, 1787.75, 1480.5, 1733.5, 1847.25, 1433, 1520, 1404.75, 1608.5, 1220, 1917.25, 1506.25, 589, 1552.75, 1518, 1793.75, 1548, 1446, 1858.25, 1486.25, 933.75, 1168.25, 877.25, 1387.25, 1312, 1551.5, 973.75, 1638.25, 1668.25, 1652.75, 1029.75, 1127, 1547.25, 1499.25, 1747.5) ejercicio05 &lt;- data.frame(consultas,quejas,residente,sexo,ingresos,horas) Ejercicio 6. Disponemos de los pesos (g) de dos pikas afganas preñadas, a lo largo de 14 periodos de tiempo igualmente espaciados entre sí desde la concepción al parto. Ajusta una curva de crecimiento para describir estos datos ¿Puedes detectar alguna diferencia entre los dos animales? animal &lt;- c(rep(&quot;Pika1&quot;,14),rep(&quot;Pika2&quot;,14)) peso &lt;-c(251, 254, 267, 267, 274, 286, 298, 295, 307, 318, 341, 342, 367, 370, 258, 263, 269, 266, 282, 289, 295, 308, 338, 350, 359, 382, 390, 400) semana &lt;- c(1:14,1:14) ejercicio06 &lt;- data.frame(animal,peso,semana) Ejercicio 7. Este problema se refiere a datos de un estudio de cangrejos herradura anidados. Cada cangrejo de herradura hembra en el estudio tenía un cangrejo macho unido a ella en su nido. El estudio investigó los factores que afectan si el cangrejo hembra tenía otros machos, llamados satélites, que residían cerca de ella. La característica que se cree que afecta el ancho del caparazón de la hembra. Se recogió información sobre las hembras y los machos, y estas se agruparon en grupos según su anchura. Cada grupo se caracterizo con la anchura media. Además, se registro el número de hembras correspondientes a cada anchura y el número de satélites alrededor de ellas. Representa la tasa media de satélites por hembra en función de la anchura y construye un modelo que represente la información contenida en estos datos. Extrae todas las conclusiones derivadas de el. anchura &lt;- c(22.69, 23.84, 24.77, 25.84, 26.79, 27.74, 28.67, 30.41) hembras &lt;- c(14, 14, 28, 39, 22, 24, 18, 14) satel &lt;- c(14, 20, 67, 105, 63, 93, 71, 72) ejercicio07 &lt;- data.frame(anchura,hembras,satel) "],["glmtablascont.html", "Unidad 14 GLM para tablas de contingencia 14.1 Bancos de datos 14.2 Modelos Log-Lineales 14.3 Modelos Logit-Multinomial 14.4 Estimación 14.5 Diagnóstico 14.6 Predicción 14.7 Ejercicios", " Unidad 14 GLM para tablas de contingencia Un tabla de contingencia se usa para estudiar una tabla de clasificación de un conjunto de factores donde se recogen el número de casos de cada una de las combinaciones de dichos factores. En este tipo de modelos las variables respuestas y predictoras son todas categóricas, medidas en una escala nominal u ordinal, aunque como veremos las construcción de este tipo de modelos se centran en estudiar las frecuencias de ocurrencia de cada combinación de los factores. El objetivo básico en el análisis de tablas de contingencia es estudiar si existe alguna relación/asociación entre los factores de clasificación considerados. posteriormente, si dicha relación existe, habrá que describir cómo es para tratar de predecirla. Para cuantificar el grado de asociación entre los factores de clasificación, los modelos log-lineales proporcionarán predicciones de las frecuencias observadas en las celdas y las probabilidades asociadas, en función de dichos factores y la interacción entre ellos. Para el análisis de estipo de datos es necesario que los datos vengan en un formato específico de forma que cada fila representa una combinación de los factores presentes en la tabla de contingencia y debe haber una columna que recoja los conteos o frecuencias de esa combinación. En ocasiones los datos deben ser trasnformados a partir de la tabla de contingencia para conseguir el fromato adecaudo para el análisis. En este último caso utilizaremos la función gather() que nosa permite modificar de forma sencilla la configuración del banco de datos. Como ocurría en los modelos de regresión de Poisson, en el caso de trabajar con factores ordinales se debderna considerar sus versiones numéwricas utilizando el método de codificación presentado en esa unidad. 14.1 Bancos de datos A continuación se presentan diferentes ejemplos de tablas de contingencia que iremos analizando a lo largo de la unidad. Realizamos una primera aproximación gráfica a la tabla de contingencia obtenida. 14.1.1 Melanoma Los datos siguientes provienen de un estudio de pacientes con una forma de cáncer de piel llamado melanoma maligno. En una muestra de 400 pacientes se recogió información sobre la localización del tumor y su tipo histológico. Los datos son el número de pacientes (frecuency) en cada combinación de tipo de tumor (type) y localización (site). El objetivo básico del análisis es investigar si determinados tipos de tumor están asociados a ciertas localizaciones. La tabla de conteos o contingencia recogida es: Tipo / Localización Cabeza-Cuello Tronco Extremidades Melanoma de Hutchinson 22 2 10 Melanoma Superficial 16 54 115 Nodular 19 33 73 Indeterminado 11 17 28 EL código para cargar estos datos se presenta a continaución. En este caso cada línea representa una combinación de factores. También representamos los datos: # Carga de datos Melanoma &lt;- read_csv(&quot;https://goo.gl/yeCXsv&quot;, col_types = &quot;cci&quot;) # Gráfico ggplot(Melanoma, aes(x = site, y = frequency, fill = type)) + stat_identity(geom = &quot;bar&quot;, position = &quot;dodge&quot;) Podemos ver claramente que hay ciertos tumores que tienen una mayor predisposición a aparecer en una parte del cuerpo que en otra. 14.1.2 Gripe En un estudio prospectivo sobre una nueva vacuna para la gripe, los pacientes fueron asignados aleatoriamente a dos grupos. A los pacientes de uno de los grupos se les trató con la nueva vacuna y a los otros se les dio un placebo salino. Las respuestas fueron los niveles de anticuerpos inhibidores de hemoglutinina (HIA) encontrados en la sangre seis semanas después de la vacunación. Los datos se encuentran en el banco de datos siguiente. El objetivo del estudio es investigar el efecto de la nueva vacuna, esto es, comprobar si el hecho de dar placebo o vacuna provoca diferente respuesta HIA. Así, la variable HIA es la variable a explicar (response) en función del tipo de tratamiento (treatment) que ha recibido el paciente y las frecuencias de las celdas (frequency). La tabla de contingencia obtenida es: Tratamiento / Respuesta Pequeño Moderado Grande Placebo 25 8 5 Vacuna 6 18 11 Podemos cargar los datos y representarlos gráficamente # Lectura de datos Gripe &lt;- read_csv(&quot;https://goo.gl/jPcz7x&quot;, col_types = &quot;cci&quot;) # Gráfico ggplot(Gripe, aes(x = treatment, y = frequency, fill = response)) + stat_identity(geom = &quot;bar&quot;, position = &quot;dodge&quot;) Se puede ver un comportamiento distinto entre el placebo y el tratamiento. 14.1.3 Aspirina En un estudio retrospectivo de casos-controles, se reunió a un grupo de pacientes con úlcera y se buscó a otro grupo de individuos de similares características a los anteriores en edad, sexo y estatus socio económico, sobre los que no se sabía que tuvieran úlcera péptica. Los pacientes con úlcera fueron clasificados de acuerdo a la localización de la úlcera: gástrica o duodenal. Se les preguntó a todos si consumían aspirina. El objetivo del análisis es averiguar si existe alguna relación entre el consumo de aspirina y la existencia de algún tipo de úlcera. Si existe tal asociación, querríamos comprobar si el consumo de aspirina (aspirina) es más habitual en los pacientes con úlcera gástrica que en los de úlcera duodenal (locali). Interesa predecir el consumo de aspirina (variable a explicar) en función de si un individuo tiene úlcera o no (ulcera). y si la tiene, de qué tipo es. La variable frecuencia contiene los conteos de las combinaciones de tratamientos. La tabla de contingencia obtenida es: Tipo Úlcera Úlcera / Consumo de aspirina No Si Gástrica Si 39 25 No 62 6 Duodenal Si 49 8 No 53 8 Podemos cargar los datos y representarlos gráficamente # Carga de datos locali &lt;- gl(2, 2, 8, labels = c(&quot;Gástrica&quot;, &quot;Duodenal&quot;)) ulcera &lt;- gl(2, 1, 8, labels = c(&quot;Si&quot;, &quot;No&quot;)) aspirina &lt;- gl(2, 4, 8, labels = c(&quot;No&quot;, &quot;Si&quot;)) frecuencia &lt;- c(39, 62, 49, 53, 25, 6, 8, 8) Aspirina &lt;- data.frame(locali, ulcera, aspirina, frecuencia) # Gráfico ggplot(Aspirina, aes(x = aspirina, y = frecuencia, fill = locali)) + stat_identity(geom = &quot;bar&quot;, position = &quot;dodge&quot;) + facet_wrap(~ ulcera) + labs(xlab =&quot;Consumo de aspirina&quot;, title = &quot;Desarrollo de úlcera&quot;, fill = &quot;Localización&quot;) De nuevo se observan comportamientos distintos para la combinación de los factores considerados. 14.1.4 Aspiraciones En la tabla se muestran una parte de los resultados de un estudio en los Estados Unidos con el que se pretendía investigar el grado de asociación entre las aspiraciones de los estudiantes de bachillerato por proseguir con estudios universitarios (aspiraciones) y su entorno social, medido en términos del estatus socio-económico de su familia (estatus) y el hecho de que recibieron motivación en su familia para continuar estudiando (motivacion). La variable frecuencia contiene los conteos para todas las combinaciones. La tabla de contingencia original es: Estatus Motivación familiar / Aspiraciones Universitarias No Si Baja Baja 749 35 Alta 233 133 Media-Baja Baja 627 38 Alta 330 303 Media-Alta Baja 420 37 Alta 374 467 Alta Baja 153 26 Alta 266 800 Dado que Estatus y Motivación personal son factores ordinales se debe considerar su codificación como variables numéricas. A continuación se presenta la lectura del banco de datos y su representación gráfica. estatus &lt;- gl(4, 2, 16, labels = c(&quot;Baja&quot;, &quot;Media-Baja&quot;, &quot;Media-Alta&quot;, &quot;Alta&quot;)) motivacion &lt;- gl(2, 1, 16, labels = c(&quot;Baja&quot;, &quot;Alta&quot;)) aspiraciones &lt;- gl(2, 8, 16, labels = c(&quot;No&quot;, &quot;Si&quot;)) frecuencia &lt;- c(749, 233, 627, 330, 420, 374, 153, 266, 35, 133, 38, 303, 37, 467, 26, 800) Aspiraciones &lt;- data.frame(estatus, motivacion, aspiraciones, frecuencia) # Código numérico para factores ordinales Aspiraciones &lt;- Aspiraciones %&gt;% mutate(estatus.num = as.numeric(gl(4, 2, 16)), motivacion.num = as.numeric(gl(2, 1, 16))) # Represenatción gráfica ggplot(Aspiraciones, aes(x = aspiraciones, y = frecuencia, fill = motivacion)) + stat_identity(geom = &quot;bar&quot;, position = &quot;dodge&quot;) + facet_wrap(~ estatus) + labs(xlab =&quot;Conusmo de aspirina&quot;, title = &quot;Estatus social&quot;, fill = &quot;Motivación&quot;) ¿Qué podemos comentar del gráfico obtenido? 14.1.5 Contraceptivos En la tabla aparecen los datos de un estudio sobre distintos usos contraceptivos en diferentes grupos generacionales. Entendiendo la variable método contraceptivo (metodo) como variable respuesta y la variable edad (edad) como predictiva, una cuestión de interés puede ser predecir el uso anticonceptivo de una mujer en función de su edad. La variable frecuencia contiene los conteos para todas las combinaciones. Edad / Método contraceptivo Esterilización Otros Ninguno 15-19 3 61 232 20-24 80 137 400 25-29 216 131 301 30-34 268 76 203 35-39 197 50 188 40-44 150 24 164 45-49 91 10 183 El código de lectura de datos (incluyendo la codificación del factor ordinal como el punto medio del intervalo) y el gráfico se muestran a continuación: edad &lt;- gl(7, 1, 21, labels = c(&quot;15-19&quot;, &quot;20-24&quot;, &quot;25-29&quot;, &quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;)) metodo &lt;- gl(3, 7, 21, labels = c (&quot;Esterilización&quot;, &quot;Otros&quot;, &quot;Ninguno&quot;)) frecuencia &lt;- c(3, 80, 216, 268, 197, 150, 91, 61, 137, 131, 76, 50, 24, 10, 232, 400, 301, 203, 188, 164, 183) Contraceptivos &lt;- data.frame(edad, metodo, frecuencia) # Código numérico para factor ordinales Contraceptivos &lt;- Contraceptivos %&gt;% mutate(edad.num = rep(c(17, 22, 27, 32, 37, 42, 47),3)) # Gráfico ggplot(Contraceptivos, aes(x = metodo, y = frecuencia, fill = edad)) + stat_identity(geom = &quot;bar&quot;, position = &quot;dodge&quot;) ¿Qué conclusiones podemos obtener de este gráfico? 14.1.6 Satisfacción laboral Los datos que se presentan corresponden a un estudio en el que se pretendía concluir sobre la relación entre el grado de satisfacción en el trabajo (Estado) y los ingresos percibidos (Ingresos). El objetivo es predecir el grado de satisfacción en el trabajo en función de los ingresos percibidos (en dólares). Construimos la variable frecuencia que contiene los conteos para todas las combinaciones. Ingresos / Satisfacción Muy Insatisfecho Poco Insatisfecho Moderadamente Satisfecho Muy Satisfecho &lt; 6000 20 24 80 82 6000 - 15000 22 38 104 125 15000 - 25000 13 28 81 113 &gt; 25000 7 18 54 92 Cargamos los datos que vienen en formato de tabla, con lo que es necesario transformarlos adecuadamente. También se calculan las variables numéricas asociadas con los factores ordinales. Satisfaccion &lt;- read_csv(&quot;https://goo.gl/5T0nh0&quot;, col_types = &quot;ciiii&quot;) # Construimos la tabla donde cada fila recoge la frecuencia observada para combinación de las variables Satisfaccion &lt;- Satisfaccion %&gt;% gather(`Muy insatisfecho`, `Poco insatisfecho`, `Moderadamente satisfecho`, `Muy satisfecho`, key = &quot;Estado&quot;, value = frecuencia) # Código numérico para factores ordinales Satisfaccion &lt;- Satisfaccion %&gt;% mutate(Ingresos.num = as.numeric(gl(4, 1, 16)), Estado.num = as.numeric(gl(4, 4, 16))) # Gráfico # Creamos un vector con el orden predefinido ords &lt;- c(&quot;&lt; 6000&quot;, &quot;6000 - 15000&quot;, &quot;15000 - 25000&quot;, &quot;&gt; 25000&quot;) ggplot(Satisfaccion, aes(x = Ingresos, y = frecuencia, fill = Estado)) + stat_identity(geom = &quot;bar&quot;, position = &quot;dodge&quot;) + scale_x_discrete(limits = ords) ¿Qué conclusiones podemos obtener de este gráfico? 14.2 Modelos Log-Lineales Las cuestiones básicas de interés en el análisis de tablas de contingencia son detectar asociación entre los factores de clasificación y predecir las frecuencias medias observadas. Dichas cuestiones se pueden resolver a partir de la modelización log-lineal de las frecuencias esperadas. Consideramos, para presentar estos modelos, únicamente dos vías de clasificación, F1 y F2. Si los factores se consideran independientes el número de individuos que esperamos clasificar en la celda \\((i, j)\\) (nivel \\(i\\) de F1 y nivel \\(j\\) de F2) se puede calcular a través del producto de los sucesos independientes “número esperado de individuos clasificados en el nivel i de F1,” \\(\\mu_{i+}\\), y “número esperado de individuos clasificados en el nivel j de F2,” \\(\\mu_{+j}\\) esto es, \\[E(Y_{ij}) = \\mu_{ij} = \\mu_{i+}*\\mu_{+j}\\] El efecto multiplicativo de los factores para predecir la frecuencia observada da lugar, de modo natural, a modelos logarítmicos aditivos (modelos log-lineales) de la forma: \\[log(E(Y_{ij})) = \\mu + \\alpha_i + \\beta_j + (\\alpha\\beta)_{ij}\\] donde \\(\\alpha_i\\) representa el efecto principal del factor fila F1 , \\(\\beta_j\\) el correspondiente al factor columna F2 y el \\((\\alpha\\beta)_{ij}\\) efecto de interacción entre ambos. Este modelo se denomina modelo saturado, ya que tiene tantos parámetros como celdas estamos considerando en la combinación de los factores, y tiene poco interés desde el punto de vista estadístico ya que cada parámetro del modelo se estima con un único valor en la muestra de datos. Contrastar independencia versus asociación será equivalente a contrastar interacción nula versus no nula en el modelo log-lineal, es decir debemos estudiar los modelos: El modelo saturado dado por \\(Frecuencias \\sim F1 * F2\\) El modelo sin interacción dado por \\(Frecuencias \\sim F1 + F2\\) dados por las expresiones \\[\\begin{array}{ll} M_0: log(E(Y_{ij})) &amp;= \\mu + \\alpha_i + \\beta_j\\\\ M_1: log(E(Y_{ij})) &amp;= \\mu + \\alpha_i + \\beta_j + (\\alpha\\beta)_{ij}\\\\ \\end{array}\\] En la práctica para contrastar independencia ajustamos un modelo con únicamente los efectos principales y valoramos la bondad del ajuste conseguido mediante el test \\(\\chi^2\\). En conclusión, reconocer asociación entre los factores de clasificación de una tabla de contingencia es equivalente a rechazar interacción nula entre ellos en el modelo log-lineal con el que se predicen las frecuencias observadas en las celdas. Cuando consideramos la tabla de contingencia asociada con tres factores el modelo saturado vendrá dado por: \\[Frecuencias \\sim F1 + F2 + F3 + F1:F2 + F1:F3 + F2:F3 + F1:F2:F3\\] donde el efecto de interacción triple \\(F1:F2:F3\\) nos permite estudiar si existe asociación entre los tres factores conjuntamente. En caso de que el contraste de bondad de ajuste del modelo reducido \\[M_0: Frecuencias \\sim F1 + F2 + F3 + F1:F2 + F1:F3 + F2:F3\\] no resulte significativo, podremos abordar el estudio de las interacciones dobles de la siguiente forma: la interacción \\(F1:F2\\) nos permite estudiar la asociación entre ambos factores dado F3 la interacción \\(F1:F3\\) nos permite estudiar la asociación entre ambos factores dado F2 la interacción \\(F2:F3\\) nos permite estudiar la asociación entre ambos factores dado F1 Por tanto, debemos estudiar la bondad de ajuste de los modelos \\[\\begin{array}{ll} M_1:&amp; Frecuencias \\sim F1 + F2 + F3 + F1:F3 + F2:F3\\\\ M_2:&amp; Frecuencias \\sim F1 + F2 + F3 + F1:F2 + F2:F3\\\\ M_3:&amp; Frecuencias \\sim F1 + F2 + F3 + F1:F2 + F1:F3\\\\ \\end{array}\\] para detectar las posibles asociaciones. En la pra´ctica siempre se fija un factor como varaible respuesta y los otros dos como predictoras, de forma que, si el factor F1 actúa como respuesta y los otros dos factores como predictoras, el modelo M3 no tiene sentido práctico, ya que en realidad nuestro interés radica en la asociación entre respuesta y predictoras. Así podemos seguir aumentando el número de factores en el modelo y estudiando las posibles asociaciones entre ellos. Se trata pues de un procedimiento de comparación de efectos o modelos de tipo manual y no automático como habíamos hecho en otro tipo de modelos. Para escribir de forma reducida lo modelos anteriores usamos la siguiente notación (que también nos vale para el ajuste de los modelos en R). \\[\\begin{array}{ll} M_0:&amp; Frecuencias \\sim (F1+F2+F3)^2\\\\ M_1:&amp; Frecuencias \\sim F2*F3 + F1 + F1:F3\\\\ M_2:&amp; Frecuencias \\sim F2*F3 + F1 + F1:F2\\\\ M_3:&amp; Frecuencias \\sim F1*F3 + F2 + F1:F2\\\\ \\end{array}\\] 14.2.1 Especificación en R Para el ajuste de estos modelos utilizamos la función glm() con las especificaciones siguientes: \\[glm(modelo, family = poisson(), data_set)\\] donde \\(modelo\\) se establece según las notaciones reducidas que hemos presentado tanto para dos como para tres factores. 14.2.2 Ejemplos A continuación estudiamos de forma inicial la independencia o dependencia en los ejemplos del inicio. Para el análisis de independencia utilizamos el test \\(\\chi^2\\) de bondad de ajuste y concluímos en función del p-valor obtenido. 14.2.2.1 Melanoma En este caso la pregunta de interés es si ¿existe asociación entre el tipo de tumor y su localización?, que equivale a estudiar si el efecto de interacción entre tipo de tumor y su localización resulta significativo, es decir, estudiar la bondad de ajuste del modelo sin interacción entre ambos. # Ajuste del modelo sin interacción fit.melanoma &lt;- glm(frequency ~ type + site, family = poisson(), data = Melanoma) # Bondad del asjute del modelo 1-pchisq(fit.melanoma$deviance, fit.melanoma$df.residual) ## [1] 2.050453e-09 Dado que el valor es inferior a 0.05 podemos concluir que hay evidencias estadísticas a favor de la asociación entre los factores tipo de tumor y localización, es decir, determinados tipos de tumor se presentan en ciertas localizaciones con más frecuencia que en otras. 14.2.2.2 Aspirina En el estudio se controlaron las variables úlcera y localización. A los pacientes clasificados en cada una de las combinaciones de estas dos variables se les preguntó sobre el consumo de aspirina, que es la variable aleatoria y por tanto la variable a explicar en función de las otras dos. Las cuestiones que nos planteamos son: En el grupo gástrico ¿la úlcera está asociada con el consumo de aspirina? ¿y en el grupo duodenal?. Para ambas cuestiones estamos planteando si, dado un grupo especifico (locali), el consumo de aspirina (aspirina) está relacionado con la existencia de úlcera (ulcera). Ambas preguntas se pueden contestar estudiando el efecto de interacción entre el consumo de aspirina y el desarrollo de una úlcera (aspirina:ulcera). Si dicha asociación existe, cabe preguntarse si dicha relación es similar en los dos grupos de pacientes. En este caso el estudio de la independencia total nos llevaría a analizar un modelo donde eliminamos la interacción de orden tres. Dicho modelo se puede obtener y analizar con: # Ajuste del modelo sin interacción fit.aspirina &lt;- glm(frecuencia ~ (locali + ulcera + aspirina)^2, family = poisson(), data = Aspirina) # Bondad del asjute del modelo 1-pchisq(fit.aspirina$deviance, fit.aspirina$df.residual) ## [1] 0.01219027 Dado que el p-valor resulta significativo podemos concluir que existe asociación entre los factores considerados. Pasamos ahora a estudiar cada una de las cuestiones planteadas ahora que sabemos que los factores están relacionados. Para saber si la existencia del desarrollo de una úlcera está asociado con el consumo de aspirina para cada tipo de úlcera, ajustamos un modelo sin la interacción aspirina:ulcera # Ajuste del modelo sin interacción fit.aspirina &lt;- glm(frecuencia ~ locali*ulcera + aspirina + aspirina:locali, family = poisson(), data = Aspirina) # Bondad del asjute del modelo 1-pchisq(fit.aspirina$deviance, fit.aspirina$df.residual) ## [1] 0.000143616 Se rechaza claramente independencia entre el consumo de aspirina y la existencia de úlcera para ambos tipos de úlcera. Pasamos ahora a la segunda cuestión, es decir, tratamos de averiguar si existe asociación entre el consumo de aspirina y el tipo de úlcera desarrollada. Para ello debemos analizar la interacción entre aspirina:locali cuando sabemos que se ha desarrollado una úlcera # Ajuste del modelo sin interacción fit.aspirina &lt;- glm(frecuencia ~ locali*ulcera + aspirina + aspirina:ulcera, family = poisson(), data = Aspirina) # Bondad del asjute del modelo 1-pchisq(fit.aspirina$deviance, fit.aspirina$df.residual) ## [1] 0.005147627 Rechazamos la hipótesis de independencia a favor de que el consumo de aspirina es diferente en pacientes con distinto tipo de úlcera. 14.2.2.3 Gripe Estudiamos la posible asociación entre la respuesta tars la vacunación y si el sujeto eras tratado o no. Podemos cargar los datos y representarlos gráficamente # Ajuste del modelo sin interacción fit.gripe &lt;- glm(frequency ~ treatment + response, family = poisson(), data = Gripe) # Bondad del asjute del modelo 1-pchisq(fit.gripe$deviance, fit.gripe$df.residual) ## [1] 8.95007e-05 puesto que el p-valor obtenido es significativo podemos concluir que hay asociación entre los factores considerados, es decir, la respuesta tras la vacunación se asocia con el grupo de tratamiento. 14.2.2.4 Aspiraciones Estamso interesados en conocer si existe asociación entre el estatus, la motivacion familiar y las aspiraciones universitarias. En este caso la variable que actuaría como respuesta son las aspiraciones universitarias, mientras que las otras dos se utilizan como varaible clasificadoras. Ajustamos el modelo sin interacción triple para establecer la posible asociación. # Ajuste del modelo sin interacción fit.aspiraciones &lt;- glm(frecuencia ~ (estatus + motivacion + aspiraciones)^2, family = poisson(), data = Aspiraciones) # Bondad del asjute del modelo 1-pchisq(fit.aspiraciones$deviance, fit.aspiraciones$df.residual) ## [1] 0.664965 en este caso no parece existir uan asociación entre los tres factores, pero ¿podría alguno de ellos estar asociado con las aspiraciones? ¿Cómo interpretamos los modelos siguientes? # Modelo 1 fit.aspiraciones &lt;- glm(frecuencia ~ estatus*motivacion + aspiraciones + aspiraciones:motivacion, family = poisson(), data = Aspiraciones) # Modelo 2 fit.aspiraciones &lt;- glm(frecuencia ~ estatus*motivacion + aspiraciones + aspiraciones:estatus, family = poisson(), data = Aspiraciones) Ejercicio. Realiza el análisis de independencia apra los bancos de datos Contraceptivos y Salud Laboral. 14.3 Modelos Logit-Multinomial El objetivo principal al analizar las tablas de contingenia no es sólo determinar la posible asociación entre los factores, sino tratar de predecir el comportamiento de uno de los factores (que actúa como variable respuesta) en función del resto de factores (que actúan como predictoras) cuando se detecta esta. En esta situación interesará modelizar los datos para predecir la probabilidad de que se dé una u otra respuesta en la variable respuesta en función de las distintas combinaciones en las variables predictoras. Para modelizar este tipo de situación se establece una variante de los modelos log-lineales, que además de resultar útiles para investigar asociación, son equivalentes a los modelos logit para respuesta Binomial, conocidos como modelos logit-multinomial. Para estudiar la especificación de este tipo de modleos nos planteamos la situacoçpn más sencilla donde consideremos una tabla de contingencia en la que están involucradas como variables de clasificación, una variable respuesta \\(R\\) con \\(I\\) niveles de clasificación, y una variable respuesta \\(A\\) con \\(J\\) niveles de clasificación. Además, denotamos por \\(\\pi_{i|j}\\) las probabilidades de respuesta \\(R = i\\) dada cierta clasificación en la variable predictora, \\((A = j)\\), esto es, \\[\\pi_{i|j} = P(R = i | A = j).\\] Los modelos logit-multinomial vienen definidos en términos de los log-odds (logaritmo del cociente) de las probabilidades condicionadas de dos niveles de respuesta de \\(R\\), dadas las diferentes combinaciones de niveles de las variables predictoras. En esta situación, y de forma similar a lo que ocurre con los modelos ANOVA, se suele elegir uno de los niveles de \\(R\\) como nivel de referencia, generalmente el primero o el último, para predecir el cociente de probabilidades condicionadas. Si se toma como categoría de referencia la última de \\(R\\) (en este caso I), los log-odds a predecir serán: \\[log\\left(\\frac{\\pi_{i|j}}{\\pi_{I|j}}\\right), \\quad \\text{para cada nivel } i \\text{ de } R\\] El ajuste de estos modelos logit-multinomiales se realiza a través de modelos log-lineales equivalentes con los que se predicen las frecuencias observadas \\(Y_{ij}\\) en la tabla de contingencia. Es preciso puntualizar que la equivalencia entre estos modelos logit y los log-lineales es cierta asumiendo que los totales marginales correspondientes a las variables predictivas son fijos. Básicamente es decir que las variables predictoras han sido controladas en el estudio con el fin principal de predecir la variable respuesta \\(R\\). Al asumir esto, obligamos a que los efectos asociados a dichas variables predictoras hayan de aparecer siempre (junto con sus interacciones) en cualquier modelo log-lineal que ajustemos. El cociente de log-odds (o logit entre las categorías \\(i\\) e \\(I\\)) se puede expresar como: \\[log\\left(\\frac{\\pi_{i|j}}{\\pi_{I|j}}\\right) = log\\left(\\frac{E(Y_{ij})}{E(Y_{Ij})}\\right) = log\\{E(Y_{ij})\\} - log\\{E(Y_{Ij})\\}\\] donde los \\(E(Y_{ij})\\) para ca \\(i\\) son los valores predichos del modelo log-lineal para cada combinación de los niveles de todas las variables involucradas. En realidad, esto significa que a la hora de estimar el log-odds sólo debemos tener en cuenta los coeficientes del modelo que hagan referencia a los niveles considerados de la variable respuesta, y a la interacción (si está presente en el modelo) entre respuesta y predictora, es decir: \\[log\\left(\\frac{\\pi_{i|j}}{\\pi_{I|j}}\\right) = (\\alpha_i -\\alpha_I) + (\\alpha\\beta_{ij} - \\alpha\\beta_{Ij})\\] donde los \\(\\alpha\\) son los efectos asociados con los niveles de las categorías de la respuesta y los \\(\\alpha\\beta\\) son los efectos asociados con la interacción entre respuesta y predictora. Esta relación tiene implicaciones importantes ya que para estimar los logits debemos tener en cuenta únicamente los coeficientes del modelo que están relacionados con la respuesta, a través de sus efectos principales o de sus interacciones con las predictoras. Este principio nos sirve para todas las situaciones de análisis que planteamos a continuación en función de las características de la variable respuesta y la predictora o predictoras. Antes de comenzar, al igual que ocurria en modelizaciones anteriores, la utilización de variables ficticias numéricas para sustituir una variable categórica de tipo ordinal es una forma de proceder es muy habitual. Dichos valores numéricos se denominan en los modelos log-lineales como scores o valores numéricos asociados a variables de carácter ordinal. Existen dos posibilidades de asignación de estos scores: Cuando la variable ordinal viene dada en intervalos se elige el punto medio como score asociado. Cuando la varaible ordinal viene dada en categorías nonuméricas se suele asociar un código numérico con el valor más bajo de 1 indicando la categoría más baja, y vamos aumentando de 1 en 1 hasta acabar con todos los niveles del factor. 14.4 Estimación A continuación se presenta el proceso de estimación de los diferentes modelos logit-multinomial que pueden surgir en función de las características de la varaible respuesta y las predictoras. Se detalla cada caso siguiendo las pautas del punto anterior y se analizan los ejemplos correspondientes. 14.4.1 Respuesta binaria nominal y predictora nominal Imaginemos que la variable respuesta esta compuesta por dos categorías de carácter nominal (\\(i=1, 2\\)=. Con la estructura de estimación definida en el punto anterior si la respuesta tiene únicamente dos categorías tendríamos que \\(\\pi_{1|j} = 1 - \\pi_{2|j}\\), de forma que tendríamos un único log-odds que se puede expresar como: \\[log\\left(\\frac{\\pi_{2|j}}{\\pi_{1|j}}\\right) = log\\left(\\frac{\\pi_{2|j}}{1-\\pi_{2|j}}\\right) = (\\alpha_2 -\\alpha_1) + (\\alpha\\beta_{2j} - \\alpha\\beta_{1j})\\] donde los \\(\\alpha\\) y los \\(\\alpha\\beta\\) son los definidos en el punto anterior. Si denotamos por \\(\\eta_{2|j}\\) al \\(log\\left(\\pi_{2|j}/\\pi_{1|j}\\right)\\), a partir de la expresión anterior resulta posible obtener la probabilidad de cada nivel de la respuesta mediante la ecuación: \\[\\pi_{2|j} = \\frac{exp(\\eta_{2|j})}{1+exp(\\eta_{2|j})}\\] 14.4.1.1 Datos Aspirina En primer lugar calculamos y evaluamos los logits empíricos asociados y más tarde realizamos el ajuste y estimación delm modelo. Tomamos como variable respuesta el consumo de aspirina, y usamos como referencia la categroria No podemos obtener los log-odds como: # Creamos variable con valores de referencia y obtenemos los log-odds asociados referencia.val &lt;- unlist(dplyr::select(filter(Aspirina, aspirina == &quot;No&quot;), frecuencia)) # Log-odds Aspirina &lt;- Aspirina %&gt;% mutate(referencia = rep(referencia.val, 2), lodds = log(frecuencia / referencia)) # Gráfico # Seleccionamos las categorías a representar eliminando la de referencia # Como la respuesta sólo tiene una categoría no hace falta utilizarla en el gráfico datos &lt;- filter(Aspirina, aspirina != &quot;No&quot;) ggplot(datos,aes(x = locali, y = lodds, group = ulcera, color = ulcera)) + geom_point() + geom_line() + labs(x = &quot;Localización&quot;, y = &quot;log-odds (Aspirina == Si/No)&quot;, col = &quot;Desarrollo de úlcera&quot;) Ajustamos un modelo con todas las interacciones dobles, ya que en este caso resulta imposible plantear el modelo con las interacción triple. Este modelo el que ya se planteo en el estudio de independencia. # Ajuste del modelo sin interacción fit.aspirina &lt;- glm(frecuencia ~ (locali + ulcera + aspirina)^2, family = poisson(), data = Aspirina) Para obtener los logits y probabilidades asociadas a cada categoría de la respuesta extraemos los coeficientes del modelo ajustado. Dado que solo nos interesan los efectos que están relaciondos directamente con la variable respuesta vamos a presentar únicamente dichos valores. Para saber los nombres de los coeficientes del modelo podemos utilizar el código siguiente identificando todos los efectos que están realcionados con la respuesta (efecto principal e interacciones). En estos modelos utilizamos la función La función tidy para presentar la estimación del modelo selecionando las columnas necesarias. tabla &lt;- tidy(fit.aspirina)[,c(&quot;term&quot;, &quot;estimate&quot;)] tabla Tabla 14.1: termestimate (Intercept)3.75&nbsp;&nbsp; localiDuodenal0.0698 ulceraNo0.321&nbsp; aspirinaSi-0.679&nbsp; localiDuodenal:ulceraNo-0.106&nbsp; localiDuodenal:aspirinaSi-0.7&nbsp;&nbsp;&nbsp; ulceraNo:aspirinaSi-1.14&nbsp;&nbsp; Seleccionamos los efectos necesarios para el ajuste de los logits y la estimación de probabilidades. Estos efectos son los relacionados (principales e interacciones) con la variable aspirina. # Filas de la tabla de estimaciones relacionados con metodo selefect&lt;- c(4, 6, 7) tabla[selefect,] Tabla 14.2: termestimate aspirinaSi-0.679 localiDuodenal:aspirinaSi-0.7&nbsp;&nbsp; ulceraNo:aspirinaSi-1.14&nbsp; Dado que ambas variables son de tipo nominal y tomando como referencia la categoría “No” de consumo de aspirina, podemos obtener el logit del consumo de aspirina versus la categoria de referencia para cualquier combinación der categorias de las predictoras mediante: \\[log\\left(\\frac{\\pi_{SI|jk}}{\\pi_{No|jk}}\\right) = (\\alpha_{Si} - \\alpha_{No}) + (\\theta_{Si,jk} - \\theta_{No,jk})\\] donde \\(\\alpha\\) hace referencia al efecto principal asociado con la respuesta (aspirina), y \\(\\theta\\) hace referencia al coeficiente de interacción entre la respuesta y los niveles \\(j\\) y \\(k\\) de localización de la úlcera (locali) y tener úlcera (ulcera) respectivamente. Si denotamos por \\(A\\) al consumo de aspirina, \\(L\\) la localización de la úlcera, y \\(U\\) tener o no tener úlcera, para obtener el logit para un sujeto con \\(U = No\\) y \\(L = Duodenal\\) tendríamos que: \\[\\eta_\\text{Si| U = NO; L = Duodenal} = (\\alpha_{Si} - \\alpha_{No}) + (\\theta_{Si,No,Duodenal} - \\theta_{No,No,Duodenal})\\] donde \\(\\alpha_{Si} = -0.679\\), \\(\\alpha_{No} = 0\\), y \\(\\theta_{Si,No,Duodenal}\\), \\(\\theta_{No,No,Duodenal}\\) representan las interacciones de la respuesta y predictoras para dicha combinación que vienen dadas por: \\[\\begin{array}{ll} \\theta_{Si,No,Duodenal} &amp;= \\theta_{Si,No} + \\theta_{Si,Duodenal} = - 1.14 - 0.70 = - 1.84\\\\ \\theta_{No,No,Duodenal} &amp;= \\theta_{No,No} + \\theta_{No,Duodenal} = 0 + 0 = 0\\\\ \\end{array}\\] Para la estimación de los logits hya que tener en cuenta las restricciones de identificabilidad \\(\\alpha_{No} = 0\\) y \\(\\theta_{No,jk} = 0\\) para cualquier combinación de \\(j\\) y \\(k\\), de forma que: \\[\\begin{array}{ll} \\eta_\\text{[Si| U = No; L = Duodenal]} &amp;= \\alpha_{Si} + \\theta_{Si,No} + \\theta_{Si,Duodenal} = - 0.679 - 1.84 = -2.519\\\\ \\eta_\\text{[Si| U = No; L = Gástrica]} &amp; = \\alpha_{Si} + \\theta_{Si,No} + \\theta_{Si,Gástrica} = - 0.679 - 1.14 + 0 = -1.819\\\\ \\eta_\\text{[Si| U = Si; L = Duodenal]} &amp; = \\alpha_{Si} + \\theta_{Si,Si} + \\theta_{Si,Duodenal} = - 0.679 + 0 - 0.70 = -1.379\\\\ \\eta_\\text{[Si| U = Si; L = Gástrica]} &amp; = \\alpha_{Si} + \\theta_{Si,Si} + \\theta_{Si,Gástrica} = - 0.679 + 0 + 0 = - 0.679\\\\ \\end{array}\\] Podemos obtener ahora las probabilidades de consumo de aspirina para cada combinación de las predictoras: \\[\\begin{array}{ll} \\pi_\\text{[Si| U = NO; L = Duodenal]} &amp; = exp(-2.519)/(1+exp(-2.519)) = 0.0745\\\\ \\pi_\\text{[Si| U = NO; L = Gástrica]} &amp; = exp(-1.819)/(1+exp(-1.819)) = 0.1396\\\\ \\pi_\\text{[Si| U = Si; L = Duodenal]} &amp; = exp(-1.379)/(1+exp(-1.379)) = 0.2012\\\\ \\pi_\\text{[Si| U = Si; L = Gástrica]} &amp; = exp(-0.679)/(1+exp(-0.679)) = 0.3365\\\\ \\end{array}\\] A la vista de estos resultados podemos concluir que la probabilidad de consumir aspirina dado un enfermo de úlcera duodenal es de 0.2012, mientras que para un enfermo de úlcera gástrica dicha probabilidad es de 0.3365. Podemos concluir que la probabilidad del consumo de aspirina es superior en los enfermos con úlcera gástrica que en la duodenal, y mayor en los sujetos enfermos que en los controles. Las probabilidades anteriores se puden obtener de forma un poco más directa a partir de los valores predichos del modelo. # Calculamos los conteos predichos del modelo conteos &lt;- predict(fit.aspirina, type = &quot;response&quot;) # Combinamos los datos originales con los predichos newdata &lt;- cbind(Aspirina, conteos) # Calculamos el conteo total por las predictoras newdata.sum &lt;- newdata %&gt;% group_by(locali, ulcera) %&gt;% summarise(suma = sum(conteos)) # Calculamos las probabilidades asociadas a cada combinación newdata &lt;- newdata %&gt;% left_join(newdata.sum, by = c(&quot;locali&quot;,&quot;ulcera&quot;)) %&gt;% mutate(prob = round(conteos/suma,4)) # Vemos las probabiliddes obtenidas dplyr::select(newdata,c(locali, ulcera, aspirina, prob)) Tabla 14.3: localiulceraaspirinaprob GástricaSiNo0.663&nbsp; GástricaNoNo0.861&nbsp; DuodenalSiNo0.799&nbsp; DuodenalNoNo0.926&nbsp; GástricaSiSi0.337&nbsp; GástricaNoSi0.139&nbsp; DuodenalSiSi0.201&nbsp; DuodenalNoSi0.0743 Podemos representar las probabilidades obtenidas para ver los efectos de la combinacion de predictoras en la respuesta. ggplot(newdata, aes(x = locali, y = prob, group = ulcera, color = ulcera)) + geom_point() + geom_line() + facet_wrap(~ aspirina) + labs(title = &quot;Consumo de aspirina&quot;, x = &quot;Localización de la úlcera&quot;, y = &quot;Probabilidad&quot;, col = &quot;Úlcera&quot;) + scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1)) 14.4.2 Respuesta multinomial nominal y predictora nominal Cuando tenemos más de dos categorías el procedimiento es bastante similar. En este caso tomamos la última categoria \\(I\\) como referencia, de forma que los log-odds se pueden expresar como: \\[log\\left(\\frac{\\pi_{i|j}}{\\pi_{I|j}}\\right) = \\eta_{i|j} = (\\alpha_i -\\alpha_I) + (\\alpha\\beta_{ij} - \\alpha\\beta_{Ij})\\] A partir del logit anterior para cada categoría \\(i\\),podemos obtener la probabilidad condicionada de dicha categoría \\(i\\) como: \\[\\pi_{i|j} = \\frac{exp(\\eta_{i|j})}{\\sum_{l=1}^I exp(\\eta_{l|j})}\\] Puesto que \\(exp(\\eta_{I|j}) = 1\\) dicha probabilidad se puede expresar como: \\[\\pi_{i|j} = \\frac{exp(\\eta_{i|j})}{1 + \\sum_{l \\neq I} exp(\\eta_{l|j})}\\] Esta expresión es similar a la de dos categorías salvo por la modificación del denominador, donde se incluyen los predictores, \\(\\eta\\), asociados a todas las categorías de la respuesta. 14.4.3 Respuesta nominal, predictora ordinal Esta situación es miliar a la anterior salvo por el carácter ordinal de la predictora. Para estimar dichos modelos debemos incluir una variable ficticia (\\(S\\)) que contendrá los scores asociados con las categorías de la predictora. Si \\(v_1=1, v_2=2,...,v_J=J\\) denota a los scores asociados con la varaible ordinal, el logit asociado a esta situación se puede expresar mediante: \\[log\\left(\\frac{\\pi_{i|j}}{\\pi_{I|j}}\\right) = \\eta_{i|j} = (\\alpha_i -\\alpha_I) + (\\alpha\\beta_{ij} - \\alpha\\beta_{Ij})v_j\\] donde las interacciones entre la respuesta y la predictora se modifican a través del score definido, para introducir el efecto ordinal entre las comninaciones, de forma que los cocientes de probabilidades se obtienen como \\[\\frac{\\pi_{i|j}}{\\pi_{I|j}} = exp(\\eta_{i|j}) = exp\\{(\\alpha_i -\\alpha_I) + (\\alpha\\beta_{ij} - \\alpha\\beta_{Ij})v_j\\}\\] de forma que la probabilidad de una categoría \\(i\\) viene dada por: \\[\\pi_{i|j} = \\frac{exp(\\eta_{i|j})}{1 + \\sum_{l \\neq I} exp(\\eta_{l|j})}\\] 14.4.3.1 Datos Aspiraciones universitarias Si tomamos como variable respuesta las aspiraciones universitarias en función del estatus económico y de la motivación familiar, y usamos como referencia la categoría No podemos obtener el log-odd de la categoría Si mediante: # Creamos variable con valores de referencia y obtenemos los log-odds asociados referencia.val &lt;- unlist(dplyr::select(filter(Aspiraciones, aspiraciones == &quot;No&quot;), frecuencia)) Aspiraciones &lt;- Aspiraciones %&gt;% mutate(referencia = rep(referencia.val, 2), lodds = log(frecuencia / referencia)) # Gráfico # Seleccionamos las categorías a representar eliminando la de referencia # Como la respuesta sólo tiene una categoría no hace falta utilizarla en el gráfico datos &lt;- filter(Aspiraciones, aspiraciones != &quot;No&quot;) ggplot(datos,aes(x = estatus, y = lodds, group = motivacion, color = motivacion)) + geom_point() + geom_line() + labs(x = &quot;Estatus Socioeconómico&quot;, y = &quot;log-odds (Aspiraciones == Si / No)&quot;, col = &quot;Motivacion&quot;) Se observa una tendencia creciente (puede incluso que no lineal) conforme aumenta el estatus económico, que va relacionada directamente con una motivación más alta en el entorno familiar (comportamiento casi paralelo para ambas motivaciones). Para el ajuste de este modelo debemos considerar los scores asociados a cada una de las predictoras ordinales (estatus.num y motivacion.num) tal y como los definimos al presentar este banco de datos. En primer lugar ajustamos el modelo para estudiar asociación eliminando la interacción de orden 3. # Ajuste del modelo sin interacción triple fit.aspiraciones.aso &lt;- glm(frecuencia ~ (estatus + motivacion + aspiraciones)^2, family = poisson(), data = Aspiraciones) # Bondad del asjute del modelo 1-pchisq(fit.aspiraciones.aso$deviance, fit.aspiraciones.aso$df.residual) ## [1] 0.664965 No podemos rechazar la interacción triple. Ajustamos un nuevo modelo eliminando la interacción doble entre estatus y motivacion dado que los prefiles de los logits parecían paralelos. # Ajuste del modelo sin interacción triple fit.aspiraciones.aso2 &lt;- glm(frecuencia ~ estatus + motivacion + aspiraciones + estatus:aspiraciones + motivacion:aspiraciones, family = poisson(), data = Aspiraciones) # Bondad del ajuste 1-pchisq(fit.aspiraciones.aso2$deviance, fit.aspiraciones.aso2$df.residual) ## [1] 0 # Comapramos con el modelo anterior anova(fit.aspiraciones.aso2, fit.aspiraciones.aso, test =&quot;Chisq&quot;) Tabla 14.4: Resid. DfResid. DevDfDeviancePr(&gt;Chi) 6298&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31.5832974.64e-64 El p-valor resulta significativo dando indicaciones de que la interacción estatus:motivacion no es relevante pero este modelo si que es distinto del modelo saturado. Ajustamos este modelo teniendo en cuenta los scores: # Debemos incluir el efecto de las predictoras como factor principal # para mantener la estructura del modelo fit.aspiraciones &lt;- glm(frecuencia ~ estatus + motivacion + aspiraciones + aspiraciones*(estatus.num + motivacion.num), family = poisson(), data = Aspiraciones) Obtenemos la tabla de estimación para el modelo: tabla &lt;- tidy(fit.aspiraciones)[,c(&quot;term&quot;, &quot;estimate&quot;)] tabla Tabla 14.5: termestimate (Intercept)6.42&nbsp;&nbsp; estatusMedia-Baja-0.0318 estatusMedia-Alta-0.307&nbsp; estatusAlta-0.78&nbsp;&nbsp; motivacionAlta-0.482&nbsp; aspiracionesSi-7.81&nbsp;&nbsp; estatus.num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; motivacion.num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aspiracionesSi:estatus.num0.806&nbsp; aspiracionesSi:motivacion.num3.01&nbsp;&nbsp; Seleccionamos los efectos necesarios para el ajuste de los logits y la estimación de probabilidades. Estos efectos son los relacionados (principales e interacciones) con la variable aspiraciones. # Filas de la tabla de estimaciones relacionados con metodo tabla[6:8,] Tabla 14.6: termestimate aspiracionesSi-7.81 estatus.num&nbsp;&nbsp;&nbsp; motivacion.num&nbsp;&nbsp;&nbsp; Con una variable respuesta nominal y una predictora ordinal la ecuació del logit (tomando la categoría No como referencia) se pueden obtener de forma sencilla a partir de las ecuaciones descritas anteriormente. La expresión del logit en función de los niveles de las predictoras viene dada por: \\[log\\left(\\frac{\\pi_{\\text{Si,jk}}}{\\pi_{\\text{No,jk}}}\\right) = (\\alpha_{\\text{Si}} - \\alpha_{\\text{No}}) + (\\theta_{Si,j} - \\theta_{No,j}) v_j + (\\gamma_{Si,k} - \\gamma_{No,k}) w_k \\\\ = \\alpha_{\\text{Si}} + \\theta_{Si,j} v_j + \\gamma_{Si,k} w_k\\] donde los \\(\\alpha\\) representan los efectos principales de aspiraciones, \\(\\theta\\) los efectos de las interacciones entre aspiraciones y estatus, \\(\\gamma\\) los efectos de las interacciones entre aspiraciones y motivacion, los \\(v_j\\) son los scores de estatus, y los \\(\\gamma_k\\) son los scores de motivacion. Sustituyendo tendríamos: \\[log\\left(\\frac{\\pi_{\\text{Si,jk}}}{\\pi_{\\text{No,jk}}}\\right) = - 7.81 + 0.806 v_j + 3.01 w_k\\] Dando valores a \\(v_j\\) (de 1 a 4) y a \\(w_k\\) (de 1 a 2) podemos obtener el logit asociado con la variable respuesta. En este caso pasamos directamente a estimar las probabilidades de cada combinación. # Calculamos los conteos predichos del modelo conteos &lt;- predict(fit.aspiraciones, type = &quot;response&quot;) # Combinamos los datos originales con los predichos newdata &lt;- cbind(Aspiraciones, conteos) # Calculamos el conteo total por las predictoras newdata.sum &lt;- newdata %&gt;% group_by(estatus, motivacion) %&gt;% summarise(suma = sum(conteos)) # Calculamos las probabilidades asociadas a cada combinación newdata &lt;- newdata %&gt;% left_join(newdata.sum, by = c(&quot;estatus&quot;, &quot;motivacion&quot;)) %&gt;% mutate(prob = round(conteos/suma,4)) # Vemos las probabiliddes obtenidas dplyr::select(newdata,c(estatus, motivacion, aspiraciones, prob)) Tabla 14.7: estatusmotivacionaspiracionesprob BajaBajaNo0.982&nbsp; BajaAltaNo0.728&nbsp; Media-BajaBajaNo0.96&nbsp;&nbsp; Media-BajaAltaNo0.545&nbsp; Media-AltaBajaNo0.916&nbsp; Media-AltaAltaNo0.348&nbsp; AltaBajaNo0.829&nbsp; AltaAltaNo0.193&nbsp; BajaBajaSi0.0181 BajaAltaSi0.272&nbsp; Media-BajaBajaSi0.0396 Media-BajaAltaSi0.455&nbsp; Media-AltaBajaSi0.0844 Media-AltaAltaSi0.652&nbsp; AltaBajaSi0.171&nbsp; AltaAltaSi0.807&nbsp; Podemos representar las probabilidades obtenidas para ver los efectos de la combinacion de predictoras en la respuesta. ggplot(newdata, aes(x = estatus, y = prob, group = aspiraciones, color = aspiraciones)) + geom_point() + geom_line() + facet_wrap(~ motivacion) + labs(title = &quot;Probabilidades estimadas por motivacion&quot;, x = &quot;Edad&quot;, y = &quot;Probabilidad&quot;, col = &quot;Método anticonceptivo&quot;) + scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1)) 14.4.3.2 Datos de Contraceptivos Si tomamos como variable respuesta el método anticonceptivo utilizado, y usamos como referencia la categroria Ninguno podemos obtener los log-odds de la otras dos categorías como: # Creamos variable con valores de referencia y obtenemos los log-odds asociados referencia.val &lt;- unlist(dplyr::select(filter(Contraceptivos, metodo == &quot;Ninguno&quot;), frecuencia)) Contraceptivos &lt;- Contraceptivos %&gt;% mutate(referencia = rep(referencia.val, 3), lodds = log(frecuencia / referencia)) # Gráfico # Seleccionamos las categorías a representar eliminando la de referencia # Como la respuesta sólo tiene una categoría no hace falta utilizarla en el gráfico datos &lt;- filter(Contraceptivos, metodo != &quot;Ninguno&quot;) ggplot(datos,aes(x = edad, y = lodds, group = metodo, color = metodo)) + geom_point() + geom_line() + labs(x = &quot;Grupo de edad&quot;, y = &quot;log-odds (Ref: Método == Ninguno)&quot;, col = &quot;Método anticonceptivo&quot;) Se observan claramente tendencias cuadráticas distintas para cada método asociadas con el grupo de edad considerado. Aprovecharemos el carácter ordinal de dicha variable para incluir una nueva variable que contenga la marca de clase de cada grupo de edad (score), que nos permita ajustar el modelo cuadrático con edad. Dado que sólo tenemos una predictora vamos a ajustar un modelo sólo con efectos principales. Estudiamos la bondad del ajuste de dicho modelo para conocer el patrón de asociación entre las variables. Si desechamos la interacción doble concluiríamos que no existe asociación entre edad y método contraceptivo. En caso contrario deberíamos establecer el modelo de asociación entre ambas variables. El gráfico de log-odds muestra cierto grado de asociación de tipo cuadrático con la edad. Se debe explorar la posibilidd de un modelo de interacción con la variable de scores de edad asumiendo un modelo cuadrático. # Ajuste del modelo sin interacción fit.contraceptivos.aso &lt;- glm(frecuencia ~ edad + metodo, family = poisson(), data = Contraceptivos) # Bondad del asjute del modelo 1-pchisq(fit.contraceptivos.aso$deviance, fit.contraceptivos.aso$df.residual) ## [1] 0 Rechazamos la hipótesis de independencia. Ajustamos el modelo de interacción cuadrático con los scores de la variable edad que ya fijamos en la presentación del banco de datos (punto medio de los intervalos de edad). En este modelo incluimos la edad como factor principal, y los scores de la edad en interacción con la variable método anticonceptivo. # Ajuste del modelo con efecto cuadrático en edad # Debemos incluir el efecto edad como factor principal # para mantener la estructura del modelo fit.contraceptivos &lt;- glm(frecuencia ~ edad + metodo*(edad.num + I(edad.num^2)), family = poisson(), data = Contraceptivos) Comparamos los dos modelos obtenidos para validar la inclusión de la variable de scores de edad anova(fit.contraceptivos.aso, fit.contraceptivos, test = &quot;Chisq&quot;) Tabla 14.8: Resid. DfResid. DevDfDeviancePr(&gt;Chi) 12521&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 820.545014.9e-107 Dado que el p-valor resulta significativo podemos conluir que ambos modelos son distintos. Obtenemos la tabla de estimación para el modelo: tabla &lt;- tidy(fit.contraceptivos)[,c(&quot;term&quot;, &quot;estimate&quot;)] tabla Tabla 14.9: termestimate (Intercept)2.26&nbsp;&nbsp;&nbsp; edad20-242.14&nbsp;&nbsp;&nbsp; edad25-293.04&nbsp;&nbsp;&nbsp; edad30-343.28&nbsp;&nbsp;&nbsp; edad35-393.16&nbsp;&nbsp;&nbsp; edad40-442.78&nbsp;&nbsp;&nbsp; edad45-492.13&nbsp;&nbsp;&nbsp; metodoOtros7.85&nbsp;&nbsp;&nbsp; metodoNinguno12.3&nbsp;&nbsp;&nbsp;&nbsp; edad.num&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I(edad.num^2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; metodoOtros:edad.num-0.441&nbsp;&nbsp; metodoNinguno:edad.num-0.7&nbsp;&nbsp;&nbsp;&nbsp; metodoOtros:I(edad.num^2)0.00497 metodoNinguno:I(edad.num^2)0.00973 Seleccionamos los efectos necesarios para el ajuste de los logits y la estimación de probabilidades. Estos efectos son los relacionados (principales e interacciones) con la variable metodo. # Filas de la tabla de estimaciones relacionados con metodo tabla[8:13,] Tabla 14.10: termestimate metodoOtros7.85&nbsp; metodoNinguno12.3&nbsp;&nbsp; edad.num&nbsp;&nbsp;&nbsp;&nbsp; I(edad.num^2)&nbsp;&nbsp;&nbsp;&nbsp; metodoOtros:edad.num-0.441 metodoNinguno:edad.num-0.7&nbsp;&nbsp; Con una variable respuesta nominal y una predictora ordinal la ecuació del logit (tomando la categoría Ninguno como referencia) se pueden obtener de forma sencilla a partir de las ecuaciones descritas anteriormente. Para simplificar las expresiones utilizamos la codificación de categorias de la variable metodo: Esterilizacion = E, Ninguno = N, y Otros = O. Las expresiones de los logits en función de la edad son: \\[log\\left(\\frac{\\pi_{\\text{E,j}}}{\\pi_{\\text{N,j}}}\\right) = (\\alpha_{\\text{E}} - \\alpha_{\\text{N}}) + (\\theta_{E,j} - \\theta_{N,j}) v_j + (\\theta^2_{E,j} - \\theta^2_{N,j}) v^2_j\\] \\[log\\left(\\frac{\\pi_{\\text{O,j}}}{\\pi_{\\text{N,j}}}\\right) = (\\alpha_{\\text{O}} - \\alpha_{\\text{N}}) + (\\theta_{O,j} - \\theta_{N,j}) v_j + (\\theta^2_{O,j} - \\theta^2_{N,j}) v^2_j\\] donde los \\(\\alpha\\) representan los efectos principales, \\(\\theta\\) los efectos de las interacciones con el efecto lineal del score, \\(\\theta^2\\) los efectos de las interacciones con el efecto cuadrático del score, y los \\(v_j\\) son los scores de la edad. Sustituyendo tendríamos: \\[log\\left(\\frac{\\pi_{\\text{E,j}}}{\\pi_{\\text{N,j}}}\\right) = (0 - 12.30) + (0 + 0.70) v_j + (0 - 0.00973) v^2_j \\\\ = - 12.30 + 0.70 v_j - 0.00973 v^2_j\\] \\[log\\left(\\frac{\\pi_{\\text{O,j}}}{\\pi_{\\text{N,j}}}\\right) = (7.85 - 12.30) + (-0.441 + 0.70) v_j + (0.00497 - 0.00973) v^2_j \\\\ = - 4.45 + 0.259 v_j - 0.00476 v^2_j\\] Podemos representar los logits obtenidos en función de la edad: # Secuencia de edad edadsec &lt;- seq(15,49,1) # Valores logit comparada con la de referencia EvsN &lt;- - 12.30 + 0.70*edadsec - 0.00973*edadsec^2 OvsN &lt;- - 4.45 + 0.259*edadsec - 0.00476*edadsec^2 # Configuración de datos para logits edad &lt;- rep(edadsec,2) combinacion &lt;- c(rep(&quot;E versus N&quot;,length(edadsec)), rep(&quot;O versus N&quot;,length(edadsec))) logits &lt;- c(EvsN, OvsN) datoscom &lt;- data.frame(edad, combinacion, logits) # Gráfico ggplot(datoscom, aes(x = edad, y = logits, group = combinacion, color = combinacion)) + geom_line() + labs(title = &quot;Logits por edad&quot;, y = &quot;Logits&quot;, x = &quot;Edad&quot;, col = &quot;Comparación&quot;) Los logits estimados reproducen el comportamiento observado en los logits empíricos. Por último obtnemos las probabilidades de cada combinación, que en este caso su evolución como función de la edad. En lugar de evaluar los logits utilizaremos la función predict para evaluar dichas probabildiades y representarlas gráficamente. # Calculamos los conteos predichos del modelo conteos &lt;- predict(fit.contraceptivos, type = &quot;response&quot;) # Combinamos los datos originales con los predichos newdata &lt;- cbind(Contraceptivos, conteos) # Calculamos el conteo total por las predictoras newdata.sum &lt;- newdata %&gt;% group_by(edad) %&gt;% summarise(suma = sum(conteos)) # Calculamos las probabilidades asociadas a cada combinación newdata &lt;- newdata %&gt;% left_join(newdata.sum, by = &quot;edad&quot;) %&gt;% mutate(prob = round(conteos/suma,4)) # Vemos las probabiliddes obtenidas dplyr::select(newdata,c(edad, metodo, prob)) Tabla 14.11: edadmetodoprob 15-19Esterilización0.0322 20-24Esterilización0.132&nbsp; 25-29Esterilización0.309&nbsp; 30-34Esterilización0.463&nbsp; 35-39Esterilización0.519&nbsp; 40-44Esterilización0.457&nbsp; 45-49Esterilización0.283&nbsp; 15-19Otros0.194&nbsp; 20-24Otros0.231&nbsp; 25-29Otros0.202&nbsp; 30-34Otros0.145&nbsp; 35-39Otros0.0999 40-44Otros0.0693 45-49Otros0.0434 15-19Ninguno0.774&nbsp; 20-24Ninguno0.638&nbsp; 25-29Ninguno0.489&nbsp; 30-34Ninguno0.392&nbsp; 35-39Ninguno0.381&nbsp; 40-44Ninguno0.473&nbsp; 45-49Ninguno0.673&nbsp; Podemos representar las probabilidades obtenidas para ver los efectos de la combinacion de predictoras en la respuesta. ggplot(newdata, aes(x = edad, y = prob, group = metodo, color = metodo)) + geom_point() + geom_line() + labs(title = &quot;Probabilidades estimadas&quot;, x = &quot;Edad&quot;, y = &quot;Probabilidad&quot;, col = &quot;Método anticonceptivo&quot;) + scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1)) ¿Qué conclusiones podemos extraer de este gráfico? ¿qué método predomina en el grupo de 20 a 24 años? ¿y en l grupo 40 a 44? 14.4.4 Respuesta ordinal, predictora nominal Cuando la variable respuesta tiene carácter ordinal el proceso de estimación debe variar para tener en cuenta dicho carácter. En esta situación no obtenemos los logit de una categoría con respecto a la de referencia sino que procedemos construyendo los logit de dos categorías consecutivas \\[log\\left(\\frac{\\pi_{i+1|j}}{\\pi_{i|j}}\\right)\\] para valorar el incremento que sufre la probabilidad de un categoría con respecto a su categoría superior. Para estimar dichos modelos debemos incluir una variable ficticia (\\(S\\)) que contendrá los scores asociados con las categorías de la respuesta. Si \\(u_1=1, u_2=2,...,u_n=n\\) denotan dichos scores y sólo tenemos una variable predictora, el logit anterior se puede obtener fácilmente mediante: \\[log(E(Y_{ij})) = \\mu +\\alpha_i + \\beta_j + \\theta_j S_i\\] donde \\(\\mu\\) es la interceptación del modelo, \\(\\alpha_i\\) es el efecto asociado con el nivel \\(i\\) de la respuesta, \\(\\beta_j\\) es el efecto asociado con el nivel \\(j\\) de la predictora, y \\(\\theta\\) es el efecto asociado con la variable de scores. En la práctica el logit para dos categorías consecutivas de la respuesta dependen únicamente de los coeficientes del modelo que afectaban a la respuesta y a la interacción entre respuesta y predictora, es decir: \\[log\\left(\\frac{\\pi_{i+1|j}}{\\pi_{i|j}}\\right) = \\eta_{i+1|j} =(\\alpha_{i+1} - \\alpha_i)+ \\theta_j (u_{i+1} - u_i)\\ \\] de forma que la relación entre ambas probabilidades viene dada por: \\[\\frac{\\pi_{i+1|j}}{\\pi_{i|j}} = exp(\\eta_{i+1|j}) = exp\\{(\\alpha_{i+1} - \\alpha_i) + \\theta_j (u_{i+1} - u_i)\\}\\] Si queremos obtener la relación entre las probabilidades de las categorías \\(i+2\\) e \\(i\\) basta con considerar que: \\[\\frac{\\pi_{i+2|j}}{\\pi_{i|j}} = \\frac{\\pi_{i+2|j}}{\\pi_{i+1|j}}\\frac{\\pi_{i+1|j}}{\\pi_{i|j}}\\] que se puede calcular como: \\[\\frac{\\pi_{i+2|j}}{\\pi_{i|j}} = exp(\\eta_{i+2|j}) = exp\\{(\\alpha_{i+2} - \\alpha_i) + \\theta_j (u_{i+2} - u_i)\\}\\] De esta forma podemos obtener la relación entre cualquier para de categorías de la respuesta. 14.4.4.1 Datos de gripe En primer lugar calculamos y evaluamos los logits empíricos asociados y más tarde realizamos el ajuste y estimación del modelo. Dado que la respuesta es ordinal debemos calcular los logits referenciados a la categoría inferior tomando como referencia inicial la categoría small. Obtenemos los log-odds y los representamos mediante: # Creamos referencias de comparación consecutivas ref.val1 &lt;- unlist(dplyr::select(filter(Gripe, response == &quot;small&quot;), frequency)) ref.val2 &lt;- unlist(dplyr::select(filter(Gripe, response == &quot;moderate&quot;), frequency)) # Log-odds Gripe &lt;- Gripe %&gt;% mutate(referencia = c(rep(ref.val1, 2), ref.val2), lodds = log(frequency / referencia)) # Gráfico # Seleccionamos las categorías a representar eliminando la de referencia # Como la respuesta sólo tiene una categoría no hace falta utilizarla en el gráfico datos &lt;- filter(Gripe, response != &quot;small&quot;) ggplot(datos,aes(x = treatment, y = lodds, group = response, color = response)) + geom_point() + geom_line() + labs(x = &quot;Tratamiento&quot;, y = &quot;log-odds condicionados&quot;, col = &quot;Respuesta&quot;) Se observa casi un comportamiento paralelo entre los logits obtenidos. En este caso queremos estudiar un posible modelo de asociación entre la respuesta a la vacuna y el tipo de tratamiento seguido. La variable respuesta es de tipo ordinal y asignamos la variable de scores de 1 a 3, donde 1 refleja efecto pequeño y 3 refleja un efecto grande. En este caso modelizaremos los logits de categorías consecutivas: Moderado vs Pequeño, y Grande vs Moderado. Planteamos el análisis de independencia (sin interacción entre el tratamiento y la variable de scores) frente al de asociación (interacción entre tratamiento y scores) dado los logits observados. En primer lugar creamos los scores asociados: # Creamos variable de scores Gripe$efecto.s &lt;-c() Gripe$efecto.s[Gripe$response == &quot;small&quot;] &lt;- 1 Gripe$efecto.s[Gripe$response == &quot;moderate&quot;] &lt;- 2 Gripe$efecto.s[Gripe$response == &quot;large&quot;] &lt;- 3 Ajustamos los modelos sin (independencia) y con interacción (dependencia) de los scores con la predictora y valoramos sin ambos modleos son iguales: # Ajuste del modelo de independencia fit.gripe.ind &lt;- glm(frequency ~ treatment + response + efecto.s, family = poisson(), data = Gripe) # Ajuste del modelo de asociación fit.gripe &lt;- glm(frequency ~ treatment + response + treatment:efecto.s, family = poisson(), data = Gripe) # Comparamos ambos modelos anova(fit.gripe.ind, fit.gripe, test = &quot;Chisq&quot;) Tabla 14.12: Resid. DfResid. DevDfDeviancePr(&gt;Chi) 218.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14.31114.30.000153 Rechazamos el modelo de independencia a favor del modelo de asociación. Veamos las estimaciones del modelo. Obtenemos la tabla de estimación para el modelo: tabla &lt;- tidy(fit.gripe)[,c(&quot;term&quot;, &quot;estimate&quot;)] tabla Tabla 14.13: termestimate (Intercept)4.88&nbsp;&nbsp; treatmentvaccine-2.32&nbsp;&nbsp; responsemoderate0.0928 responsesmall-0.49&nbsp;&nbsp; treatmentplacebo:efecto.s-1.25&nbsp;&nbsp; treatmentvaccine:efecto.s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Seleccionamos los efectos necesarios para el ajuste de los logits y la estimación de probabilidades. Estos efectos son los relacionados (principales e interacciones) con la variable response. # Filas de la tabla de estimaciones relacionados con metodo tabla[3:5,] Tabla 14.14: termestimate responsemoderate0.0928 responsesmall-0.49&nbsp;&nbsp; treatmentplacebo:efecto.s-1.25&nbsp;&nbsp; Para este modelo Los logits consecutivos asociados vienen dados por las expresiones siguientes donde utilizamos la codificación S = small, M = moderate, y L = large para la variable response: \\[log\\left(\\frac{\\pi_{\\text{M,j}}}{\\pi_{\\text{S,j}}}\\right) = (\\alpha_{\\text{M}} - \\alpha_{\\text{S}}) + \\theta_j(u_{M} - u_{S})\\] \\[log\\left(\\frac{\\pi_{\\text{L,j}}}{\\pi_{\\text{M,j}}}\\right) = (\\alpha_{\\text{L}} - \\alpha_{\\text{M}}) + \\theta_j(u_{L} - u_{M})\\] donde los \\(\\alpha_i\\) son los efectos asociados con el nivel \\(i\\) de la respuesta, \\(\\theta\\) es el efecto de intereacción entre predictora y scores, y los \\(u_i\\) son los scores asociados con la variable respuesta. Al sustituir por las correspondientes estimaciones y scores proporciona: \\[log\\left(\\frac{\\pi_{\\text{M,j}}}{\\pi_{\\text{S,j}}}\\right) = (0.0928 + 0.490) + \\theta_j (2 -1) = 0.5828 + \\theta_j \\] \\[log\\left(\\frac{\\pi_{\\text{L,j}}}{\\pi_{\\text{M,j}}}\\right) = (0 - 0.0928) + \\theta_j (3 - 2) = -0.0928 + \\theta_j\\] con \\(\\theta_1 = -1.25\\) para el placebo y \\(\\theta_2 = 0\\) para el tratamiento. Si asignamos la codificación T = treatment y P = placebo los losgits obtenidos son: \\[log\\left(\\frac{\\pi_{\\text{M,T}}}{\\pi_{\\text{S,T}}}\\right) = 0.5828; \\quad log\\left(\\frac{\\pi_{\\text{M,P}}}{\\pi_{\\text{S,P}}}\\right) = - 0.6672\\] \\[log\\left(\\frac{\\pi_{\\text{L,T}}}{\\pi_{\\text{M,T}}}\\right)= - 0.0928; \\quad log\\left(\\frac{\\pi_{\\text{L,P}}}{\\pi_{\\text{M,P}}}\\right)= - 1.3428\\] A partir de estos logits podemos obtner las probabiliddes asociadas a cada combinación de respuesta y predictora. Calculamos y representamos dichas probabilidades: # Calculamos los conteos predichos del modelo conteos &lt;- predict(fit.gripe, type = &quot;response&quot;) # Combinamos los datos originales con los predichos newdata &lt;- cbind(Gripe, conteos) # Calculamos el conteo total por las predictoras newdata.sum &lt;- newdata %&gt;% group_by(treatment) %&gt;% summarise(suma = sum(conteos)) # Calculamos las probabilidades asociadas a cada combinación newdata &lt;- newdata %&gt;% left_join(newdata.sum, by = &quot;treatment&quot;) %&gt;% mutate(prob = round(conteos/suma,4)) # Vemos las probabiliddes obtenidas dplyr::select(newdata,c(treatment, response, prob)) Tabla 14.15: treatmentresponseprob placebosmall0.608&nbsp; placebomoderate0.311&nbsp; placebolarge0.0812 vaccinesmall0.226&nbsp; vaccinemoderate0.405&nbsp; vaccinelarge0.369&nbsp; Podemos representar las probabilidades obtenidas para ver los efectos de la combinacion de predictoras en la respuesta. ggplot(newdata, aes(x = treatment, y = prob, group = response, color = response)) + geom_point() + geom_line() + labs(title = &quot;Probabilidades estimadas&quot;, x = &quot;Tratamiento&quot;, y = &quot;Probabilidad&quot;, col = &quot;Respuesta&quot;) + scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1)) ¿Cómo varían las probabilidades de la respuesta en función del tratamiento? 14.4.5 Respuesta ordinal, predictora ordinal Imaginemos que tenemos una variable respuesta y otra predictora (ambas de carácter ordinal). La modelización en esta situación pasa por definir variables ficticias de scores tanto para la predictora como la respuesta. Denotamos por \\(S\\) y \\(U\\) a las variables de scores para la respuesta y la predictora respectivamente. Calculamos la variable producto \\(P\\) en ambos scores que será introducida en el modelo para reflejar el posible efecto de interacción entre respuesta y predictora. En esta situación tenemos que: \\[log(E(Y_{ij})) = \\mu +\\alpha_i + \\beta_j + \\theta P_{ij} = \\mu +\\alpha_i + \\beta_j + \\theta S_iU_j\\] donde \\(\\mu\\) es la interceptación del modelo, \\(\\alpha_i\\) es el efecto asociado con el nivel \\(i\\) de la respuesta, \\(\\beta_j\\) es el efecto asociado con el nivel \\(j\\) de la predictora, y \\(\\theta\\) es el efecto asociado con la variable \\(P_{ij} = S_iU_j\\). En la práctica se puede demostrar que el logit para dos categorías consecutivas de la respuesta dependen únicamente de los coeficientes del modelo que afectan a la respuesta y a la interacción entre respuesta y predictora, es decir: \\[log\\left(\\frac{\\pi_{i+1|j}}{\\pi_{i|j}}\\right) = \\eta_{i+1|j} = (\\alpha_{i+1} - \\alpha_i) + \\theta (u_{i+1} - u_i)v_j\\] de forma que la relación entre ambas probabilidades viene dada por: \\[\\frac{\\pi_{i+1|j}}{\\pi_{i|j}} = exp(\\eta_{i+1|j}) = exp\\{(\\alpha_{i+1} - \\alpha_i) + \\theta (u_{i+1} - u_i)v_j\\}\\] Si queremos obtener la relación entre las probabilidades de las categorías \\(i+2\\) e \\(i\\) basta con considerar que: \\[\\frac{\\pi_{i+2|j}}{\\pi_{i|j}} = \\frac{\\pi_{i+2|j}}{\\pi_{i+1|j}}\\frac{\\pi_{i+1|j}}{\\pi_{i|j}}\\] que se puede calcular como: \\[\\frac{\\pi_{i+2|j}}{\\pi_{i|j}} = exp(\\eta_{i+2|j}) = exp\\{(\\alpha_{i+2} - \\alpha_i) + \\theta (u_{i+2} - u_i)v_j\\}\\] De esta forma podemos obtener la relación entre cualquier par de categorías de la respuesta. Actuado de esta forma resulta posible calcular la probabilidad de cada categoría de la respuesta sin más que fijar una categoría de referencia, y obtener todas las probabilidades asociadas con la de referencia. Procederíamos entonces como en el caso multinomial. Todas estas ecuaciones de estimación se pueden generalizar sin problemas cuando existe más de una variable predictora, sin más que considerar las posibles interacciones entre la respuesta y las predictoras. En caso de tratarse de variables de tipo ordinal construiremos los scores correspondientes para analizar dichos efectos de interacción. 14.4.5.1 Datos Satisfacción laboral Si tomamos como variable respuesta el grado de satisfacción, y usamos como referencia la categroria Muy Insatisfecho podemos obtener los log-odds condicionales mediante: # Creamos referencias de comparación consecutivas ref.val1 &lt;- unlist(dplyr::select(filter(Satisfaccion, Estado == &quot;Muy insatisfecho&quot;),frecuencia)) ref.val2 &lt;- unlist(dplyr::select(filter(Satisfaccion, Estado == &quot;Poco insatisfecho&quot;),frecuencia)) ref.val3 &lt;- unlist(dplyr::select(filter(Satisfaccion, Estado == &quot;Moderadamente satisfecho&quot;), frecuencia)) # Log-odds Satisfaccion &lt;- Satisfaccion %&gt;% mutate(referencia = c(rep(ref.val1, 2), ref.val2, ref.val3), lodds = log(frecuencia / referencia)) # Gráfico # Seleccionamos las categorías a representar eliminando la de referencia # Como la respuesta sólo tiene una categoría no hace falta utilizarla en el gráfico datos &lt;- filter(Satisfaccion, Estado != &quot;Muy insatisfecho&quot;) ords &lt;- c(&quot;&lt; 6000&quot;, &quot;6000 - 15000&quot;, &quot;15000 - 25000&quot;, &quot;&gt; 25000&quot;) ggplot(datos,aes(x = Ingresos, y = lodds, group = Estado, color = Estado)) + geom_point() + geom_line() + scale_x_discrete(limits = ords) + labs(x = &quot;Ingresos&quot;, y = &quot;log-odds condicionados&quot;, col = &quot;Grado de satisfacción&quot;) ¿Cómo interpretamos los log-odds condicionales entre categorías consecutivas obtenidos? Recuerda que en este caso cada perfil se debe comparar con la categoria inmediatamente inferior. En este caso queremos estudiar un posible modelo de asociación entre la satisfacción laboral en función de los ingresos percibidos. Tanto la variable respuesta como la predictora se encuentran en escala ordinal. Debemos introducir los scores asociados a ambas variables para poder considerarlos en el modelo de asociación. Creamos scores en escala continua de 1 a 4 para la satisfacción (\\(u_i\\)), y de 1 a 4 para los ingresos (\\(v_j\\)), ya que los intervalos considerados no tienen la misma amplitud en este caso y no podmeos utilizar el punto medio. La interacción entre ambas variables se reflejará mediante el producto de las variables de scores creadas. # Generamos la variable de interacción Satisfaccion &lt;- Satisfaccion %&gt;% mutate(asociacion = Ingresos.num * Estado.num) # Ajuste del modelo de independencia fit.satisfaccion.ind &lt;- glm(frecuencia ~ Ingresos + Estado, family = poisson(), data = Satisfaccion) # Ajuste del modelo de asociación fit.satisfaccion &lt;- glm(frecuencia ~ Ingresos + Estado + asociacion, family = poisson(), data = Satisfaccion) # Comparamos ambos modelos anova(fit.satisfaccion.ind, fit.satisfaccion, test = &quot;Chisq&quot;) Tabla 14.16: Resid. DfResid. DevDfDeviancePr(&gt;Chi) 912&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 82.3919.650.00189 Rechazamos el modelo de independencia a favor del modelo de asociación que obtenemos con los scores. Veamos el resumen del modelo: tabla &lt;- tidy(fit.satisfaccion)[,c(&quot;term&quot;, &quot;estimate&quot;)] tabla Tabla 14.17: termestimate (Intercept)3.98&nbsp;&nbsp; Ingresos&gt; 25000-1.26&nbsp;&nbsp; Ingresos15000 - 25000-0.577&nbsp; Ingresos6000 - 15000-0.0105 EstadoMuy insatisfecho-1.13&nbsp;&nbsp; EstadoMuy satisfecho-0.0181 EstadoPoco insatisfecho-0.823&nbsp; asociacion0.112&nbsp; Seleccionamos los efectos necesarios para el ajuste de los logits y la estimación de probabilidades. Estos efectos son los relacionados (principales e interacciones) con la variable Estado. # Filas de la tabla de estimaciones relacionados con metodo tabla[5:8,] Tabla 14.18: termestimate EstadoMuy insatisfecho-1.13&nbsp;&nbsp; EstadoMuy satisfecho-0.0181 EstadoPoco insatisfecho-0.823&nbsp; asociacion0.112&nbsp; Para la obtención de los logits vinculados con este modelo usamos la codificación Muy Insatisfecho = S1, Poco Insatisfecho = S2, Moderadamente Satisfecho = S3, y Muy Satisfecho = S4 para la variable Estado, y &lt; 6000 = I1, 6000 - 15000 = I2, 15000 - 25000 = I3, y &gt; 25000 = I4 para la variable ingresos, de forma que las ecuaciones de los logit para este modelo vienen dadas por: \\[log\\left(\\frac{\\pi_{\\text{S4|j}}}{\\pi_{\\text{S3|j}}}\\right) = (\\alpha_{\\text{S4|j}} - \\alpha_{\\text{S3|j}} ) + \\theta (u_{\\text{S4|j}} - u_{\\text{S3|j}})v_j\\] \\[log\\left(\\frac{\\pi_{\\text{S3|j}}}{\\pi_{\\text{S2|j}}}\\right) = (\\alpha_{\\text{S3|j}} - \\alpha_{\\text{S2|j}} ) + \\theta (u_{\\text{S3|j}} - u_{\\text{S2|j}})v_j\\] \\[log\\left(\\frac{\\pi_{\\text{S2|j}}}{\\pi_{\\text{S1|j}}}\\right) = (\\alpha_{\\text{S2|j}} - \\alpha_{\\text{S1|j}} ) + \\theta (u_{\\text{S2|j}} - u_{\\text{S1|j}})v_j\\] donde los \\(\\alpha_i\\) son los efectos asociados con el nivel \\(i\\) de la respuesta, \\(\\theta\\) es el efecto de intereacción entre scores (asociacion), los \\(u_i\\) son los scores asociados con Estado, y los \\(u_i\\) son los scores asociados con Ingresos. Al sustituir por las correspondientes estimaciones y scores proporciona: \\[log\\left(\\frac{\\pi_{\\text{S4|j}}}{\\pi_{\\text{S3|j}}}\\right) = (-0.0181 - 0) + 0.112*(4-3)* v_j = -0.0181 + 0.112 * v_j\\] \\[log\\left(\\frac{\\pi_{\\text{S3|j}}}{\\pi_{\\text{S2|j}}}\\right) = (0 + 0.823) + 0.112*(3-2)* v_j = 0.823 + 0.112 * v_j\\] \\[log\\left(\\frac{\\pi_{\\text{S2|j}}}{\\pi_{\\text{S1|j}}}\\right) = (-0.823 + 1.13) + 0.112*(2-1)* v_j = 0.307 + 0.112 * v_j\\] Sustiyuendo los \\(v_j\\) podemos establecer la relación entre las probabildiades de dos categorias consecutivas de la respuesta. Finalmente obtnemos las probabilidades asociadas al modelo ajustado. # Calculamos los conteos predichos del modelo conteos &lt;- predict(fit.satisfaccion, type = &quot;response&quot;) # Combinamos los datos originales con los predichos newdata &lt;- cbind(Satisfaccion, conteos) # Calculamos el conteo total por las predictoras newdata.sum &lt;- newdata %&gt;% group_by(Ingresos) %&gt;% summarise(suma = sum(conteos)) # Calculamos las probabilidades asociadas a cada combinación newdata &lt;- newdata %&gt;% left_join(newdata.sum, by = &quot;Ingresos&quot;) %&gt;% mutate(prob = round(conteos/suma,4)) # Vemos las probabiliddes obtenidas dplyr::select(newdata,c(Ingresos, Estado, prob)) Tabla 14.19: IngresosEstadoprob &lt; 6000Muy insatisfecho0.0939 6000 - 15000Muy insatisfecho0.0741 15000 - 25000Muy insatisfecho0.0578 &gt; 25000Muy insatisfecho0.0447 &lt; 6000Poco insatisfecho0.143&nbsp; 6000 - 15000Poco insatisfecho0.126&nbsp; 15000 - 25000Poco insatisfecho0.11&nbsp;&nbsp; &gt; 25000Poco insatisfecho0.0952 &lt; 6000Moderadamente satisfecho0.364&nbsp; 6000 - 15000Moderadamente satisfecho0.359&nbsp; 15000 - 25000Moderadamente satisfecho0.35&nbsp;&nbsp; &gt; 25000Moderadamente satisfecho0.339&nbsp; &lt; 6000Muy satisfecho0.4&nbsp;&nbsp;&nbsp; 6000 - 15000Muy satisfecho0.441&nbsp; 15000 - 25000Muy satisfecho0.482&nbsp; &gt; 25000Muy satisfecho0.521&nbsp; Podemos representar las probabilidades obtenidas para ver los efectos de la combinacion de predictoras en la respuesta. ords &lt;- c(&quot;&lt; 6000&quot;, &quot;6000 - 15000&quot;, &quot;15000 - 25000&quot;, &quot;&gt; 25000&quot;) ggplot(newdata, aes(x = Ingresos, y = prob, group = Estado, color = Estado)) + geom_point() + geom_line() + scale_x_discrete(limits = ords) + labs(title = &quot;Probabilidades estimadas&quot;, x = &quot;Ingresos&quot;, y = &quot;Probabilidad&quot;, col = &quot;Nivel de satisfacción&quot;) + scale_y_continuous(breaks = seq(0, 1, by = 0.1), limits = c(0, 1)) ¿Cómo evolucionan las probabilidades del nivel de satisfacción en función de los ingresos percibidos? 14.5 Diagnóstico El diagnóstico de este tipo de modelos se parece al diagnóstico de los modelos de poisson. Dado que sólo tenemos un valor predicho y un residuo por cada combinación de niveles el diagnóstico nos limitaremos a: Realizar el gráfico de residuos vs ajustados del predictor lineal, para detectar problema de linealidad y/o homogeneidad. Realizar el gráfico de valores predichos (frecuencias predichas) vs observados (frecuenias observadas), para conocer la precisión en la predicción de la frecuencia de interés. A continuación pasamos a analizar los ejemplos tratados en el punto anterior. 14.5.1 Ejemplos Para el análisis diagnóstico utilizamos la función fortify que nos proporciona tanto los valores de predicción del preditor lineal y los residuos estandarizados, mientras que la predicción de la respuesta ya hemos visto en el punto anterior como obtenerla como una nueva columna denominada conteos. 14.5.1.1 Aspirina En primer luagr realizamos el gráfico de residuos versus ajustados (predictor lineal). # Valores de diganóstico diagnostico &lt;- fortify(fit.aspirina) # Gráfico Residuos vs ajustados ggplot(diagnostico, aes(.fitted, .stdresid)) + geom_point() + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) + geom_hline(yintercept = 0) Dado que hay tan pocas observaciones resulta díficl poder concluir que existe algún problema con las hipótesis del modelo. Comprobamos la bondad del modelo representando los valores originales de frecuencias frente a los valores ajustados. # Valores predichos Aspirina &lt;- Aspirina %&gt;% mutate(conteo = predict(fit.aspirina, type = &quot;response&quot;)) # Gráfico Residuos vs ajustados ggplot(Aspirina, aes(conteo, frecuencia)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Predicción frecuencia&quot;, y = &quot;Frecuencia observada&quot;) El ajuste conseguido es bastante bueno dado que los valores se presentan a los largo de la diagonal, que representa el ajuste perfecto. 14.5.1.2 Aspiraciones En primer luagr realizamos el gráfico de residuos versus ajustados (predictor lineal). # Valores de diganóstico diagnostico &lt;- fortify(fit.aspiraciones) # Gráfico Residuos vs ajustados ggplot(diagnostico, aes(.fitted, .stdresid)) + geom_point() + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) + geom_hline(yintercept = 0) Parece intuirse que existe una mayor variabilidad conforme aumenta el valor ajustado pero no resulta muy concluyente. Comprobamos la bondad del modelo representando los valores originales de frecuencias frente a los valores ajustados. # Valores predichos Aspiraciones &lt;- Aspiraciones %&gt;% mutate(conteo = predict(fit.aspiraciones, type = &quot;response&quot;)) # Gráfico Residuos vs ajustados ggplot(Aspiraciones, aes(conteo, frecuencia)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Predicción frecuencia&quot;, y = &quot;Frecuencia observada&quot;) El ajuste conseguido es bastante bueno dado que los valores se presentan a los largo de la diagonal, que representa el ajuste perfecto. 14.5.1.3 Contraceptivos En primer luagr realizamos el gráfico de residuos versus ajustados (predictor lineal). # Valores de diganóstico diagnostico &lt;- fortify(fit.contraceptivos) # Gráfico Residuos vs ajustados ggplot(diagnostico, aes(.fitted, .stdresid)) + geom_point() + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) + geom_hline(yintercept = 0) ¿Qué opinas sobre el gráfico? Comprobamos la bondad del modelo representando los valores originales de frecuencias frente a los valores ajustados. # Valores predichos Contraceptivos &lt;- Contraceptivos %&gt;% mutate(conteo = predict(fit.contraceptivos, type = &quot;response&quot;)) # Gráfico Residuos vs ajustados ggplot(Contraceptivos, aes(conteo, frecuencia)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Predicción frecuencia&quot;, y = &quot;Frecuencia observada&quot;) El ajuste conseguido es bastante bueno dado que los valores se presentan a los largo de la diagonal, que representa el ajuste perfecto. 14.5.1.4 Gripe En primer luagr realizamos el gráfico de residuos versus ajustados (predictor lineal). # Valores de diganóstico diagnostico &lt;- fortify(fit.gripe) # Gráfico Residuos vs ajustados ggplot(diagnostico, aes(.fitted, .stdresid)) + geom_point() + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) + geom_hline(yintercept = 0) ¿Qué opinas sobre el gráfico? Comprobamos la bondad del modelo representando los valores originales de frecuencias frente a los valores ajustados. # Valores predichos Gripe &lt;- Gripe %&gt;% mutate(conteo = predict(fit.gripe, type = &quot;response&quot;)) # Gráfico Residuos vs ajustados ggplot(Gripe, aes(conteo, frequency)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Predicción frecuencia&quot;, y = &quot;Frecuencia observada&quot;) ¿Qué opinas de la calidad del ajuste? 14.5.1.5 Satisfacción laboral En primer lugar realizamos el gráfico de residuos versus ajustados (predictor lineal). # Valores de diganóstico diagnostico &lt;- fortify(fit.satisfaccion) # Gráfico Residuos vs ajustados ggplot(diagnostico, aes(.fitted, .stdresid)) + geom_point() + labs(x = &quot;Ajustados&quot;, y = &quot;Residuos&quot;) + geom_hline(yintercept = 0) ¿Qué opinas sobre el gráfico? Comprobamos la bondad del modelo representando los valores originales de frecuencias frente a los valores ajustados. # Valores predichos Satisfaccion &lt;- Satisfaccion %&gt;% mutate(conteo = predict(fit.satisfaccion, type = &quot;response&quot;)) # Gráfico Residuos vs ajustados ggplot(Satisfaccion, aes(conteo, frecuencia)) + geom_point() + geom_abline(intercept = 0, slope = 1) + labs(x = &quot;Predicción frecuencia&quot;, y = &quot;Frecuencia observada&quot;) ¿Qué opinas de la calidad del ajuste? 14.6 Predicción La predicción en este tipo de modelos pasa por estimar: los conteos predichos para comninación de variables incluidas en el modelo, las probabilidades de ocurrencia de cada combinación. Dado que en puntos anteriores ya hemos visto como obtener dichos valores de interés no repetoremos de nuevo dichos calculos. 14.7 Ejercicios Colección de ejercicios sobre modleos lineales generalizados con respuesta binomial. Los pasos a seguir para la obtención del modelo son los que hemos ido desarrollando: representación gráfica y propuesta de modelo, ajuste, bondad de ajuste, diagnóstico y predicción. En caso de encontrar problemas con el diagnóstico se deberá proponer un nuevo modelo alternativo. No olvides cargar las librerías para realizar los ejercicios. Ejercicio 1. En el banco de datos siguiente aparecen los datos de un estudio sobre la actividad sexual de los adolescentes entre 15 y 16 años. El objetivo básico de interés radica en conocer si han tenido o no relaciones sexuales. Las datos son el número de adolescentes (frecuencia) que han tenido o no relaciones sexuales (relaciones) en función del sexo del adolescente (sexo) y su raza (raza). Realiza un análisis preliminar de los datos recogidos y contesta a las siguientes preguntas ajustando el modelo que corresponda en cada caso: ¿Hay diferencias entre individuos de raza blanca y de raza negra respecto al hecho de haber tenido relaciones sexuales antes de los 16 años? ¿Y entre chicos y chicas? Predice la proporción de individuos que han tenido relaciones sexuales antes de los 16 años en función de su sexo y raza. raza &lt;- gl(2, 4, 8, labels = c(&quot;Blanca&quot;, &quot;Negra&quot;)) sexo &lt;- gl(2, 2, 8, labels = c(&quot;Hombre&quot;, &quot;Mujer&quot;)) relaciones &lt;- gl(2, 1, 8, labels = c(&quot;Si&quot;, &quot;No&quot;)) frecuencia &lt;- c(43, 134, 26, 149, 29, 23, 22, 36) ejercicio01 &lt;- data.frame(raza, sexo, relaciones, frecuencia) Ejercicio 2. Los datos que se presentan corresponden a una encuesta social en Dinamarca, en la que se clasificó a 165 individuos según su estatus marital (soltero, casado, o divorciado alguna vez} y su edad. Se pretendía establecer una relación entre las variables estatus marital y edad, con el fin de concluir sobre el comportamiento social en Dinamarca. Identifica las variables involucradas en el análisis de estos datos. ¿Cuáles son de tipo cualitativo -nominal u ordinal- y cuáles cuantitativas? A la vista de los datos y del gráfico de número de individuos versus edad para cada status marital, ¿aprecias algún tipo de tendencia entre edad y estatus marital? El efecto de la edad, ¿es similar para los solteros, los casados y los divorciados? ¿Existe alguna relación entre el estatus marital y la edad? Tu conclusión, ¿es coherente con lo que comentaste en el apartado anterior? Si pretendemos llevar a cabo un análisis predictivo y explicar la proporción de individuos en cada uno de los estatus maritales en función de la edad, ¿cuál es la variable a explicar y cuál la explicativa? Incorporando toda la información de que dispones. propón. formula y ajusta un modelo log-lineal útil para concluir sobre la relación entre edad y estatus marital. Comenta las hipótesis que asumes y tus conclusiones. Construye la variable log(edad-16)y y representa el gráfico del punto 2 para esta nueva variable (sustituyendo la variable edad). Ajusta el modelo log-lineal más acertado para representar dicha información. Extrae las conclusiones de dicho modelo. Compara las probabilidades condicionadas de estatus dado edad para el modelo anterior. Para el grupo de edad 40-50, ¿cuál es la relación que predices entre las proporciones de individuos en cada estatus marital? ¿Qué es lo más común en ese grupo de edad? edad &lt;- gl(8, 3, 24, labels = c(&quot;17-21&quot;, &quot;21-25&quot;, &quot;25-30&quot;, &quot;30-40&quot;, &quot;40-50&quot;, &quot;50-60&quot;, &quot;60-70&quot;, &quot;+70&quot;)) estado &lt;- gl(3, 1, 24, labels = c(&quot;Solteros&quot;, &quot;Casados&quot;, &quot;Divorciados&quot;)) frecuencia &lt;- c(17, 1, 0, 16, 8, 0, 8, 17, 1, 6, 22, 4, 5, 21, 6, 3, 17, 8, 2, 8, 6, 1, 3, 5) edad.num &lt;- rep(c(19, 23, 27.5, 35, 45, 55, 65, 75), c(3, 3, 3, 3, 3, 3, 3, 3)) ejercicio02 &lt;- data.frame(edad, estado, frecuencia, edad.num) Ejercicio 3. Los datos que se presentan corresponden al status de supervivencia, tras tres años, de pacientes con cáncer de mama, clasificados por su edad (en tres grupos) y por el tipo de tumor (maligno o benigno). Formula al menos dos preguntas de interés científico para contestar a partir de los datos anteriores. Formula el modelo a ajustar suponiendo que existe independencia completa entre los tres factores de clasificación. Contrasta la hipótesis de independencia completa. Formula el modelo correspondiente a la hipótesis de que el que una paciente sobreviva no tiene nada que ver con su edad o con el tipo de tumor que padece, y resuelve el contraste. Formula el modelo correspondiente a la hipótesis de que en cada grupo de edad, el que una paciente sobreviva o no es independiente del tipo de tumor, y resuelve el contraste. Consigue el mejor ajuste para explicar los datos de supervivencia al cáncer de mama. Justifícalo y formula explícitamente el modelo que has ajustado. ¿Cómo están relacionados la supervivencia de una paciente, con su edad y con el tipo de tumor que padece? Identifica los coeficientes que explican dicha relación. Según el modelo que has ajustado, calcula el número de pacientes que se espera que sobrevivan en función del grupo de edad al que pertenecen y el tipo de tumor que padecen. edad &lt;- gl(3, 2, 12, labels = c(&quot;&lt;50&quot;, &quot;50-69&quot;, &quot;&gt;70&quot;)) maligno &lt;- gl(2, 1, 12,labels = c(&quot;No&quot;, &quot;Si&quot;)) supervivencia &lt;- gl(2, 6, 12, labels = c(&quot;Si&quot;, &quot;No&quot;)) frecuencia &lt;- c(77, 51, 51, 38, 7, 6, 10, 13, 11, 20, 3, 3) edad.num &lt;- c(40, 40, 60, 60, 80, 80, 40, 40, 60, 60, 80, 80) ejercicio03 &lt;- data.frame(edad, maligno, supervivencia, frecuencia, edad.num) Ejercicio 4. En la Fiji Fertility Survey de 1975 se entrevistó a 1607 mujeres casadas y embarazadas. Fueron clasificadas por edad actual (4 grupos), nivel de estudios (2 niveles), deseo de tener más hijos y uso de contraceptivos. ¿Están relacionados factores como la educación, la edad o simplemente el deseo de no tener más hijos, con el uso de contraceptivos? edad &lt;- gl(4, 4, 32, labels = c(&quot;&lt;25&quot;, &quot;25-29&quot;, &quot;30-39&quot;, &quot;40-49&quot;)) estudios &lt;- gl(2, 2, 32, labels = c(&quot;Baja&quot;, &quot;Alta&quot;)) hijos &lt;- gl(2, 1, 32, labels = c(&quot;Si&quot;, &quot;No&quot;)) contraceptivos &lt;- gl(2, 16, 32, labels = c(&quot;Si&quot;, &quot;No&quot;)) frecuencia &lt;- c(53, 10, 212, 50, 60, 19, 155, 65, 112, 77, 118, 68, 35, 46, 8, 12, 6, 4, 52, 10, 14, 10, 54, 27, 33, 80, 46, 78, 6, 48, 8, 31) edad.num &lt;- rep(c(22.5, 27.5, 35, 45, 22.5, 27.5, 35, 45), c(4, 4, 4, 4, 4, 4, 4, 4)) ejercicio04 &lt;- data.frame(edad, estudios, hijos, contraceptivos, frecuencia, edad.num) Ejercicio 5. En el banco de datos siguiente recoge la información de un estudio sobre la vinculación del cáncer de pulmón y el consumo de tabaco. Se registra la información de hombres ingresados en hospitales enfermos de cáncer de pulmón y enfermos por otras causas (controles) y se les preguntó sobre su consumo diario de cigarros. ¿Existe relación entre el consumo de cigarros y tener cáncer de pulmón? Si es así ¿cómo cambia la probabilidad de tener cáncer de pulmón en función del consumo diario de cigarros? consumo &lt;- gl(6, 1, 12, labels = c(&quot;Ninguno&quot;, &quot;&lt;5&quot;, &quot;5-14&quot;, &quot;15-24&quot;, &quot;25-49&quot;, &quot;50+&quot;)) sujeto &lt;- gl(2, 6, 12, labels = c(&quot;cáncer&quot;, &quot;control&quot;)) frecuencia &lt;- c(7, 55, 489, 475, 293, 38, 61, 129, 570, 431, 154, 12) edad.num &lt;- rep(c(0, 2.5, 9.5, 19.5, 37, 55), 2) ejercicio05 &lt;- data.frame(consumo, sujeto, frecuencia, edad.num) Ejercicio 6. En el banco de datos siguiente recoge la información de un estudio sobre el estudio de cierta sustancia farmacológica que potencialmente podría acarrear malformaciones en el feto. Para ello se toma una muestra de ratones embarazados, se les aplica diferente concentraciones de fármaco y se observan los resultados tras el embarazo (“Muerto,” “Malformaciones,”“Normal”). La concentración, medida en mg/kg por día, tiene los niveles: “N0” = 0, “N1” = 62.5, “N2” = 125, “N3” = 250, “N4” = 500. ¿Influye la concentración en las características finales del feto? Si utilizamos los valores numéricos de concentración ¿Como varía el estado del feto en función de dicha concentración? concentracion &lt;- gl(5 ,1, 15,labels = c(&quot;N0&quot;, &quot;N1&quot;, &quot;N2&quot;, &quot;N3&quot;, &quot;N4&quot;)) concentracion.num &lt;- rep(c(0, 62.5, 125, 250, 500), 3) estado &lt;- gl(3, 5, 15, labels = c(&quot;Muerto&quot;, &quot;Malformaciones&quot;, &quot;Normal&quot;)) ejercicio06 &lt;- data.frame(concentracion, concentracion.num, estado) "],["glmsuperv.html", "Unidad 15 GLM para datos de supervivencia 15.1 Funciones de supervivencia 15.2 Análisis preliminar 15.3 Modelos de supervivencia 15.4 Ejercicios", " Unidad 15 GLM para datos de supervivencia El análisis de supervivencia examina y modela el tiempo que tardan en producirse lo que denominamos “eventos” aleatorios. Habitualmente dicho evento se asocia con la muerte del sujeto bajo estudio lo que justifica su nombre como análisis de supervivencia. Sin embargo el ámbito de aplicación es mucho más amplio. Esencialmente, la misma metodología utilizada para el estudio de mortalidad se utiliza para el “análisis de eventos históricos” en sociología y el “análisis del tiempo de fallo” en ingeniería. Cuando se toman datos sobre tiempos de supervivencia en un conjunto de sujetos, se toma como resultado de dicha variable: el tiempo en que acontece el suceso (el sujeto muere, la máquina falla, la enfermedad remite,etc… o el tiempo transcurrido hasta la finalización del periodo de seguimiento del experimento. Tenemos por tanto, dos posibilidades para cada sujeto en función se si ocurre o no el evento de interés. Los sujetos en los que al finalizar el periodo bajo estudio no se ha registrado el evento de interés se denominan datos censurados o incompletos. Las observaciones censuradas aún contienen información importante. Se sabe que al final del período de observación, un individuo con dato censurado es un individuo sobre el que no ha ocurrido el evento de interés, es decir, un individuo cuyo tiempo de vida supera al tiempo del periodo de observación. Los tipos de censura más habituales son: censura por tiempo, que ocurre cuando se deja de observar a los individuos una vez que ha transcurrido un intervalo fijo de tiempo. En consecuencia, no se sabe si actualmente a ocurrido el evento de interés o no. Es frecuente en estudios médicos. censura por fallo: si a lo largo del período de estudio se “pierden” casos (pacientes que dejan ele asistir a las revisiones, etc.), a pesar ele que el estudio prosiga hasta conseguir información completa sobre un número fijo de casos. Es común en tests industriales, donde para modelizar el proceso de fallos se observa, en cada máquina, el tiempo transcurrido hasta que tienen un fallo; el objetivo en estos tests es predecir cada cuanto tiempo acontece un fallo. Sin embargo, los casos pueden desaparecer por razones no relacionadas con el estudio o más allá del control del investigador. Esto puede estar o no ligado a la respuesta o a las variables predictoras (por ejemplo, testando un fármaco, un paciente decide suspender el tratamiento debido a los efectos secundarios que le ha provocado). Por tanto, el análisis de supervivencia se centra en estudiar la función de distribución del tiempo de supervivencia o tiempo hasta que ocurre el evento de interés. El caso más interesante aparece cunado disponemos de variables predictoras que pueden influir en el tiempo de supervivencia. En este tema estudiamos este tipo de modelos y más concretamente los conocidos como modelos de regresión de Cox. A continuación se muestran los diferentes ejemplos que trabajaremos a lo largo del tema. Ejemplo Leucemia. Los datos siguientes provienen de un estudio de supervivencia en pacientes con leucemia mielógena aguda. las variables consideradas son time (tiempo de supervivencia o censura en semanas), status (valor 1 cuando el paciente ha fallecido y 0 si el dato está censurado), y x que indica para cada sujeto si el ciclo estándar de quimioterapia debería extenderse (Maintained) para ciclos adicionales o no (Nonmaintained). La pregunta de interés es si el matenimiento de la quimioteapia mejora la supervivencia de los pacientes. Ejemplo Cáncer de pulmón. Los datos siguientes provienen de un estudio de supervivencia en pacientes con cáncer de pulmón avanzado del North Central Cancer Treatment Group. A cada paicnete se le pasan diferentes test para medir su capacidad para desempeñarse habitualmente, así ocm variables asociadas con su alimentación. El conjunot de variable consideradas son: inst (código de la institución), time (tiempo de supervivencia en días), status (estado de la censura 1=censurado, 2=muerto), age (edad in años), sex (masculino=1 femenino=2), ph.ecog (puntuación del test ECOG (0=buen estado 5=muerto)), ph.karno (puntuación del test de Karnofsky (malo=0-bueno=100)), pat.karno (test de Karnofsky estandarizado por paciente), meal.cal (conusmo de calorias), wt.loss (peso pérdido en los últimos seis meses). Se desea estudiar la supervivencia de los pacientes en función de las variables registradas. Ejemplo Ratas. Los datos siguientes provienen de un estudio de supervivencia en ratas. El experimneto consistía en estudiar el efecto de un nuevo tratamiento para un tumor cerebral. Se elegían tres ratas de cada una de 100 camadas y se les generaba un tumor cerebral. Las ratas eran divididas en dos grupos de forma que unas eran tratados con radioterapía y las otras no recibían ningún tratamiento. Las variables consideradas son: litter (camada de la que proviene la rata), rx (1 = radioterapia, 0 = control), time (supervivencia en días), status (0 = censurado, 1 = muerta), sex (f = femenino, m = masculino). El objetvo es estudiar la supervivencia de las ratas en función de las variables consideradas. Ejemplo Ovarian Los datos siguientes provienen de un estudio de supervivencia en mujeres con cáncer de ovarios sometidas a dos tratamientos distintos. Las variables consideradas son: futime (tiempo de supervivencia en días), fustat (estado de la censura 0 = censurado, 1 = defunción), age (edad de la paciente), resid.ds (persistencia de la enfermedad tras el tratamiento 1 = No, 2 = Si), rx (tratamiento a la que es sometida la paciente), ecog.ps (puntuación del test ECOG 1= buen estado). El objetvo es estudiar la supervivencia de las pacientes en función de las variables consideradas. Ejemplo Retinopatia Se realiza un ensayo clínico para estudiar la coagulacióncon láser como tratamiento para retrasar la retinopatía diabética. Los 197 pacientes en este conjunto de datos fueron una muestra aleatoria del 50% de los pacientes con retinopatía diabética de “alto riesgo” tal como se define en el Estudio de Retinopatía Diabética (DRS). Cada paciente tenía un ojo asignado al azar al tratamiento con láser y el otro ojo no recibió tratamiento, y tiene dos observaciones en el conjunto de datos. Para cada ojo, el evento de interés fue el tiempo desde el inicio del tratamiento hasta el momento en que la agudeza visual cayó por debajo de 5/200 dos visitas seguidas. Por lo tanto, hay un retraso incorporado de aproximadamente 6 meses (las visitas fueron cada 3 meses). Los tiempos de supervivencia en este conjunto de datos son el tiempo real de pérdida de la visión en meses, menos el tiempo mínimo posible para el evento (6,5 meses). Las variables consideradas son: id (identificación del sujeto), laser (tipo de láser usado xenon o argon), eye (que ojo se ha tratado: left, right ), age (edad al diagnóstico de diabetes), type (tipo de diabetes: juvenile adult), trt (0 = control eye, 1 = treated eye), futime (tiempo hasta de pérdida de visión o finalización del seguimiento), status (0 = censurado, 1 = pérdida de visión en el ojo), risk (un score de riesgo para el ojo, con un valor mayor que 6 indicando riesgo alto en al menos un ojo). Ejemplo Mieloma Datos de mieloma múltiple extraídos de datos de expresión génica disponibles públicamente (ID GEO: GSE4581). Las variables consideradas son: molecular_group (grupo molecular de pacientes), chr1q21_status (estado de amplificación del cromosoma 1q21), treatment (tratamiento), event (estado de supervivencia 0 = censurado, 1 = muerto), time (tiempo de supervivencia en meses), CCND1, CRIM1, DEPDC1, IRF4, TP53, WHSC1 son las expresiones de los genes. Ejemplo Veteranos Datos sobre un ensayo aleatorizado de dos regímenes de tratamiento para el cáncer de pulmón en veteranos de guerra. Las variables consideradas son: trt (tratamiento 1=standard 2=test), celltype (1=squamous, 2=smallcell, 3=adeno, 4=large), time (tiempo de supervivencia), status (estado censura 0=censurada), karno (puntuación del test de Karnofsky (100=good)), diagtime (meses desde el diagnóstico hasta la aleatorización), age (en años), prior (si se aplico una terapia anterior 0=no, 1=yes.) 15.1 Funciones de supervivencia Antes de presentar el modelos de regresión de Cox estableemos la notación y definiciones necesarias para el estudio de este tipo de modelos. Si \\(f(t)\\) denota a la función de densidad de probabilidad para la variable aleatoria \\(T\\), tiempo de supervivencia, y \\(F(t)\\) a la correspondiente función de distribución, entonces se define la función de supervivencia \\(S(t)\\) como la probabilidad de sobrevivir al menos hasta el instante \\(t\\), esto es, \\[S(t) = P(T &gt; t) = 1 - F(t)\\] Se define el riesgo instantáneo de morir o función hazard, \\(h(t)\\), como el cociente entre la función de densidad y la función de supervivencia, es decir: \\[h(t) = \\frac{f(t)}{S(t)}\\] De hecho, \\(h(t)dt\\) o incremento de la función hazard representa la intensidad del proceso de ocurrencia del evento, o lo que es lo mismo, la probabilidad de que ocurra el evento en un intervalo pequeño de tiempo \\(dt\\) dado que el individuo no ha registrado el evento de interés hasta el instante \\(t\\). Una distribución para los tiempos de supervivencia ha de tener una función hazard con buenas propiedades; por ejemplo, es de esperar que la función hazard no decrezca con \\(t\\), esto es, a más tiempo transcurrido, mayor riesgo de de que ocurra el evento de interés. Teniendo esto en cuenta, se define la función hazard acumulada, \\(H(t)\\) como: \\[H(t) = - log S(t)\\] Una característica importante de la función de supervivencia es la denominada mediana de supervivencia que es el valor de \\(t_{0.5}\\) de forma que: \\[S(t_{0.5}) = 0.5\\]. Asociado con este valor se puede obtener un intervalo de confianza para la mediana de supervivencia. Para la modelización de este tipo de datos necesitamos instalar las librerías survival y survminer. 15.1.1 Supervivencia completa En este caso estamos interesados en estimar la curva de supervivencia completa para todo el conjunto de sujetos. La estimación de dichas funciones de supervivencia se realizan mediante las funciones: # Tiempo de supervivencia y estado de la censura Surv(time, status) # Estimación de la supervivencia sin variables predictoras survfit(Surv(time, status) ~ 1, data = dataset) donde time identifica la variable con los tiempo de supervivencia, status es la variable que identifica si el dato está censurado o no, y \\(~ 1\\) indica que obtenemos la curva de supervivencia completa. Habitualmente se usa la codificación 0-1 donde el cero indica que el tiempo está censurado y 1 cuando ha ocurrido el evento de interés. El resultado de esta función se puede representar para obtener una primera aproximación de la función de supervivencia o conocido como estimador de Kaplan-Meier. 15.1.2 Supervivencia por un factor La primera aproximación para la comparación de curvas de supervivencia es utilizar un factor que separa a la población de sujeto en grupos. En esta situación se puede estimar la curva de supervivencia para cada uno de los grupos. Este proceso se realiza mediante la función: # Estimación de la supervivencia sin variables predictoras survfit(Surv(time,status) ~ factor, data = dataset) donde factor identifica la variable de clasificación. 15.1.3 Test de comparación Dadas dos o más curvas de supervivencia estas se pueden comparar a través de las funciones hazard asociadas a cada una de ellas. Si tenemos \\(k\\) curvas de supervivencia y sus funciones hazard asociadas (\\(h_1(t), h_2(t),...,h_k(t)\\)) el test de comparación viene dado por: \\[\\begin{array}{ll} H_0:&amp; h_1(t) = h_2(t) = ... = h_k(t)\\\\ H_1:&amp; \\text{existen al menos dos } h_i(t) \\text{ y } h_j(t) \\text{ distintas}\\\\ \\end{array}\\] La resolución de este contraste se basa en un test ji-cuadrado. Si rechazamos \\(H_0\\) concluiremos que existen al menos dos curvas de supervivencia distintas. Si tenemos solamente dos curvas el contraste permite establecer si las consideramos iguales o distintas. 15.2 Análisis preliminar En este análisis preliminar no nos preocupamos por el posible efecto que pueden tener las diferentes variables predictoras en la supervivencia, sino más bien en un estudio descriptivo de la supervivencia global o por un factor de clasificación. Mostramos los resultados para diferentes bancos de datos de los presentados al inicio de este tema. Todos los bancos de datos son accesibles directamente ya que se encuentran alojados dentro de la librería survival. 15.2.1 Leucemia Para este conjunto de datos obtenemos y representamos la estimación de la curva de supervivencia global así como la mediana de supervivencia. # Estimación fit &lt;- survfit(Surv(time,status) ~ 1, data = aml) fit ## Call: survfit(formula = Surv(time, status) ~ 1, data = aml) ## ## n events median 0.95LCL 0.95UCL ## [1,] 23 18 27 18 45 summary(fit) ## Call: survfit(formula = Surv(time, status) ~ 1, data = aml) ## ## time n.risk n.event survival std.err lower 95% CI upper 95% CI ## 5 23 2 0.9130 0.0588 0.8049 1.000 ## 8 21 2 0.8261 0.0790 0.6848 0.996 ## 9 19 1 0.7826 0.0860 0.6310 0.971 ## 12 18 1 0.7391 0.0916 0.5798 0.942 ## 13 17 1 0.6957 0.0959 0.5309 0.912 ## 18 14 1 0.6460 0.1011 0.4753 0.878 ## 23 13 2 0.5466 0.1073 0.3721 0.803 ## 27 11 1 0.4969 0.1084 0.3240 0.762 ## 30 9 1 0.4417 0.1095 0.2717 0.718 ## 31 8 1 0.3865 0.1089 0.2225 0.671 ## 33 7 1 0.3313 0.1064 0.1765 0.622 ## 34 6 1 0.2761 0.1020 0.1338 0.569 ## 43 5 1 0.2208 0.0954 0.0947 0.515 ## 45 4 1 0.1656 0.0860 0.0598 0.458 ## 48 2 1 0.0828 0.0727 0.0148 0.462 # Gráfica de la función de supervivencia y mediana de supervivencia # conf.int: permite obtner el intervalo de confinaza para la curva de supervivencia # surv.median.line: permite represenatr la mediana de supervivencia ggsurvplot(fit, data = aml, palette = &quot;blue&quot;, conf.int = FALSE, surv.median.line = &quot;hv&quot;) La mediana de supervivencia se sitúa en 27 semanas con un intervalo de confianza del 95% entre 18 y 45 semanas. En el resumen podemos ver como evoluciona la supervivencia con el tiempo. A partir del gráfico podemos ver que la probabilidad de sobrevivir más de 40 semanas se sitúa por debajo de 0.25. Realizamos ahora el análisis diferenciando por la variable ‘x’ que indica si el sujeto ha mantenido o no el ciclo de quimioterapia. Representamos las curvas de supervivencia, la mediana de supervivencia, y el pvalor del contraste de comparación de funciones hazard. Añadimos además el intervalo de confianza para la curva de supervivencia de cada grupo. # Estimación fit &lt;- survfit(Surv(time,status) ~ x, data = aml) fit ## Call: survfit(formula = Surv(time, status) ~ x, data = aml) ## ## n events median 0.95LCL 0.95UCL ## x=Maintained 11 7 31 18 NA ## x=Nonmaintained 12 11 23 8 NA # Gráfica de la función de supervivencia y mediana de supervivencia # conf.int: permite obtner el intervalo de confinaza para la curva de supervivencia # surv.median.line: permite represenatr la mediana de supervivencia ggsurvplot(fit, data = aml, conf.int = TRUE, conf.int.style = &quot;step&quot;, surv.median.line = &quot;hv&quot;, pval = TRUE) Se observa como los sujetos que han mantenido el ciclo de quimioterapia muestran una mayor probabilidad de supervivencia que los que no lo han mantenido. Sin embargo, las medianas de supervivencia entre ambos grupos se diferencia únicamente en 8 meses, y el p-valor resulta no significativo. Tenemos evidencias para concluir que no hay evidencias estadísticas para concluir que las curvas de supervivencia son distintas para cada uno de los grupos considerados. 15.2.2 Veteranos Para este conjunto de datos obtenemos el resumen de la mediana de supervivencia para todo el conjunto de datos, y representamos la función de supervivencia y la mediana de supervivencia. # Estimación fit &lt;- survfit(Surv(time,status) ~ 1, data = veteran) fit ## Call: survfit(formula = Surv(time, status) ~ 1, data = veteran) ## ## n events median 0.95LCL 0.95UCL ## [1,] 137 128 80 52 105 # Gráfica de la función de supervivencia e IC ggsurvplot(fit, data = veteran, palette = &quot;blue&quot;, conf.int = FALSE, surv.median.line = &quot;hv&quot;) La mediana de supervivencia se sitúa en 80 semanas con un intervalo de confianza del 95% entre 52 y 105 semanas Realizamos ahora el análisis considerando la variable ‘trt’ que indica el tratamiento del sujeto. Representamos las curvas de supervivencia, la mediana de supervivencia, y el pvalor del contraste de comparación de funciones hazard. # Estimación fit &lt;- survfit(Surv(time, status) ~ trt, data = veteran) fit ## Call: survfit(formula = Surv(time, status) ~ trt, data = veteran) ## ## n events median 0.95LCL 0.95UCL ## trt=1 69 64 103.0 59 132 ## trt=2 68 64 52.5 44 95 # Gráfica de la función de supervivencia y mediana de supervivencia ggsurvplot(fit, data = veteran, conf.int = TRUE, conf.int.style = &quot;step&quot;, surv.median.line = &quot;hv&quot;, pval = TRUE) Podemos ver que no existen diferencias entre las curvas de supervivencia para los dos grupos considerados (p-valor superior a 0.05). Probamos ahora con la variable celltype. Como esta variable tiene cuatro grupos no representaremos los intervalos de confianza. # Estimación fit &lt;- survfit(Surv(time,status) ~ celltype, data = veteran) fit ## Call: survfit(formula = Surv(time, status) ~ celltype, data = veteran) ## ## n events median 0.95LCL 0.95UCL ## celltype=squamous 35 31 118 82 314 ## celltype=smallcell 48 45 51 25 63 ## celltype=adeno 27 26 51 35 92 ## celltype=large 27 26 156 105 231 # Gráfica de la función de supervivencia y mediana de supervivencia ggsurvplot(fit, data = veteran, surv.median.line = &quot;hv&quot;, pval = TRUE) En este caso podemos ver que si existen diferencias entre las curvas de supervivencia (p-valor inferior a 0.05). AL menos existen dos funciones de supervivencia que pueden ser consideradas distintas. El problema es que el test no nos permite conocer que grupos son los que son diferentes. 15.2.3 Cáncer de pulmón Para este conjunto de datos obtenemos el resumen de la mediana de supervivencia para todo el conjunto de datos, y representamos la función de supervivencia y la mediana de supervivencia. En este caso la variable status no está codificado con 0-1 y debemos construir una nueva variable. Además añadimos las etiquetas de los factores presentes en el banco de datos. # Creamos la nueva varaible lung &lt;- lung %&gt;% mutate(censurado = status - 1, sex = fct_recode(as.factor(sex), &quot;Male&quot; = &quot;1&quot;, &quot;Female&quot; = &quot;2&quot;)) Estimamos ahora la función de supervivencia # Estimación fit &lt;- survfit(Surv(time, censurado) ~ 1, data = lung) fit ## Call: survfit(formula = Surv(time, censurado) ~ 1, data = lung) ## ## n events median 0.95LCL 0.95UCL ## [1,] 228 165 310 285 363 # Gráfica de la función de supervivencia e IC ggsurvplot(fit, data = lung, palette = &quot;blue&quot;, conf.int = FALSE, surv.median.line = &quot;hv&quot;) ¿Cómo interpretamos esta función de supervivencia? Utilizamos ahora la variable sex # Estimación fit &lt;- survfit(Surv(time, censurado) ~ sex, data = lung) fit ## Call: survfit(formula = Surv(time, censurado) ~ sex, data = lung) ## ## n events median 0.95LCL 0.95UCL ## sex=Male 138 112 270 212 310 ## sex=Female 90 53 426 348 550 # Gráfica de la función de supervivencia e IC ggsurvplot(fit, data = lung, conf.int = TRUE, conf.int.style = &quot;step&quot;, surv.median.line = &quot;hv&quot;, pval = TRUE) ¿Cómo interpretamos estos resultados? ¿Podemos considerar las curvas de supervivencia iguales o distintas? 15.3 Modelos de supervivencia En las situaciones experimentales en las que deseamos estudiar la supervivencia de un conjunto de sujetos en función de un conjunto \\(X = (X_1,...,X_p)\\) de variables predictoras, es decir, variables que pueden afectar o caracterizar su supervivencia, es necesario establecer modelos estadísticos capaces de analizar dichas relaciones. La construcción de este tipo de modelos que depende del tiempo y de las predictoras se hace a través el análisis de las función hazard asociada \\(h(t;X)\\). El modelo más habitual en esta situación es el modelo hazard proporcional que separa en dos componentes la función hazard, una correspondiente al tiempo de supervivencia y otra a las variables predictoras, de la forma siguiente: \\[h(t;X) = h(t)exp(X\\beta)\\] donde \\(h(t)\\) es la función hazard base y describe el riesgo para individuos cuando las predictoras toman valor 0, es decir \\(x = O\\); \\(exp(X\\beta)\\) es el riesgo relativo, y representa la reducción o incremento del riesgo asociada con el conjunto de características \\(X\\), que es similar para todas las duraciones \\(t\\). La exponencial está justificada por la necesidad de positivista y la hipótesis de un efecto multiplicativo de las covariables en los hazards. Este modelo implica que el cociente de hazards (\\(hr\\)) de dos individuos depende de la diferencia entre sus predictores lineales en cualquier instante t, es decir, si \\(x\\) y \\(x^*\\) denotan a los valores de las predictoras para ambos sujetos tendríamos que: \\[hr(x,x^*) = \\frac{h(t)exp(x\\beta)}{h(t)exp(x^*\\beta)} = exp((x-x^*)\\beta)\\] Si solo tenemos una variable predictora de tipo factor con posibles valores 0 o 1, tendríamos la expresión para la función hazard asociada a cada respuesta: \\[h(t;X = 0) = h(t); \\text{ y } h(t;X = 1) = h(t)exp(\\beta)\\] de forma que el el hazard rate viene dado por \\(hr(x = 1,x = 0) = exp(\\beta)\\). Esto implica que dicho coeficiente representa el incremento en el logaritmo del hazard rate, esto es: \\[log(hr(x = 1, x = 0)) = \\beta\\] En este caso cuando \\(exp(\\beta)&gt;0\\) tenemos que \\(hr &gt; 1\\) indicando que hay un incremento el riesgo, y por tanto una reducción de la supervivencia. Cuando \\(exp(\\beta) &lt; 0\\) tenemos que \\(hr &lt; 1\\) indicando que hay un descenso en el riesgo, y por tanto un aumento de la supervivencia. Si la variable predictora es de tipo continuo de forma que \\(\\delta = x -x^*\\) es la diferencia entre los valores para dos sujetos, el logaritmo del hazard rate nos da: \\[log(hr(x,x^*)) = \\delta\\beta\\] Si el incremento entre los dos valores es de un unidad (\\(\\delta = 1\\)), \\(\\beta\\) representa el incremento en el hazard rate por cada unidad que aumentamos el valor de la variable predictora. La interpretación del \\(hr\\) es igual que el caso de un factor. Si \\(hr &gt; 1\\) aumenta el riesgo y si es menor que uno disminuye el riesgo Para facilitar la interpretación de los coeficientes se plantea la modelización del logaritmo del hazard mediante la expresión: \\[log(h(t;X)) = log(h(t)) + X\\beta\\] donde queda claro que el efecto de las predictoras afecta de forma lineal a la función hazard. Esta formulación es muy similar a la de los modelos lineales generalizados con función de enlace \\(log()\\) y con un offset dado por \\(log(h(t))\\). EL problema es que en muchas ocasiones desconocemos la forma de la función \\(h\\), y por tanto, no podemos determinar de forma exacta el offset asociado. Los modelos de regresión de Cox o de supervivencia no paramétrica no asumen una forma específica para \\(h\\) al estilo de los modelos de suavizado. La estimación de este tipo de modelos se hace mediante la función: modelo &lt;- coxph(Surv(time,status) ~ predictoras, data = dataset) Para el resumen del modelo utilizaremos las funciones summary(modelo) que nos proporciona el proceso de estimación del modelo, y ggforest(modelo) que nos proporciona un resumen gráfico del modelo ajustado (estimaciones del \\(hr\\), intervalos de confianza y p-valores asociados para cada variable predictora presente en el modelo). Para representar le modelo ajustado utilizaremos la función ggcoxadjustedcurves(modelo, dataset, variable) que permite representar la función de supervivencia asociada con la variable de interés o con una factor creado a partir de una de las variables presente en el modelo ajustado. 15.3.1 Hipótesis del modelo Las hipótesis de este modelo son: Proporcionalidad en la función hazard El efecto de las predictoras es lineal sobre el logaritmo de la función hazard (asumiendo que no hay interacciones entre las predictoras) Estas hipótesis deben verificarse una vez estimado el modelo de supervivencia a través de la obtención de los residuos del modelo. En este caso trabajamos con los residuos de Schoenfeld. El incumplimiento de alguna de estas hipótesis implicará el planteamiento de un nuevo modelo. Para la verificación de las hipótesis utilizamos las funciones: cox.zph(modelo) que permite verificar la hipótesis de hazards proporcionales mediante los residuos de Schoenfeld. La verificación gráfica se puede realizar mediante la función ggcoxzph(modelo) que representa para cada predictora el gráfico de residuos vs tiempo. ggcoxdiagnostics(modelo) que permite representar los residuos en función del tiempo, en función del predictor lineal o del tiempo para verificar la hipótesis de linealidad. 15.3.2 Análisis Cáncer de pulmón Procedemos en este punto a mostrar el análisis completo de los datos correspondientes al ejemplo de cáncer de pulmón. Realizaremos el análisis completo mostrando el uso de todas las funciones tanto para la estimación y diagnóstico del modelo de regresión de Cox aplicado en este caso. En primer lugar recodificamos la variable de status para que coincida con una variable 0-1. # Creamos la nueva varaible lung &lt;- lung %&gt;% mutate(censurado = status - 1, sex = fct_recode(as.factor(sex),&quot;Male&quot; = &quot;1&quot;, &quot;Female&quot; = &quot;2&quot;)) 15.3.2.1 Estimación del modelo Por el momento plateamos un modelo en el que solo tenemos una variable predictora. Consideremos la variable sex dado que ya pudimos ver en el análisis preliminar que se apreciaban diferencias en la supervivencia por este factos. # Ajuste del modelo fit &lt;- coxph(Surv(time, status) ~ sex, data = lung) # Resumen del modelo ajustado fit ## Call: ## coxph(formula = Surv(time, status) ~ sex, data = lung) ## ## coef exp(coef) se(coef) z p ## sexFemale -0.5310 0.5880 0.1672 -3.176 0.00149 ## ## Likelihood ratio test=10.63 on 1 df, p=0.001111 ## n= 228, number of events= 165 El hazard rate asociado con le factor (columna exp(coef)) es menor que 1 lo que indica que las mujeres tienen más supervivencia que los hombres. Además el test de bondad de ajuste del modelo (“likelihood ratio test”) resulta significativo indicando que el sexo contribuye claramente a explicar la supervivencia de los sujetos del estudio. A continuación se muestran gráficamente los intervalos de confianza y pvalores asociados con le modelo estimado. # Gráfico de la relevancia de los coeficientes ggforest(fit) Como podemos ver se usa la categoría “Male” como referencia para la estimación de efectos del modelo. El hazard ratio asociado con las mujeres se sitúa en 0.58, lo que indica una fuerte relación entre el sexo de los pacientes y la disminución del riesgo de muerte.Por tanto, ser mujer reduce el riesgo de muerte por un factor de 0,58 o equivalentemente un 42% (100*(1-0.58)). Concluimos que ser mujer se asocia con buen pronóstico. El intervalo de confianza para el hazard ratio en las mujeres se sitúa entre 0.42 y 0.82 indicando una reducción del riesgo de entre el 18% y el 58%. # Gráfico de supervivencia ggadjustedcurves(fit, data =lung, variable = &quot;sex&quot;, palette = &quot;lancet&quot;) # Gráfico con intervalos de confianza sex.df &lt;- with(lung, data.frame(sex = c(&quot;Male&quot;, &quot;Female&quot;))) ggsurvplot(survfit(fit,newdata = sex.df), data = lung, palette = &quot;lancet&quot;, conf.int = TRUE, conf.int.style = &quot;step&quot;, legend.labs=c(&quot;Male&quot;, &quot;Female&quot;)) A partir de la solución gráfica es posible obtener los datos de supervivencia para ambos grupos, así como la diferencia de supervivencia. El código necesario es # Guardamos la información del gráfico datosgraf &lt;- ggadjustedcurves(fit, data=lung, variable = &quot;sex&quot;, palette = &quot;lancet&quot;)$dat datossurv &lt;- spread(datosgraf, key = variable, value =surv) datossurv &lt;- datossurv %&gt;% mutate(dif = Female - Male) # Gráfico ggplot(datossurv,aes(x = time, y = dif)) + geom_smooth() + theme_minimal() Se observa que entre los 375 y 500 días la probabilidad de supervivencia es aproximadamente 0.2 superior en las mujeres que en los hombres. 15.3.2.2 Diagnóstico del modelo El modelo de Cox hace varias suposiciones. Por lo tanto, es importante evaluar si un modelo de regresión de Cox ajustado describe adecuadamente los datos. En concreto debemos comprobar: Suposición de riesgos proporcionales. Existen observaciones influyentes (o valores atípicos). Detectar la no linealidad de los efectos de las variables predictoras en la función hazard. Para verificar estas suposiciones del modelo, se utilizan diferentes tipos de residuos. Los residuos a considerar son: Residuos de Schoenfeld vs time para verificar la suposición de riesgos proporcionales Residuos de Schoenfeld vs time para cada predictora para evaluar la no linealidad Desviación residual (transformación simétrica de los residuos de Martingale) para examinar observaciones influyentes 15.3.2.2.1 Riesgos porporcionales Utilizamos la función cox.zph() para evaluar mediante tests estadísticos la hipótesis de riesgos proporcionales, y la función ggcoxzph() para el análisis gráfico. # Tests de riesgos proporcionales ftest &lt;- cox.zph(fit) ftest ## chisq df p ## sex 2.86 1 0.091 ## GLOBAL 2.86 1 0.091 Dado que el pvalor asociado del test resulta no significativo no podemos descartar la hipótesis de riesgos proporcionales asociados con la variable sexo. # Tests de riesgos proporcionales ggcoxzph(ftest) No se observa ningún tipo de tendencia en la curva ajustada (línea continua) entre tiempo y residuos, lo que da indicios de la verificación de la hipótesis de riesgos proporcionales. 15.3.2.2.2 Observaciones influyentes La detección de observaciones influyentes se realiza mediante métodos gráficos # Observaciones influyentes ggcoxdiagnostics(fit, type = &quot;deviance&quot;, linear.predictions = FALSE) El patrón de residuos es bastante simétrico respecto de cero. Además no hay residuos con valores claramente fuera del rango (-3, 3), indicando que no hay ninguna observación que pueda identificarse como anómala. En caso de existir alguna deberíamos eliminarla y ajustar el nuevo modelo. 15.3.2.2.3 No linealidad El test de no linealidad sólo se puede interpretar para variables de tipo numérico donde se pueden plantear diferentes tendencia en al respuesta en función de diferentes transformaciones numéricas de la predictora. En este caso realizamos el gráfico de análisis pero no lo interpretamos. # Observaciones influyentes ggcoxdiagnostics(fit, type = &quot;schoenfeld&quot;, ox.scale = &quot;time&quot;) 15.3.3 Múltiples predictoras Pasamos ahora a analizar el modelo con múltiples predictoras. En principio en este tipo de modelos no se consideran interacciones entre las predictoras para determinar el efecto individual que cada una de ellas puede tener en la supervivencia de los sujetos considerados. En nuestro caso consideramos las variables: sex (factor), age (numérica), y wt.loss (numérica). El modelo ajustado viene dado por: # Ajuste del modelo fitcom &lt;- coxph(Surv(time, status) ~ sex + age + wt.loss, data = lung) # Resumen del modelo ajustado fitcom ## Call: ## coxph(formula = Surv(time, status) ~ sex + age + wt.loss, data = lung) ## ## coef exp(coef) se(coef) z p ## sexFemale -0.5210319 0.5939074 0.1743541 -2.988 0.0028 ## age 0.0200882 1.0202913 0.0096644 2.079 0.0377 ## wt.loss 0.0007596 1.0007599 0.0061934 0.123 0.9024 ## ## Likelihood ratio test=14.67 on 3 df, p=0.002122 ## n= 214, number of events= 152 ## (14 observations deleted due to missingness) A la hora de interpretar los resultados de este modelo hay que tener en cuenta que las estimaciones proporcionadas corresponden al efecto de cada variable cuando el resto se mantienen constantes. Eso quiere decir que el riesgo de 0.59 para la variable sexo se obtiene fijando el resto de variables en su valor medio. En este caso tendríamos que la edad se fijaría en 62.47 y wt.loss en 9.8. Por tanto, el riesgo de muerte se reduce en las mujeres en un 43% (0.57) para una edad de 62 años y una pérdida de peso de 9.8 kg. En cuanto a los pvalores podemos ver que tanto la variable sex como age contribuyen significativamente la supervivencia de los sujetos, pero no así la variable wt.loss Por cada aumento de una unidad de edad el riesgo de morir aumenta en un 2% (1.02). El test global indica que el modelo construido es útil para explicar la supervivencia de los sujetos. Veamos el análisis gráfico de los coeficientes del modelo: # Gráfico de la relevancia de los coeficientes ggforest(fitcom) Representamos ahora las curvas de supervivencia ajustadas. Recordemos que sólo se representan la curvas de supervivencia comparando por variables de tipo factor. En este caso tenemos dos variables de tipo numérico, de forma que si queremos representar la supervivencia asociada con cada una de ellas las deberemos convertir en factores de una forma adecuada. Esta forma de proceder es muy habitual den los modelos de supervivencia donde siempre son preferibles variables de tipo factor a las numéricas. En este caso los gráficos son condicionales a los valores medios de las variables numéricas, tal y como hemos explicado en la interpretación de los parámetros del modelo. # Gráfico de supervivencia para sex ggadjustedcurves(fitcom, data = lung, variable = &quot;sex&quot;, palette = &quot;lancet&quot;) # Gráfico con intervalos de confianza tomando los valores medios de las numéricas sex.df &lt;- with(lung, data.frame(sex = c(&quot;Male&quot;, &quot;Female&quot;), age = rep(62.5,2), wt.loss = rep(9.5,2))) ggsurvplot(survfit(fit, newdata = sex.df), data = lung, palette = &quot;lancet&quot;, conf.int = TRUE, conf.int.style = &quot;step&quot;, legend.labs=c(&quot;Male&quot;, &quot;Female&quot;)) Para representar las curvas de supervivencia para la variable numérica procedemos construyendo una nueva variable categórica artificial a partir de los cuantiles de la variable numérica, y sin necesitad de ajustar el modelo. # Edad # Variable artificial lung$agenew &lt;- cut(lung$age, quantile(lung$age, na.rm = TRUE)) lung$wtnew &lt;- cut(lung$wt.loss, quantile(lung$wt.loss, na.rm = TRUE)) # Ajuste del modelo fitcom &lt;- coxph(Surv(time, status) ~ sex + agenew + wtnew, data = lung) # Gráfico de supervivencia para edad ggadjustedcurves(fitcom, data = lung, variable = &quot;agenew&quot;, palette = &quot;lancet&quot;) # Pérdida de peso # Gráfico de supervivencia para sex ggadjustedcurves(fitcom, data = lung, variable = &quot;wtnew&quot;, palette = &quot;lancet&quot;) Podemos ver que los sujetos de mayor edad tienen una supervivencia menor, así como los que han perdido más peso en los último seis meses. Sin embargo, esta forma de proceder no es óptima ya que hay muchas curvas de supervivencia muy similares. Para evitar esto podemos buscar el punto de la variable numérica que separa a los sujeto en dos grupos que podemos considerar que tienen supervivencias distintas. Para realizar esto utilizamos la función surv_cutpoint. # Puntos de corte corte &lt;- surv_cutpoint(lung, time = &quot;time&quot;, event = &quot;status&quot;, variables = c(&quot;age&quot;, &quot;wt.loss&quot;)) corte ## cutpoint statistic ## age 70 2.013619 ## wt.loss 9 1.756750 El valor para edad se sitúa en los 70 años mientras que para la pérdida de peso es de 9kg. Veamos los gráfico con las variables artificiales # Variable artificial edad lung$agenew &lt;- ifelse(lung$age &gt;= corte$age$estimate,&quot;+70&quot;,&quot;-70&quot;) lung$wtnew &lt;- ifelse(lung$wt.loss &gt;= corte$wt.loss$estimate,&quot;+9&quot;,&quot;-9&quot;) # Ajuste del modelo fitcom &lt;- coxph(Surv(time, status) ~ sex + agenew + wtnew, data = lung) # Gráfico de supervivencia para edad ggadjustedcurves(fitcom, data = lung, variable = &quot;agenew&quot;, palette = &quot;lancet&quot;) # Gráfico de supervivencia para pérdida de peso ggadjustedcurves(fitcom, data = lung, variable = &quot;wtnew&quot;, palette = &quot;lancet&quot;) Para variables numéricas con pocos valores posibles resulta más útil introducir dicha variable en el modelo como un nivel de estratificación son necesidad de estimar el coeficiente asociado. En este caso las variables ph.ecog y ph.karno se pueden tomar como estratos, ya que se tratan de valoraciones sobre los sujetos que no tienen porque tener relación directa con la supervivencia. En este caso el modelo a ajustar viene dado por: # Ajuste del modelo coxph(Surv(time, status) ~ sex + age + wt.loss + strata(ph.ecog) + strata(ph.karno), data = lung) ## Call: ## coxph(formula = Surv(time, status) ~ sex + age + wt.loss + strata(ph.ecog) + ## strata(ph.karno), data = lung) ## ## coef exp(coef) se(coef) z p ## sexFemale -0.632793 0.531106 0.188563 -3.356 0.000791 ## age 0.020913 1.021133 0.010562 1.980 0.047702 ## wt.loss -0.009286 0.990757 0.007059 -1.315 0.188359 ## ## Likelihood ratio test=17.16 on 3 df, p=0.0006537 ## n= 213, number of events= 151 ## (15 observations deleted due to missingness) ¿Cómo interpretaríamos este modelo? También podríamos ajustar el modelo de supervivencia con los nuevos factores creados: # Ajuste del modelo fitcomp2 &lt;- coxph(Surv(time, status) ~ sex + agenew + wtnew, data = lung) fitcomp2 ## Call: ## coxph(formula = Surv(time, status) ~ sex + agenew + wtnew, data = lung) ## ## coef exp(coef) se(coef) z p ## sexFemale -0.5160 0.5969 0.1744 -2.960 0.00308 ## agenew+70 0.3754 1.4555 0.1800 2.086 0.03702 ## wtnew+9 0.2370 1.2675 0.1628 1.456 0.14549 ## ## Likelihood ratio test=16.34 on 3 df, p=0.0009675 ## n= 214, number of events= 152 ## (14 observations deleted due to missingness) Se puede ver como el efecto de la edad es mucho más claro en este modelo. ¿Cuáles serían los riesgos asociados con cada una de las variables? Procedemos con el gráfico de curvas de supervivencia estimadas: # Gráfico conjunto de todos los fatores ggsurvplot_facet(fitcomp2, lung, facet.by = &quot;wtnew&quot;, palette = &quot;lancet&quot;, pval = TRUE) Con este tipo de gráficos resulta posible estudiar como se modifica la supervivencia cuando tenemos variables que no están en el modelo. Partimos del modelo más simple donde sólo consideramos la variable sexo, y estudiamos las funciones de supervivencia si incluimos las variables edad y pérdida de peso en forma de factores: # Eliminamos valores pérdidos lung &lt;- na.omit(lung) # Gráfico conjunto de todos los fatores ggsurvplot_facet(fit, lung, facet.by = c(&quot;agenew&quot;,&quot;wtnew&quot;), palette = &quot;lancet&quot;, pval = TRUE) Este gráfico nos permite comparar el efecto de las combinaciones de los nuevos factores teniendo en cuenta el modelo por sexo. Es casi como un estudio de la interacción o de la inclusión de un factor en el modelo. 15.3.4 Diagnóstico del modelo Comenzamos con el diagnóstico del modelo. En principio trabajamos con le modelo tomando las variables edad y peso perdido como numéricas. # Ajuste del modelo fitcomp &lt;- coxph(Surv(time, status) ~ sex + age + wt.loss, data = lung) 15.3.4.1 Riesgos porporcionales # Tests de riesgos proporcionales ftest &lt;- cox.zph(fitcomp) ftest ## chisq df p ## sex 1.003 1 0.32 ## age 0.668 1 0.41 ## wt.loss 0.351 1 0.55 ## GLOBAL 1.868 3 0.60 Todos los pvalores (tanto los individuales de cada variable como el global para el modelo) son superiores a 0.05 indicando que se verifica la hipótesis de riesgos proporcionales. Veamos el análisis gráfico: # Gráfico de riesgos proporcionales ggcoxzph(ftest) 15.3.4.2 Observaciones influyentes # Observaciones influyentes ggcoxdiagnostics(fitcomp, type = &quot;deviance&quot;, linear.predictions = FALSE) No se aprecian observaciones influyentes. Podemos ver que se cumplen todas la hipótesis del modelo, pero ¿podemos considerar que los modelos ajustados son iguales en su capacidad explicativa? Para poder verificar esto realizamos el test de comparación de modelos basado en el test Ji-cuadrado. ¿Podríamos prescindir de alguna variable? Comparamos los siguientes modelos para obtener el modelo con menor número de predictoras pero con la misma capacidad explicativa. Construimos modelos anidados para favorecer la comparación: # Ajuste del modelos fit1 &lt;- coxph(Surv(time, status) ~ sex, data = lung) fit2 &lt;- coxph(Surv(time, status) ~ sex + agenew, data = lung) fit3 &lt;- coxph(Surv(time, status) ~ sex + agenew + wt.loss, data = lung) # Comparación summary(fit) summary(fit2) summary(fit3) Puesto que no hay ningún pvalor significativo podríamos concluir que el mejor modelo es aquel que sólo contiene la variable sexo, pero podríamos llegar a modelos erróneos. En el caso de tener factores que no parecen aportar capacidad explicativa pero que si tienen sentido desde el punto de vista experimental, es necesario introducirlos en el modelo de alguna forma. En este caso utilizamos la denominada estratificación. Ajustamos los nuevos modelos considerando la edad como variable estratificada. Al considerarla de esta forma no podremos evaluar su riesgo de forma directa en la supervivencia, pero si en la supervivencia global. En este caso podemos ver que el modelo 2 es claramente distinto del modelo 1, pero no es distinto del modelo 3. Por tanto, nuestro modelo para estos datos sería el 2. # Ajuste del modelo fitcomp &lt;- coxph(Surv(time, status) ~ sex + strata(agenew), data = lung) fitcomp ## Call: ## coxph(formula = Surv(time, status) ~ sex + strata(agenew), data = lung) ## ## coef exp(coef) se(coef) z p ## sexFemale -0.4645 0.6285 0.1981 -2.344 0.0191 ## ## Likelihood ratio test=5.75 on 1 df, p=0.01645 ## n= 167, number of events= 120 Veamos el diagnóstico # Tests de riesgos proporcionales ftest &lt;- cox.zph(fitcomp) ftest ## chisq df p ## sex 0.944 1 0.33 ## GLOBAL 0.944 1 0.33 # Observaciones influyentes ggcoxdiagnostics(fitcomp, type = &quot;deviance&quot;, linear.predictions = FALSE) # No linealidad ggcoxdiagnostics(fitcomp, type = &quot;schoenfeld&quot;, ox.scale = &quot;time&quot;) Se cumplen todas las hipótesis. Representamos las funciones de supervivencia para este modelo # Supervivencia para menores de 70 años sex.df &lt;- with(lung, data.frame(sex = c(&quot;Male&quot;, &quot;Female&quot;), agenew = c(&quot;-70&quot;,&quot;-70&quot;))) ggsurvplot(survfit(fitcomp,newdata = sex.df), data = lung, palette = &quot;lancet&quot;, conf.int = TRUE, conf.int.style = &quot;step&quot;, legend.labs=c(&quot;Male&quot;, &quot;Female&quot;)) # Supervivencia para mayores de 70 años sex.df &lt;- with(lung, data.frame(sex = c(&quot;Male&quot;, &quot;Female&quot;), agenew = c(&quot;+70&quot;,&quot;+70&quot;))) ggsurvplot(survfit(fitcomp,newdata = sex.df), data = lung, palette = &quot;lancet&quot;, conf.int = TRUE, conf.int.style = &quot;step&quot;, legend.labs=c(&quot;Male&quot;, &quot;Female&quot;)) Se puede ver como si se aprecian diferencias por sexo para los menores de 70 años, pero no ocurre lo mismo para los mayores de 70 años (el intervalo de confianza de los hombres contiene a la estimación de supervivencia para las mujeres). Existen más modificaciones de este tipo de modelos que por límite de tiempo no consideramos aquí como son: la posible inclusión de interacciones, modelos doble censurados, incorporación de efectos de grupos o sujetos (camadas, hospitales,…). parte de estas situaciones aparecen en los ejemplos planteados al inicio de este tema y se trataran con lago de detalle en las sesiones prácticas. 15.4 Ejercicios Colección de ejercicios sobre modelos de supervivencia. No olvides cargar las librerías para realizar los ejercicios. Ejercicio 1. Los datos siguientes corresponden a un pequeño experimento en el que 7 de un total de 16 ratones fueron aleatoriamente seleccionados para recibir un nuevo tratamiento médico. Los 9 ratones restantes fueron asignados a un grupo control en el que no se administró ningún tipo de tratamiento. El objetivo del tratamiento era prolongar el tiempo de supervivencia después de una operación quinírgica. El banco de datos contiene los tiempos de supervivencia (en días) tras la operación para los 16 ratones. El objetivo principal es saber si el tratamiento prolongaba la vida de los ratones tras la operación grupo &lt;- c(rep(&quot;Tratado&quot;, 7), rep(&quot;Control&quot;, 9)) tiempo &lt;- c(94, 38, 23, 19, 99, 16,141, 52, 104, 146, 10, 51, 30, 40, 27, 46) Ejercicio 2. Los datos de la Tabla siguiente son: ‘tiemsup,’ que es el tiempo hasta la muerte (en semanas) desde la diagnosis de leucemia, y ‘logcel,’ igual al log 10 del número inicial de células blancas en la sangre. Se dispone de datos de diecisiete pacientes que sufrían de leucemia. ¿Cuáles son tus conclusiones sobre la utilidad de saber el número de células blancas en la sangre para predecir el tiempo de supervivencia? ¿Cuál es la probabilidad de sobrevivir de un paciente con 5000 células blancas en la sangre? tiemsup &lt;- c(65, 156, 100, 134, 16, 108, 121, 5, 65, 4, 39, 143, 56, 26, 22, 1, 1) logcel &lt;- c(3.36, 2.88, 3.63, 3.41, 3.78, 4.02, 4.00, 4.72, 5.00, 4.23, 3.73, 3.85, 3.97, 4.51, 4.54, 5.00, 5.00) Ejercicio 3. Un total de 90 pacientes que sufrían ele cancer gástrico fueron asignados aleatoriamente a dos grupos. Un gupo fue tratado con quimioterapia y radiación, mientras que el otro sólo recibió quimioterapia. Se recoge además el tiempo de superviviencia si dicho datos está censurado (0) o no (1). ¿Existe evidencia para concluir que la radiación prolonga el tiempo de supervivencia? group &lt;- c(rep(&quot;Q+R&quot;, 45),rep(&quot;Q&quot;, 45)) censor &lt;- c(rep(1, 36),rep(0, 9),rep(1, 36),rep(0, 9)) time &lt;- c(17, 42, 44, 48, 60, 72, 74, 95, 103, 108, 122, 144, 167, 170, 183, 185, 193, 195, 197, 208, 234, 235, 254, 307, 315, 401, 445, 464, 484, 528, 542, 567, 577, 580, 795, 855, 1174, 1214, 1232, 1366, 1455, 1585, 1622, 1626, 1736, 1, 63, 105, 125, 182, 216, 250, 262, 301, 301, 342, 354, 356, 358, 380, 383, 383, 388, 394, 408, 460, 489, 499, 523, 524, 535, 562, 569, 675, 676, 748, 778, 786, 797, 955, 968, 977, 1245, 1271, 1420, 1460, 1516, 1551, 1690, 1694) Ejercicio 4. Los datos siguientes contienen los tiempos de remisión de pacientes con leucemia para dos grupos de pacientes ¿Existen diferencias en los tiempos de supervivencia para ambos grupos? Realiza un estudio completo del modelo de superviviencia asocaido con estos datos. glm_surv_01=read_csv(&quot;https://goo.gl/d4YI9g&quot;, col_types = &quot;cid&quot;) str(glm_surv_01) ## spec_tbl_df [42 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ group : chr [1:42] &quot;control&quot; &quot;control&quot; &quot;control&quot; &quot;control&quot; ... ## $ censor: int [1:42] 1 1 1 1 1 1 1 1 1 1 ... ## $ time : num [1:42] 1 1 2 2 3 4 4 5 5 8 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. group = col_character(), ## .. censor = col_integer(), ## .. time = col_double() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; Ejercicio 5. El conjunto de datos siguiente contiene los datos de supervivencia (en meses) de pacientes hepatitis crónica activa y que son dividios en dos grupos. Al grupo tratado se le suministra Prednisona mientras que el otro grupo actúa como control. ¿Existen diferencias en los tiempos de supervivencia para ambos grupos? Realiza un estudio completo del modelo de superviviencia asocaido con estos datos. glm_surv_02=read_csv(&quot;https://goo.gl/Rzxo3o&quot;, col_types = &quot;dcc&quot;) str(glm_surv_02) ## spec_tbl_df [44 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame) ## $ stime : num [1:44] 2 6 12 54 56 68 89 96 96 125 ... ## $ censor: chr [1:44] &quot;died&quot; &quot;died&quot; &quot;died&quot; &quot;died&quot; ... ## $ group : chr [1:44] &quot;prednisolone&quot; &quot;prednisolone&quot; &quot;prednisolone&quot; &quot;prednisolone&quot; ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. stime = col_double(), ## .. censor = col_character(), ## .. group = col_character() ## .. ) ## - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; Ejercicio 6. Los siguientes datos representan la supervivencia en días desde el ingreso al ensayo de pacientes con linfoma histiocítico difuso. Se comparan dos grupos diferentes de pacientes, aquellos con estadio III y aquellos con enfermedad en estadio IV. group &lt;- c(rep(&quot;SIII&quot;, 19),rep(&quot;SIV&quot;, 61)) censor &lt;- c(1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) time &lt;- c(6, 19, 32, 42, 42, 43, 94, 126, 169, 207, 211, 227, 253, 255, 270, 310, 316, 335, 346, 4, 6, 10, 11, 11, 11, 13, 17, 20, 20, 21, 22, 24, 24, 29, 30, 30, 31, 33, 34, 35, 39, 40, 41, 43, 45, 46, 50, 56, 61, 61, 63, 68, 82, 85, 88, 89, 90, 93, 104, 110, 134, 137, 160, 169, 171, 173, 175, 184, 201, 222, 235, 247, 260, 284, 290, 291, 302, 304, 341, 345) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
